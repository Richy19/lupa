export Compiler, Grammar

class Scope {
   has entries = { }
   has outer
   method __init(outer) {
      self.outer = outer
   }
   method lookup(name) {
      if name in self.entries {
         return self.entries[name]
      }
      else if self.outer {
         return self.outer.lookup(name)
      }
   }
   method define(name, info) {
      self.entries[name] = info || { }
   }
}

class Context {
   has scope = Scope()
   has exports = { }

   method enter() {
      self.scope = Scope(self.scope)
   }
   method leave() {
      if 'outer' in self.scope {
         var outer = self.scope.outer
         self.scope = outer
         return outer
      }
      error("no outer scope")
   }
   method define(name, info) {
      self.scope.define(name, info)
   }
   method lookup(name) {
      self.scope.lookup(name)
   }
}

object Grammar {

   function error_line(src, pos) {
      var line = 1
      var index, limit = 1, pos
      while index <= limit {
         var s, e = src.find("\n", index, true)
         if s == nil || e > limit { break }
         index = e + 1
         line  = line + 1
      }
      return line
   }
   function error_near(src, pos) {
      if (#src < pos + 20) {
         return src.sub(pos)
      }
      else {
         return src.sub(pos, pos + 20)~"..."
      }
   }
   function syntax_error(m) {
      return function(src, pos) {
         var line, near = error_line(src, pos), error_near(src, pos)
         error("SyntaxError: ${m||''} on line ${line} near '${near}'")
      }
   }

   var id_counter = 9
   function genid() {
      id_counter += 1
      return '_'~id_counter
   }

   function define(name, ctx, base, type, expr) {
      ctx.define(name, { base = base, type = type, expr = expr })
      return name
   }
   function define_const(name, ctx, ...) {
      ctx.define(name, ...)
      return
   }
   function enter(ctx) {
      ctx.enter()
      return
   }
   function leave(ctx) {
      ctx.leave()
      return
   }

   function lookup(name, ctx) {
      var info = ctx.lookup(name)
      if info {
         if info.base { return info.base~'.'~name }
         return name
      }
      return '__env.'~name
   }
   function lookup_or_define(name, ctx) {
      var info = ctx.lookup(name)
      if !info {
         define(name, ctx, '__env')
         return '__env.'~name
      }
      if info.base {
         return info.base~'.'~name
      }
      return name
   }

   function quote(c) { "%q".format(c) }

   var nl      = / "\n" /
   var comment = / {~
      | ((!nl %s)* ("//" -> '--') (!nl .)* nl)
      | ("/*" -> '--[=[') (']=]' -> ']\=]' | !"*/" .)* ("*/" -> ']=]')
   ~} /
   var idsafe  = / !(%alnum | "_") /
   var s       = / (comment | %s)* /
   var semicol = / (";" -> '')? /
   var digits  = / (%digit {~ "_" -> '' ~}?)+ /
   var keyword = / (
      | "var" | "function" | "class" | "with" | "like" | "in"
      | "nil" | "true" | "false" | "typeof" | "return" | "as"
      | "for" | "throw" | "method" | "has" | "from" | "break"
      | "continue" | "import" | "export" | "try" | "catch" | "switch" | "case"
      | "default" | "finally" | "if" | "else" | "yield" | "rule"
   ) idsafe /

   var prec = {
      ["^^"]  = 4,
      ["*"]   = 5,
      ["/"]   = 5,
      ["%"]   = 5,
      ["+"]   = 6,
      ["-"]   = 6,
      ["~"]   = 6,
      [">>"]  = 7,
      ["<<"]  = 7,
      [">>>"] = 7,
      ["&"]   = 8,
      ["^"]   = 9,
      ["|"]   = 10,
      ["<="]  = 11,
      [">="]  = 11,
      ["<"]   = 11,
      [">"]   = 11,
      ["in"]  = 11,
      ["as"]  = 11,
      ["=="]  = 12,
      ["!="]  = 12,
      ["&&"]  = 13,
      ["||"]  = 14,
   }

   var unrops = {
      ["!"] = "not(%s)",
      ["#"] = "#(%s)",
      ["-"] = "-(%s)",
      ["~"] = "__env.__op_bnot(%s)",
      ["@"] = "__env.__op_spread(%s)",
      ["typeof"] = "__env.__op_typeof(%s)",
   }

   var binops = {
      ["^^"] = "(%s)^(%s)",
      ["*"] = "(%s)*(%s)",
      ["/"] = "(%s)/(%s)",
      ["%"] = "(%s)%%(%s)",
      ["+"] = "(%s)+(%s)",
      ["-"] = "(%s)-(%s)",
      ["~"] = "(%s)..(%s)",
      [">>"] = "__env.__op_rshift(%s,%s)",
      ["<<"] = "__env.__op_lshift(%s,%s)",
      [">>>"] = "__env.__op_arshift(%s,%s)",
      ["<="] = "(%s)<=(%s)",
      [">="] = "(%s)>=(%s)",
      ["<"] = "(%s)<(%s)",
      [">"] = "(%s)>(%s)",
      ["in"] = "__env.__op_in(%s,%s)",
      ["as"] = "__env.__op_as(%s,%s)",
      ["=="] = "(%s)==(%s)",
      ["!="] = "(%s)~=(%s)",
      ["&"] = "__env.__op_band(%s,%s)",
      ["^"] = "__env.__op_bxor(%s,%s)",
      ["|"] = "__env.__op_bor(%s,%s)",
      ["&&"] = "(%s)and(%s)",
      ["||"] = "(%s)or(%s)",
   }

   function fold_prefix(o,e) {
      if o == '#' && e.match('^%s*%.%.%.%s*$') {
         return '__env.select("#",...)'
      }
      return unrops[o].format(e)
   }

   function fold_infix(e) {
      var s = [ e[1] ]
      for i=2, #e {
         s[#s + 1] = e[i]
         while !binops[s[#s]] && s[#s - 1] {
            var p = s[#s - 1]
            var n = e[i + 1]
            if n == nil || prec[p] <= prec[n] {
               var b, o, a = s.pop(), s.pop(), s.pop()
               if !binops[o] {
                  error("bad expression: ${e}, stack: ${s}")
               }
               s.push(binops[o].format(a, b))
            }
            else {
               break
            }
         }
      }
      return s[1]
   }

   function make_slot_decl(ctx, name, type, body) {
      if type != 'nil' {
         type = lookup(type, ctx)
         return '__env.__has(self,"%s",%s,function(self) return %s(%s) end);'.format(name,type,type,body)
      }
      return '__env.__has(self,"%s",%s,function(self) return %s end);'.format(name,type,body)
   }

   function make_binop_bind(ctx, a1, a2, o, b) {
      a1 = Grammar.expr.match(a1, nil, ctx)
      var info = ctx.lookup(a1)
      var oper = binops[o]
      if info.type {
         var type = lookup(info.type, ctx)
         oper = (type~'(%s)').format(oper)
      }
      return a2.format(oper.format(a1,b))
   }

   function make_bind_expr(ctx, l, s1, s2, r) {
      if #l == 1 {
         var name = l[1].match('^([%w_]+)%s*=')
         if name {
            var info = ctx.lookup(name)
            if info.type {
               var type = lookup(info.type, ctx)
               r[1] = (type~'(%s)').format(r[1])
            }
         }
         return l[1].format(s2 ~ r.concat(','))
      }
      var t = [ ]
      for i=1, #l {
         t.push(genid())
         var name = l[i].match('^([%w_]+)%s*=')
         if name {
            var info = ctx.lookup(name)
            if info.type {
               var type = lookup(info.type, ctx)
               t[i] = (type~'(%s)').format(t[i])
            }
         }

         l[i] = l[i].format(t[i])
      }
      var b = [ ]
      b.push('local %s%s=%s%s;'.format(t.concat(','), s1, s2, r.concat(',')))
      b.push(l.concat(';'))
      return b.concat()
   } 

   function make_var_decl(ctx, lhs, rhs) {
      rhs = rhs || [ ]
      var tmp = [ ]
      var buf = [ ]

      if #rhs == 0 {
         return lhs.concat()
      }

      if #lhs == 1 {
         var info = ctx.lookup(lhs[1])
         if info.type {
            var type = lookup(info.type, ctx)
            rhs[1] = (type~'(%s)').format(rhs[1] || '')
         }
         return "%s=%s;".format(lhs[1], rhs[1] || '')
      }

      for i=1, #lhs {
         tmp.push(genid())
      }

      if #rhs > 0 {
         buf.push('%s=%s'.format(tmp.concat(','), rhs.concat(',')))
      }

      for i=1, #lhs {
         var info = ctx.lookup(lhs[i])
         if info.type {
            var type = lookup(info.type, ctx)
            tmp[i] = (type~'(%s)').format(tmp[i])
         }
      }

      buf.push('local %s=%s;'.format(lhs.concat(','), tmp.concat(',')))
      return buf.concat(';')
   }

   function make_params(ctx, list) {
      var head = [ ]
      if #list > 0 {
         for i=1, #list {
            var name = list[i]
            if !name.find('%.%.%.') {
               name = name.match('^%s*([^%s]+)%s*$')
               var info = ctx.lookup(name) 
               if info.expr {
                  head.push('if %s==nil then %s=%s end'.format(name,name,info.expr))
               }
               if info.type {
                  var type = lookup(info.type, ctx)
                  head.push('%s=%s(%s)'.format(name,type,name))
               }
            }
         }
         if list[#list].find('...', 1, true) {
            var last = list[#list]
            var name = last.match('%.%.%.([%w_]+)')
            list[#list] = "..."
            if name {
               var info = ctx.lookup(name) 
               if info.type {
                  var type = lookup(info.type, ctx)
                  head.push(('local %s=__env.Array(...):inject(%s)').format(name,type))
               }
               else {
                  head.push("local %s=__env.Array(...)".format(name))
               }
            }
         }
      }
      return list.concat(","), head.concat(';')
   }

   function make_for_stmt(ctx, name, init, last, step, body) {
      var list, head = make_params(ctx, [ name ])
      return 'for %s=%s,%s,%s do %s%s end'.format(name, init, last, step, head, body)
   }

   function make_for_in_stmt(ctx, name_list, expr, body) {
      var list, head = make_params(ctx, name_list)
      return 'for %s in __env.__op_each(%s) do %s%s end'.format(list, expr, head, body)
   }
   function make_return_stmt(ctx, is_lex, expr_list, ret_guard) {
      expr_list = expr_list || [ ]
      if ret_guard {
         for i=1, #ret_guard {
            var type = lookup(ret_guard[i], ctx)
            var expr = expr_list[i] || ''
            expr_list[i] = (type~"(%s)".format(expr))
         }
      }
      var e = expr_list.concat(',')
      if is_lex {
         return "do __return = {%s}; return end".format(e)
      }
      return "do return %s end".format(e)
   }

   function make_func(c,p,b) {
      var p, h = make_params(c, p)
      return "function(%s) %s%s end".format(p,h,b)
   }

   function make_short_func(c,p,b) {
      if #p == 0 { p.push('_') }
      c.define('_')
      var p, h = make_params(c, p)
      return "function(%s) %s%s end".format(p,h,b)
   }

   function make_func_decl(c,n,p,b,s) {
      var p, h = make_params(c, p)
      if s == 'lexical' {
         c.scope.outer.define(n)
         return "local function %s(%s) %s%s end".format(n,p,h,b)
      }
      else {
         c.scope.outer.define(n, { base = s })
         return "function %s.%s(%s) %s%s end".format(s,n,p,h,b)
      }
   }

   function make_meth_decl(ctx,n,p,b) {
      p.unshift('self')
      var p, h = make_params(ctx,p)
      return "__env.__method(self,%q,function(%s) %s%s end);".format(n,p,h,b)
   }

   function make_trait_decl(c,n,p,w,b) {
      var p, h = make_params(c, p)
      return
      '__env.__trait(__env,%q,{%s},function(__env,self,%s) %s%s end);'
         .format(n,w,p,h,b)
   }

   function make_try_stmt(ctx, try_body, catch_blocks) {
      var args = [ ]
      args.push("function() ${try_body} end")
      for i=1, #catch_blocks {
         args.push(catch_blocks[i])
      }
      var stmt = [ ]
      stmt.push("do local __return;__env.__try(${args.concat(',')});")
      stmt.push('if __return then return __env.__op_spread(__return) end end')
      return stmt.concat(' ')
   }
   function make_catch_stmt(ctx, node) {
      var body = node.body
      var head = node.head || '__err'
      var name = head.match('^%s*([^%s]+)%s*$')
      var info = ctx.lookup(name)
      var type = lookup(info.type, ctx)
      return "{body=function(${name}) ${body} end, type=${type}}"
   }
   function make_import_stmt(c, n, f, d) {
      var q = [ ]
      if d {
         c.define(d, { base = '__env' })
         d = quote(d)
         for i=1, #n {
            q[i] = quote(n[i])
         }
      }
      else {
         d = 'nil'
         for i=1, #n {
            c.define(n[i], { base = '__env' })
            q[i] = quote(n[i])
         }
      }
      return "__env.__import(__env,%q,{%s},%s);".format(f, q.concat(','), d)
   }
   function make_export_stmt(c,n) {
      var b = [ ]
      for i=1, #n {
         c.exports[n[i]] = true
      }
      return ''
   }

   method match(...) {
      self.script.match(...)
   }

   rule script {
      {~ <unit> ~} (!. | <{syntax_error("expected <EOF>")}>)
   }
   rule unit {
      {:set_return: {`false`} :}
      {:ret_guard: {`nil`} :}
      {:scope: {`'__env'`} :}
      { %s* '#!' (!nl .)* %s* }? s
      {`'local __env=_G.setmetatable({},{__index=_G.require("lupa.core")});'`}
      <enter>
      ({`'_G'`}    <ctx> -> define_const)
      ({`'__env'`} <ctx> -> define_const)
      {~ (s <main_body_stmt>)* s ~}
      (<ctx> -> function(ctx) {
         var buf = [ ]
         for k,v in ctx.exports {
            if !ctx.lookup(k) {
               throw SyntaxError("export '${k}' was never defined", 2)
            }
            buf.push('{%q,%s}'.format(k,lookup(k, ctx)))
         }
         return "return __env.__export(${buf.concat(',')});"
      })
      <leave>
   }
   rule eval {
      {~ 
         {:set_return: {`false`} :}
         {:ret_guard: {`nil`} :}
         {:scope: {`'__env'`} :}
         {`'local __env=...;'`}
         <enter>
         ({`'_G'`}    <ctx> -> define_const)
         ({`'__env'`} <ctx> -> define_const)
         {~ (s <func_body>) s ~}
         <leave>
      ~} (!. | <{syntax_error("expected <EOF>")}>)
   }

   rule ctx   { %1 }
   rule enter { <ctx> -> enter }
   rule leave { <ctx> -> leave }

   rule main_body_stmt {
      | <var_decl>
      | <func_decl>
      | <class_decl>
      | <trait_decl>
      | <object_decl>
      | <import_stmt>
      | <export_stmt>
      | <statement>
   }
   rule statement {
      | <if_stmt>
      | <switch_stmt>
      | <try_stmt>
      | <for_stmt>
      | <for_in_stmt>
      | <do_while_stmt>
      | <while_stmt>
      | <break_stmt>
      | <throw_stmt>
      | <continue_stmt>
      | <yield_stmt>
      | <block_stmt>
      | <bind_stmt>
      | <call_stmt>
      | &<return_stmt> <{ syntax_error("return outside of function body") }>
      | !(s ("}" | !.)) <{ syntax_error("invalid statement") }>
   }
   rule call_stmt {
      {~ {~
         <primary> s (
         <invoke_expr> | <{syntax_error("expected <invoke_expr>") }>
      ) ~} -> '%1;' semicol ~}
   }
   rule return_stmt {
      {~ "return" -> '' idsafe s (
         <ctx>
         =set_return {@ (<expr> (s "," s <expr>)*)? @}
         =ret_guard
         -> make_return_stmt)
      ~}
   }
   rule yield_stmt {
      'yield' idsafe {~ s <expr_list> ~} -> '__env.__op_yield(%1);' semicol
   }
   rule throw_stmt {
      'throw' idsafe {~ s <expr> ~} -> '__env.__op_throw(%1);' semicol
   }
   rule break_stmt {
      {~ { "break" idsafe } -> "do __break = true; break end" ~}
   }
   rule continue_stmt {
      {~ { "continue" idsafe } -> "do break end" ~}
   }
   rule if_stmt {
      {~
      "if" idsafe s <expr> {`" then "`} s <block> (
         (s ({"else" idsafe s "if" idsafe} -> " elseif") s
            <expr> {`" then "`} s <block>
         )*
         (s "else" idsafe s <block> {`" end "`} | {`" end "`})
      )
      ~}
   }
   rule switch_stmt {
      {~
         "switch" idsafe s {:expr: <expr> :} s "{"
         {~ s (s <case_stmt>)* (s <default_stmt>)? s ~}
         "}" -> "repeat local __break; %2 until true"
      ~}
   }
   rule case_stmt {
      {~
         "case" idsafe =expr s <expr> s ":"
         {~ s (s !(("case" | "default") idsafe s) <statement>)* s ~}
         -> " if __env.__match(%1,%2) then %3 end "
      ~}
   }
   rule default_stmt {
      {~ "default" idsafe s ":" s {~ (s <statement>*) ~} -> "%1" ~}
   }
   rule try_stmt {
      {~
         "try" idsafe s <ctx> <enter>
         "{" {~ <lambda_body> s ~} ("}" | <{ syntax_error("expected '}'") }>)
         {@ (s <catch_stmt>)* @}
         -> make_try_stmt <leave>
      ~}
   }
   rule catch_stmt {
      {~
         "catch" idsafe <ctx> <enter> s {%
            "(" s {:head: <name> <ctx> {`nil`} (s <guard_expr> | {`'Any'`}) -> define :} ")" s
            "{" {:body: {~ <lambda_body> s ~} :} "}"
         %} -> make_catch_stmt <leave>
      ~}
   }
   rule import_stmt {
      {~ (
         "import" idsafe s
         <ctx> {@ <name> (s "," s <name>)* @} s
         "from" idsafe s {~ <name> ("." <name>)* ~}
         (s "in" idsafe s <name>)?
      ) -> make_import_stmt ~}
   }
   rule export_stmt {
      {~ "export" idsafe s <ctx> {@ <name> (s "," s <name>)* @} -> make_export_stmt ~}
   }
   rule loop_name {
      <name> <ctx> {`nil`} (s <guard_expr>)? -> define
   }
   rule for_stmt {
      {~ "for" idsafe s <enter> <ctx> <loop_name> s "=" s <expr> s "," s <expr>
         (s "," s <expr> | {`1`}) s <loop_body> -> make_for_stmt <leave>
      ~}
   }
   rule for_in_stmt {
      {~ "for" idsafe s <enter> <ctx> {@ <loop_name> (s "," s <loop_name>)* @} s "in" idsafe s
         <expr> s <loop_body> -> make_for_in_stmt <leave>
      ~}
   }
   rule while_stmt {
      {~ "while" idsafe s <expr> s <loop_body> -> 'while %1 do %2 end' ~}
   }
   rule do_while_stmt {
      {~
         "do" idsafe {~ s <loop_body> s ~}
         "while" idsafe {~ s <expr> ~} -> 'repeat %1 until not(%2)'
      ~}
   }
   rule loop_body {
      {~
         "{" {~ <block_body> s ~} ("}" | <{ syntax_error("expected '}'") }>)
         -> 'local __break repeat %1 until true if __break then break end'
      ~}
   }

   rule block {
      {~ ("{" -> "") <block_body> s (("}" | <{ syntax_error("expected '}'") }>) -> "") ~}
   }
   rule block_stmt {
      {~ ("{" -> "do ") <block_body> s (("}" | <{ syntax_error("expected '}'") }>) -> " end") ~}
   }
   rule block_body {
      {:scope: {`'lexical'`} :}
      <enter>
      (s <block_body_stmt>)*
      <leave>
   }
   rule block_body_stmt {
      | <var_decl>
      | <func_decl>
      | <return_stmt>
      | <statement>
   }
   rule lambda_body {
      {:set_return: {`true`} :}
      <block_body> s
   }

   rule var_decl {
      {~ "var" idsafe -> "local" s
         ({: <ctx> {@ <var_list> @} (s "=" s {@ <expr> (s "," s <expr>)* @})? :} -> make_var_decl)
      ~} semicol
   }
   rule var_list {
      (<name> <ctx> {`nil`} (s <guard_expr>)? -> define) (s "," s (<name> <ctx> {`nil`} (s <guard_expr>)? -> define))*
      //<name> (s "," s <name>)*
   }
   rule guard_expr {
      ":" s <name>
   }
   rule guard_list {
      ":" s {:ret_guard: {@ <name> (s "," s <name>)* @} :}
   }
   rule slot_decl {
      {~ ("has" idsafe s <ctx> <name> (s <guard_expr> | {`'nil'`}) (s "=" s <expr> | {`""`}) semicol)
         -> make_slot_decl
      ~}
   }
   rule meth_decl {
      {~ ("method" idsafe <ctx> s <name> s
      <enter>
      ({`'self'`} <ctx> -> define_const)
      "(" s <param_list> s ")" s
      <guard_list>? s
      "{" {~ <func_body> s ~} "}"
      ) -> make_meth_decl ~} <leave>
   }
   rule func_decl {
      {~ ("function" idsafe <ctx> s <name> s
      <enter>
      "(" s <param_list> s ")" s
      <guard_list>? s
      "{" {~ <func_body> s ~} "}"
      =scope) -> make_func_decl ~} <leave>
   }
   rule func_body {
      {:scope: {`'lexical'`} :}
      (s <func_body_stmt>)*
   }
   rule func_body_stmt {
      | <var_decl>
      | <func_decl>
      | <return_stmt>
      | <block_stmt>
      | ((&(<expr> s ("}" | !.)) <ctx> // last expr implies return
        =set_return {@ <expr> @}
        =ret_guard) -> make_return_stmt)
      | <statement>
   }
   rule func {
      {~ ("function" idsafe s <enter>
      "(" s <ctx> <param_list> s (")" | <{ syntax_error("expected ')'") }>) s
      <guard_list>? s "{"
         {~ <func_body> s ~}
      ("}" | <{ syntax_error("expected '}'") }>))
      -> make_func ~} <leave>
   }
   rule short_func {
      ("->" -> '') <enter>
      ((s "(" s <ctx> <param_list> s ")" | <ctx> {@ {`'_'`} <ctx> -> define_const @}) s
      "{" {~ <func_body> s ~} "}"
      -> make_short_func) <leave>
   }
   rule class_decl {
      "class" idsafe s {~ <name> <ctx> {`'__env'`} -> define ~} s
      (<class_from> | {`""`}) s
      (<class_with> | {`""`}) s
      "{" {~ <class_body> s ~} "}"
      -> '__env.__class(__env,"%1",{%2},{%3},function(__env,self) %4 end);'
   }
   rule trait_decl {
      "trait" idsafe s <ctx> {~ <name> <ctx> {`'__env'`} -> define ~} s
      <enter>
      ("(" s <param_list> s ")" | {@ {`'...'`} @}) s
      (<class_with> | {`""`}) s
      "{" {~ <class_body> s ~} "}"
      -> make_trait_decl <leave>
   }
   rule object_decl {
      "object" idsafe s {~ <name> <ctx> {`'__env'`} -> define ~} s
      (<class_from> | {`""`}) s
      (<class_with> | {`""`}) s
      "{" {~ <class_body> s ~} "}"
      -> '__env.__object(__env,"%1",{%2},{%3},function(__env,self) %4 end);'
   }
   rule class_body {
      {:scope: {`'__env'`} :}
      <enter>
      ({`'self'`} <ctx> -> define_const)
      {~ (s <class_body_stmt>)* ~}
      <leave>
   }
   rule class_from {
      "from" idsafe s {~ <expr> (s "," s <expr>)* ~}
   }
   rule class_with {
      "with" idsafe s {~ <expr> (s "," s <expr>)* ~}
   }
   rule class_body_stmt {
      | <var_decl>
      | <slot_decl>
      | <func_decl>
      | <rule_decl>
      | <meth_decl>
      | <statement>
   }
   rule rest {
      {~ {'...'} <param>? ~}
   }
   rule stack {
      {~
      | ('...' s "[" s <expr> s ("]" | <{ syntax_error("expected ']'") }>)) -> '(select(%1,...))'
      | {'...'}
      ~}
   }
   rule param_list {
      {@
      | {~ <param> s ~} ("," {~ s <param> s ~})* ("," {~ s <rest> s ~})?
      | <rest>
      | {`nil`}
      @}
   }
   rule ident {
      {~ <name> <ctx> -> lookup ~}
   }
   rule param {
      <name> <ctx> {`nil`} (s <guard_expr> | {`nil`}) (s "=" <expr>)? -> define
   }
   rule name {
      {~ !keyword (
         | { (
            | 'end' | 'elseif' | 'then' | 'local' | 'repeat' | 'until'
            | '_' [0-9]+ | '__return' | '__break'
         ) '_'* idsafe } -> '%1_'
         | ((%alpha | "_") (%alnum | "_")*)
      ) ~}
   }
   rule name_list {
      {~ <name> (s "," s <name>)* ~}
   }
   rule qname {
      {~ <ident> (("::" -> ".") <name>)* ~}
   }
   rule hexadec {
      "-"? "0x" %xdigit+
   }
   rule decimal {
      "-"? digits ("." digits)? (("e"|"E") "-"? digits)?
   }
   rule number {
      {~ <hexadec> | <decimal> ~} -> '(%1)'
   }
   rule string {
      {~ (<qstring> | <astring>) ~} -> '(%1)'
   }
   rule special {
      {~
      | "\n"  -> "\\\n"
      | "\\$" -> "$"
      | "\\\\"
      | "\\" .
      ~}
   }
   rule qstring {
      | '"""' -> '"' {~ (
         | <string_expr>
         | {~ (<special> | !'"""'('"' -> '\"') | !(<string_expr> | "\"\"\"") .)+ ~}
      )* ~} ('"""' -> '"' | <{ syntax_error("expected '\"\"\"'") }>)
      | '"' {~ (
         | <string_expr>
         | {~ (<special> | !(<string_expr> | "\"") .)+ ~}
      )* ~} ('"' | <{ syntax_error("expected '\"'") }>)
   }
   rule astring {
      {~
         | ("'''" -> "") ('\\' | '\'' | (!"'''" .))* ("'''" -> "")
         | ("'"   -> "") ('\\' | '\'' | (!"'"   .))* ("'"   -> "")
      ~} -> quote
   }
   rule string_expr {
      ('${' -> '"..') {~ s (<expr> -> 'tostring(%1)') s ~} ("}" -> '.."')
   }
   rule vnil {
      {~ { "nil" } idsafe -> '(nil)' ~}
   }
   rule vtrue {
      {~ { "true" } idsafe -> '(true)' ~}
   }
   rule vfalse {
      {~ { "false" } idsafe -> '(false)' ~}
   }
   rule range {
      {~ (
         "[" s <expr> s ":" s <expr> ( s ":" s <expr> | {`"1"`} ) s "]"
      ) -> "__env.Range(%1,%2,%3)" ~}
   }
   rule array {
      {~
         ("[" -> "__env.Array(") s
         (<array_elements> | {`""`}) s
         ("]" -> ")" | <{syntax_error("expected ']'")}>)
      ~}
   }
   rule array_elements {
      <expr> ( s "," s <expr> )* (s ("," -> ''))?
   }
   rule hash {
      {~
         ("{" -> "__env.Hash({") s
         (<hash_pairs> | {`""`}) s
         ("}" -> "})" | <{syntax_error("expected '}'")}>)
      ~}
   }
   rule hash_pairs {
      <hash_pair> (s "," s <hash_pair>)* (s ",")?
   }
   rule hash_pair {
      (<name> | "[" s <expr> s ("]" | <{syntax_error("expected ']'")}>)) s
      "=" s <expr>
   }
   rule primary {
      | <ident>
      | <range>
      | <number>
      | <string>
      | <vnil>
      | <vtrue>
      | <vfalse>
      | <stack>
      | <array>
      | <hash>
      | <func>
      | <short_func>
      | <pattern>
      | "(" s <expr> s (")" | <{ syntax_error("expected ')'") }>)
   }
   rule paren_expr {
      "(" s ( <expr_list> | {`""`} ) s (")" | <{ syntax_error("expected ')'") }>)
   }
   rule member_expr {
      {~
      | "." s <name> -> '.%1'
      | "[" s <expr> s ("]" | <{ syntax_error("expected ']'") }>)
      ~}
   }
   rule method_expr {
      {~
      | ("." -> ":" | "::" -> ".") s <name> s (<short_expr> | <paren_expr>)
      ~}
   }
   rule access_expr {
      {~
      | <invoke_expr> s <access_expr>
      | <member_expr>
      ~}
   }
   rule invoke_expr {
      {~
      | (
         | <method_expr>
         | <member_expr>
         | <short_expr>
         | <paren_expr>
      ) s <invoke_expr>
      | <method_expr>
      | <short_expr>
      | <paren_expr>
      ~}
   }
   rule short_expr {
      ("->" -> "(")
      <enter>
      ((s "(" s <ctx> <param_list> s ")" | <ctx> {@ {`'_'`} <ctx> -> define_const @}) s
      "{" {~ <func_body> s ~} "}"
      -> make_short_func) {`')'`} <leave>
   }
   rule suffix_expr {
      | <invoke_expr>
      | <access_expr>
   }
   rule term {
      {~ <primary> (s <suffix_expr>)* ~}
   }
   rule expr_list {
      {~ <expr> (s "," s <expr>)* ~}
   }
   rule expr {
      {~ (<infix_expr> | <prefix_expr>) ~}
   }

   var binop_patt = /(
      "+" | "-" | "~" | "^^" | "*" | "/" | "%" | "^" | ">>>" | ">>" | "<<"
      | "||" | "&&" | "|" | "&" | "==" | "!=" | ">="| "<=" | "<" | ">"
      | ("as" | "in") idsafe
   )/

   rule infix_expr {
      {@ {~ <prefix_expr> s ~} (
         { binop_patt }
         {~ s <prefix_expr> (&(s binop_patt) s)? ~}
      )+ @} -> fold_infix
   }

   rule prefix_expr {
      {: {
         | "@" | "!" | "#" | "-" | "~"
         | "typeof" idsafe
      } s <prefix_expr> :} -> fold_prefix
      | {~ s <term> ~}
   }

   // binding expression rules
   rule bind_stmt {
      {~ (<bind_expr> | <bind_binop_expr>) -> '%1;' semicol ~}
   }
   rule bind_expr {
      {~ <ctx> {@ <bind_list> @} {s} "=" {s} (
         | {@ <expr> (s "," s <expr>)* @}
         | <{syntax_error("bad right hand <expr>")}>
      ) -> make_bind_expr ~}
   }
   rule bind_binop {
      { "+" | "-" | "*" | "/" | "%" | "||" | "|"| "&&"
      | "&" | "^^" | "^" | "~" | ">>>" | ">>" | "<<"
      } "="
   }
   rule bind_binop_expr {
      {~ <ctx> { <bind_term> s } <bind_binop> s <expr> -> make_binop_bind ~}
   }
   rule bind_list {
      <bind_term> (s "," s <bind_term>)*
   }
   rule bind_term {
      {~
      | <primary> (s <bind_member>)+
      | {~ <name> <ctx> -> lookup_or_define ~} -> '%1=%%s'
      ~}
   }
   rule bind_member {
      {~
      | <suffix_expr> s <bind_member>
      | <bind_suffix>
      ~}
   }
   rule bind_suffix {
      {~
      | "." {~ s <name> s ~} -> '.%1=%%s'
      | "[" {~ s <expr> s ~} "]" {s} -> '[%1]%2=%%s'
      ~}
   }

   // PEG grammar and pattern rules
   rule pattern {
      "/" {~ s <rule_alt> s ~} "/" -> '__env.__patt.P(%1)'
   }
   rule rule_decl {
      "rule" idsafe s <name> s "{" {~ s <rule_body> s ~} "}"
      -> '__env.__rule(self,"%1",%2);'
   }
   rule rule_body {
      <rule_alt> | {`'__env.__patt.P(nil)'`}
   }
   rule rule_alt {
      {~ ("|" -> '' s)? <rule_seq> (s ("|" -> "+") s <rule_seq>)* ~}
   }
   rule rule_seq {
      {@ {~ s <rule_suffix> ~}+ @} -> function(a) { a.concat('*') }
   }
   rule rule_rep {
      {~ "+" -> "^1" | "*" -> "^0" | "?" -> "^-1" | "^"s("+"|"-")?s[0-9]+ ~}
   }
   rule rule_prefix {
      {~ (("&" -> "#") | ("!" -> "-")) {~ s <rule_prefix> ~} -> '%1%2'
      | <rule_primary>
      ~}
   }

   var prod_oper = / "->" | "~>" | "=>" /

   rule rule_suffix {
      ({~ <rule_prefix> (&(s prod_oper) s)? ~}
      {: {prod_oper} {~ s <term> ~} :}*) ~> function(a,o,b) {
         if o == "=>" {
            return '__env.__patt.Cmt(%s,%s)'.format(a,b)
         }
         else if o == "~>" {
            return '__env.__patt.Cf(%s,%s)'.format(a,b)
         }
         else {
            return '(%s)/(%s)'.format(a,b)
         }
      }
   }

   rule rule_primary {
      ( <rule_group>
      | <rule_term>
      | <rule_class>
      | <rule_predef>
      | <rule_back_capt>
      | <rule_group_capt>
      | <rule_sub_capt>
      | <rule_const_capt>
      | <rule_hash_capt>
      | <rule_array_capt>
      | <rule_simple_capt>
      | <rule_any>
      | <rule_ref>
      ) (s <rule_rep>)*
   }
   rule rule_group {
      {~ "(" s (<rule_alt> | <{ syntax_error("expected <rule_alt>") }>) s
         (")" | <{ syntax_error("expected ')'") }>)
      ~}
   }
   rule rule_term {
      {~ <string> -> '__env.__patt.P(%1)' ~}
   }
   rule rule_class {
      {~
         ("[" -> '(') ("^" -> '__env.__patt.P(1)-')?
         ({@ (!"]" <rule_item>)+ @} -> function(a) { "("~a.concat("+")~")" })
         ("]" -> ')')
      ~}
   }
   rule rule_item {
      {~ <rule_predef> | <rule_range>
      | {.} -> function(c) { '__env.__patt.P(%q)'.format(c) }
      ~}
   }
   rule rule_predef {
      {~ ('%' -> '') (
         | { [0-9]+ } -> '__env.__patt.Carg(%1)'
         | <name> -> '__env.__patt.Def("%1")'
      ) ~}
   }
   rule rule_range {
      {~ . ("-"->'') !"]" . ~} -> function(r) { '__env.__patt.R(%q)'.format(r) }
   }
   rule rule_any {
      {~ "." -> '__env.__patt.P(1)' ~}
   }
   rule rule_ref {
      {~
      ("<" -> '') s
         ( <name> -> '__env.__patt.V("%1")'
         | {~ ("{" -> '__env.__patt.P(') s <expr> s ("}" -> ")") ~}
         ) s
      (">" -> '')
      | <qname>
      ~}
   }
   rule rule_group_capt {
      {~ "{:" ((<name> -> quote ":") | {`'nil'`}) {~ s <rule_alt> ~} s ":}"
      -> '__env.__patt.Cg(%2,%1)'
      ~}
   }
   rule rule_back_capt {
      "=" (<name> -> quote) -> '__env.__patt.Cb(%1)'
   }
   rule rule_sub_capt {
      "{~" {~ s <rule_alt> s ~} "~}" -> '__env.__patt.Cs(%1)'
   }
   rule rule_const_capt {
      "{`" {~ s <expr_list> s ~} "`}" -> '__env.__patt.Cc(%1)'
   }
   rule rule_hash_capt {
      "{%" {~ s <rule_alt> s ~} "%}" -> '__env.__patt.Ch(%1)'
   }
   rule rule_array_capt {
      "{@" {~ s <rule_alt> s ~} "@}" -> '__env.__patt.Ca(%1)'
   }
   rule rule_simple_capt {
      "{" {~ s <rule_alt> s ~} "}" -> '__env.__patt.C(%1)'
   }
}

object Compiler {

   method compile(lupa, name, args) {
      var ctx = Context.new()
      ctx.enter()
      if args {
         for i=1, #args {
            ctx.define(args[i], { })
         }
      }
      var lua = Grammar.match(lupa, 1, ctx)
      ctx.leave()
      assert(ctx.scope.outer == nil, "scope is unbalanced")
      if args {
         return "local ${args.concat(',')}=select(2,...);${lua}"
      }
      return lua
   }

   method eval(src) {
      var ctx = Context.new()
      ctx.enter()
      var lua = Grammar.eval(src, 1, ctx)
      ctx.leave()
      var eval = assert(loadstring(lua,'=eval:'~src))

      var eenv = newtable()
      var meta = newtable()
      meta.__index = _G::require("lupa.core")
      _G::setmetatable(eenv, meta)

      return eval(eenv)
   }
}

var getopt = function(...args) {
   var opt = { }
   var idx = 0
   var len = #args
   while idx < len {
      idx = idx + 1
      var arg = args[idx]
      if arg.sub(1,1) == '-' {
         var o = arg.sub(2)
         if o == 'o' {
            idx = idx + 1
            opt['o'] = args[idx]
         }
         else if o == 'l' {
            opt['l'] = true
         }
         else if o == 'b' {
            idx = idx + 1
            opt['b'] = args[idx]
         }
         else {
            error('unknown option: '~arg, 2)
         }
      }
      else {
         opt['file'] = arg
      }
   }
   return opt
}

var run = function(...) {
   var opt = getopt(...)
   var sfh = assert(io::open(opt['file']))
   var src = sfh.read('*a')
   sfh.close()

   var lua = Compiler.compile(src)
   if opt['l'] {
      io.stdout.write(lua, "\n")
      os::exit(0)
   }

   if opt['o'] {
      var outc = io::open(opt['o'], "w+")
      outc.write(lua)
      outc.close()
   }
   else {
      lua = lua.gsub("^%s*#![^\n]*",'')
      var main = assert(loadstring(lua,'='~opt['file']))
      if opt['b'] {
         var outc = io::open(opt.b, "wb+")
         outc.write(String::dump(main))
         outc.close()
      }
      else {
         var main_env = setmetatable({ }, { __index = _G })
         var good, err = pcall(main, main_env, opt['file'], ...)
         if !good {
            io.stderr.write(tostring(err),"\n")
            os::exit(1)
         }
      }
   }
}

LUPA_PATH = "./?.lu;./lib/?.lu;./src/?.lu"
{
   package.loaders[#package.loaders + 1] = function(modname) {
      var filename = modname.gsub("%.", "/")
      for path in LUPA_PATH.gmatch("([^;]+)") {
         if path != "" {
            var filepath = path.gsub("?", filename)
            var file = io::open(filepath, "r")
            if file {
               var src = file.read("*a")
               return function(...args) {
                  try {
                     var lua  = Compiler.compile(src)
                     var main = assert(loadstring(lua, '='~filepath))
                     return main(@args)
                  }
                  catch (e) {
                     throw ImportError("failed to load ${modname}: ${e}")
                  }
               }
            }
         }
      }
   }
}

arg = "arg" in _G && [ unpack(arg) ] || [ ]
if arg[1] { run(unpack(arg)) }

