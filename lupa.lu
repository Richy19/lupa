#!/usr/bin/env luajit

_G['package'].path  = ";;./src/?.lua;./lib/?.lua;${_G['package'].path}"
_G['package'].cpath = ";;./lib/?.so;${_G['package'].cpath}"

_G.newtable = loadstring("return {...}")

var rawget, rawset = _G.rawget, _G.rawset
var getmetatable, setmetatable = _G.getmetatable, _G.setmetatable

_G.__class = function(into, name, _from, _with, body) {
    if #_from == 0 {
        _from[#_from + 1] = Object
    }

    var _super = newtable()
    var _class = newtable()
    _class.__name = name
    _class.__from = _from

    var readers = newtable()
    var writers = newtable()

    _class.__readers = readers
    _class.__writers = writers

    var queue  = newtable(unpack(_from))
    while  #queue > 0 {
        var base = table::remove(queue, 1)
        if getmetatable(base) != Class {
            error("TypeError: ${base} is not a Class", 2)
        }
        _from[base] = true
        for k,v in pairs(base) {
            if _class[k] == nil { _class[k] = v }
            if _super[k] == nil { _super[k] = v }
        }
        for k,v in pairs(base.__readers) {
            if readers[k] == nil { readers[k] = v }
        }
        for k,v in pairs(base.__writers) {
            if writers[k] == nil { writers[k] = v }
        }
        if base.__from {
            for i=1, #base.__from {
                queue[#queue + 1] = base.__from[i]
            }
        }
    }

    _class.__index = function(obj, key) {
        var reader = readers[key]
        if reader { return reader(obj) }
        return _class[key]
    }
    _class.__newindex = function(obj, key, val) {
        var writer = writers[key]
        if writer {
            writer(obj, val)
        }
        else {
            rawset(obj, key, val)
        }
    }
    _class.new = function(self, ...) {
        var obj = setmetatable(newtable(), self)
        if rawget(self, '__init') != nil {
            var ret = obj.__init(...)
            if ret != nil {
                return ret
            }
        }
        return obj
    }

    setmetatable(_class, Class)

    var _env = setmetatable({ }, { __index = into })
    if _with {
        for i=1, #_with {
            _with[i].compose(_env, _class)
        }
    }

    into[name] = _class
    body(_env, _class, _super)

    return _class
}
_G.__trait = function(into, name, _with, body) {
    var _trait = newtable()
    _trait.__name = name
    _trait.__body = body
    _trait.__with = _with
    setmetatable(_trait, Trait)
    if into {
        into[name] = _trait
    }
    return _trait
}
_G.__object = function(into, name, _from, _with, body) {
    for i=1, #_from {
        if getmetatable(_from[i]) != Class {
            _from[i] = getmetatable(_from[i])
        }
    }
    var anon = __class(into, '#'~name, _from, _with, body)
    var inst = anon()
    into[name] = inst
    return inst
}
_G.__method = function(into, name, code) {
    into[name] = code
}
_G.__has = function(into, name, def) {
    var setter = '__set_'~name
    var getter = '__get_'~name
    into[setter] = function(obj, val) {
        rawset(obj, name, val)
    }
    into[getter] = function(obj) {
        var val = rawget(obj, name)
        if val == nil {
            val = def(obj)
            obj[setter](obj, val)
        }
        return val
    }
}
_G.__grammar = function(into, name, body) {
   var gram = newtable()
   var patt
   function gram.match(self, ...) {
      return patt.match(...)
   }
   var _env = setmetatable({ }, { __index = into })
   body(_env, gram)
   {
      var grmr = newtable()
      for k,v in pairs(gram) {
         if __patt::type(v) == 'pattern' {
            grmr[k] = v
         }
      }
      grmr[1] = rawget(gram, 1) || '__init'
      patt = __patt::P(grmr)
   }

   into[name] = gram
   return gram
}
_G.__rule = function(into, name, patt) {
   if name == '__init' || rawget(into,1) == nil {
      into[1] = name
   }
   into[name] = patt
   var rule_name = '__rule_'~name
   into['__get_'~name] = function(self) {
      var _rule = rawget(self, rule_name)
      if _rule == nil {
         var grmr = newtable()
         for k,v in pairs(self) {
            if __patt::type(v) == 'pattern' {
               grmr[k] = v
            }
         }
         grmr[1] = name
         _rule = __patt::P(grmr)
         rawset(self, rule_name, _rule)
      }
      return _rule
   }
}

_G.__try = function(_try, _catch) {
    var ok, er = pcall(_try)
    if !ok { _catch(er) }
}

_G.__patt = require("lpeg")
_G.__patt::setmaxstack(1024)
{
   function make_capt_hash(init) {
      return function(tab) {
         if init != nil {
            for k,v in init {
               if tab[k] == nil { tab[k] = v }
            }
         }
         return tab as Hash
      }
   }
   function make_capt_array(init) {
      return function(tab) {
         if init != nil {
            for i=1, #init {
               if tab[i] == nil { tab[i] = init[i] }
            }
         }
         return tab as Array
      }
   }

   __patt.Ch = function(patt,init) {
      return Pattern::__div(__patt::Ct(patt), make_capt_hash(init))
   }
   __patt.Ca = function(patt,init) {
      return Pattern::__div(__patt::Ct(patt), make_capt_array(init))
   }

   var predef = newtable()

   predef.nl  = __patt::P("\n")
   predef.pos = __patt::Cp()

   var any = __patt::P(1)
   __patt::locale(predef)

   predef.a = predef.alpha
   predef.c = predef.cntrl
   predef.d = predef.digit
   predef.g = predef.graph
   predef.l = predef.lower
   predef.p = predef.punct
   predef.s = predef.space
   predef.u = predef.upper
   predef.w = predef.alnum
   predef.x = predef.xdigit
   predef.A = any - predef.a
   predef.C = any - predef.c
   predef.D = any - predef.d
   predef.G = any - predef.g
   predef.L = any - predef.l
   predef.P = any - predef.p
   predef.S = any - predef.s
   predef.U = any - predef.u
   predef.W = any - predef.w
   predef.X = any - predef.x

   __patt.predef = predef
   __patt.Def = function(id) {
      if predef[id] == nil {
         error("No predefined pattern '${id}'", 2)
      }
      return predef[id]
   }
}

_G.__package = function(into, name, body, args) {
   var path = newtable()
   for frag in name.gmatch("([^%.]+)") {
      path[#path + 1] = frag
   }

   var pckg = into
   for i=1, #path {
      var name = path[i]

      if rawget(pckg, name) == nil {
         var pkg = newtable()
         var env = newtable()
         var env_meta = newtable()
         var pkg_meta = newtable()

         function env_meta.__index(env, key) {
            var val = pkg[key]
            if val != nil { return val }
            return into.__env[key]
         }
         function env_meta.__newindex(env, key, val) {
            rawset(env, key, val)
            rawset(pkg, key, val)
         }

         function pkg_meta.__newindex(pkg, key, val) {
            env[key] = val
         }

         setmetatable(env, env_meta)
         setmetatable(pkg, pkg_meta)

         pkg.__env = env
         pckg[name] = pkg
      }
      pckg = pckg[name]
   }
   into[name] = pckg
   _G['package'].loaded[name] = pckg
   if body {
      body(pckg.__env, pckg)
   }
   return pckg
}

_G.__import = function(_from, what) {
   var mod = __load(_from)
   var out = [ ]
   if what {
      for i=1, #what {
         out[i] = mod[what[i]]
      }
      return @out
   }
   else {
      return mod
   }
}
_G.__export = function(self, ...what) {
    for i=1, #what {
        self.__export[what[i]] = true
    }
}

_G.__load = function(_from) {
   var path = _from
   if type(_from) == 'table' {
      path = table::concat(_from, '.')
   }
   var mod = require(path)
   if mod == true {
      mod = _G
      for i=1, #_from {
         mod = mod[_from[i]]
      }
   }
   return mod
}

_G.__op_as     = setmetatable
_G.__op_typeof = getmetatable
_G.__op_yield  = coroutine['yield']
_G.__op_throw  = error

_G.__op_in = function(key, obj) {
   return rawget(obj, key) != nil
}
_G.__op_like = function(this, that) {
   for k,v in pairs(that) {
      if type(this[k]) != type(v) {
         return false
      }
      if !this[k].isa(getmetatable(v)) {
         return false
      }
   }
   return true
}
_G.__op_spread = function(a) {
   var mt = getmetatable(a)
   var __spread = mt && rawget(mt, '__spread')
   if __spread { return __spread(a) }
   return unpack(a)
}
_G.__op_each = function(a, ...) {
   if type(a) == 'function' { return a, ... }
   var mt = getmetatable(a)
   var __each = mt && rawget(mt, '__each')
   if __each { return __each(a) }
   return pairs(a)
}
_G.__op_lshift = function(a,b) {
   var mt = getmetatable(a)
   var __lshift = mt && rawget(mt, '__lshift')
   if __lshift { return __lshift(a, b) }
   return bit::lshift(a, b)
}
_G.__op_rshift = function(a,b) {
   var mt = getmetatable(a)
   var __rshift = mt && rawget(mt, '__rshift')
   if __rshift { return __rshift(a, b) }
   return bit::rshift(a, b)
}
_G.__op_arshift = function(a,b) {
   var mt = getmetatable(a)
   var __arshift = mt && rawget(mt, '__arshift')
   if __arshift { return __arshift(a, b) }
   return bit::arshift(a, b)
}
_G.__op_bor = function(a,b) {
   var mt = getmetatable(a)
   var __bor = mt && rawget(mt, '__bor')
   if __bor { return __bor(a, b) }
   return bit::bor(a, b)
}
_G.__op_bxor = function(a,b) {
   var mt = getmetatable(a)
   var __bxor = mt && rawget(mt, '__bxor')
   if __bxor { return __bxor(a, b) }
   return bit::bxor(a, b)
}
_G.__op_bnot = function(a) {
   var mt = getmetatable(a)
   var __bnot = mt && rawget(mt, '__bnot')
   if __bnot { return __bnot(a) }
   return bit::bnot(a)
}

_G.Type = newtable()
Type.__name = 'Type'
Type.__call = function(self, ...) {
   return self.__apply(...)
}
Type.isa = function(self, that) {
   return getmetatable(self) == that
}
Type.can = function(self, key) {
   return rawget(self, key) || rawget(getmetatable(self), key)
}
Type.does = function(self, that) {
   return false
}
Type.__index = Type
Type.__tostring = function(self) {
   return 'type '~(rawget(self, '__name') || 'Type')
}

_G.Class = setmetatable(newtable(), Type)
Class.__tostring = function(self) {
   return self.__name
}
Class.__index = function(self, key) {
   error("AccessError: no such member '${key}' in ${self.__name}", 2)
}
Class.__newindex = function(self, key, val) {
    if key.match('^__get_') {
        var _k = key.match('^__get_(.-)$')
        self.__readers[_k] = val
    }
    else if key.match('^__set_') {
        var _k = key.match('^__set_(.-)$')
        self.__writers[_k] = val
    }
    rawset(self, key, val)
}
Class.__call = function(self, ...) {
   return self.__apply(...)
}

_G.Object = setmetatable(newtable(), Class)
Object.__name = 'Object'
Object.__from = newtable()
Object.__with = newtable()
Object.__readers = newtable()
Object.__writers = newtable()
Object.__tostring = function(self) {
   return "object ${getmetatable(self)}"
}
Object.__index = Object
Object.isa = function(self, that) {
   var meta = getmetatable(self)
   return meta == that || (meta.__from && (meta.__from[that] != nil))
}
Object.can = function(self, key) {
   var meta = getmetatable(self)
   return rawget(meta, key)
}
Object.does = function(self, that) {
   return self.__with[that.__body] != nil
}

_G.Trait = setmetatable(newtable(), Type)
Trait.__call = function(self, ...args) {
   var copy = __trait(nil, self.__name, self.__with, self.__body)
   var make = self.compose
   copy.compose = function(self, into, recv) {
      return make(self, into, recv, @args)
   }
   return copy
}
Trait.__tostring = function(self) {
   return 'trait '~self.__name
}
Trait.__index = Trait
Trait.compose = function(self, into, recv, ...) {
   for i=1, #self.__with {
      self.__with[i].compose(into, recv)
   }
   self::__body(into, recv, ...)
   recv.__with[self.__body] = true
   return into
}

_G.Hash = setmetatable(newtable(), Type)
Hash.__name = 'Hash'
Hash.__index = Hash
Hash.__apply = function(self, table) {
   return setmetatable(table || newtable(), self)
}
Hash.__tostring = function(self) {
   var buf = newtable()
   for k, v in pairs(self) {
      var _v
      if type(v) == 'string' {
         _v = string::format('%q', v)
      }
      else {
         _v = tostring(v)
      }
      if type(k) == 'string' {
         buf[#buf + 1] = k~'='~_v
      }
      else {
         buf[#buf + 1] = "[${k}]=${_v}"
      }
   }
   return '{'~table::concat(buf, ',')~'}'
}
Hash.__getitem = rawget
Hash.__setitem = rawset
Hash.__each = pairs

_G.Array = setmetatable(newtable(), Type)
Array.__name = 'Array'
Array.__index = Array
Array.__apply = function(self, ...) {
   return setmetatable(newtable(...), self)
}
Array.__tostring = function(self) {
   var buf = newtable()
   for i=1, #self {
      if type(self[i]) == 'string' {
         buf[#buf + 1] = string::format('%q', self[i])
      }
      else {
         buf[#buf + 1] = tostring(self[i])
      }
   }
   return '['~table::concat(buf,',')~']'
}
Array.__each = ipairs
Array.__spread = unpack
Array.__getitem = rawget
Array.__setitem = rawset
Array.unpack = unpack
Array.insert = table.insert
Array.remove = table.remove
Array.concat = table.concat
Array.sort = table.sort
Array.each = function(self, block) {
   for i=1, #self { block(self[i]) }
}
Array.map = function(self, block) {
   var out = Array()
   for i=1, #self {
      var v = self[i]
      out[#out + 1] = block(v)
   }
   return out
}
Array.grep = function(self, block) {
   var out = Array()
   for i=1, #self {
      var v = self[i]
      if block(v) {
         out[#out + 1] = v
      }
   }
   return out
}
Array.push = function(self, v) {
   self[#self + 1] = v
}
Array.pop = function(self) {
   var v = self[#self]
   self[#self] = nil
   return v
}
Array.shift = function(self) {
   var v = self[1]
   for i=2, #self {
      self[i-1] = self[i]
   }
   self[#self] = nil
   return v
}
Array.unshift = function(self, v) {
   for i=#self+1, 1, -1 {
      self[i] = self[i-1]
   }
   self[1] = v
}
Array.splice = function(self, offset, count, ...args) {
   var out = Array()
   for i=offset, offset + count - 1 {
      out.push(self.remove(offset))
   }
   for i=#args, 1, -1 {
      self.insert(offset, args[i])
   }
   return out
}
Array.reverse = function(self) {
   var out = Array()
   for i=1, #self {
      out[i] = self[(#self - i) + 1]
   }
   return out
}

_G.Range = setmetatable(newtable(), Type)
Range.__name = 'Range'
Range.__index = Range
Range.__apply = function(self, min, max, inc) {
   min = assert(tonumber(min), "range min is not a number")
   max = assert(tonumber(max), "range max is not a number")
   inc = assert(tonumber(inc || 1), "range inc is not a number")
   return setmetatable(newtable(min, max, inc), self)
}
Range.__each = function(self) {
   var inc = self[3]
   var cur = self[1] - inc
   var max = self[2]
   return function() {
      cur = cur + inc
      if cur <= max {
         return cur
      }
   }
}
Range.each = function(self, block) {
   for i in Range.__each(self) {
      block(i)
   }
}

_G.Nil = setmetatable(newtable(), Type)
Nil.__name = 'Nil'
Nil.__index = function(self, key) {
    var val = Type[key]
    if val == nil {
        error("TypeError: no such member ${key} in type Nil", 2)
    }
    return val
}
debug::setmetatable(nil, Nil)

_G.Number = setmetatable(newtable(), Type)
Number.__name = 'Number'
Number.__index = Number
Number.__apply = function(self, val) {
    var v = tonumber(val)
    if v == nil {
        error("TypeError: cannot coerce '${val}' to Number", 2)
    }
    return v
}
Number.times = function(self, block) {
   for i=1, self { block(i) }
}
debug::setmetatable(0, Number)

_G.String = setmetatable(string, Type)
String.__name = 'String'
String.__index = String
String.__apply = function(self, val) {
    return tostring(val)
}
String.__match = function(a,p) {
   return __patt::P(p).match(a)
}
String.split = function(str, sep, max) {
   if !str.find(sep) {
      return Array(str)
   }
   if max == nil ||  max < 1 {
      max = 0
   }
   var pat = "(.-)"~sep~"()"
   var idx = 0
   var list = Array()
   var last
   for part, pos in str.gmatch(pat) {
      idx = idx + 1
      list[idx] = part
      last = pos
      if idx == max { break }
   }
   if idx != max {
      list[idx + 1] = str.sub(last)
   }
   return list
}
debug::setmetatable("", String)

_G.Boolean = setmetatable(newtable(), Type)
Boolean.__name = 'Boolean'
Boolean.__index = Boolean
debug::setmetatable(true, Boolean)

_G.Function = setmetatable(newtable(), Type)
Function.__name = 'Function'
Function.__index = Function
Function.__apply = function(self, code, fenv) {
    code = Lupa.compile(code)
    var func = assert(loadstring(code, '=eval'))
    if fenv {
        setfenv(func, fenv)
    }
    return func
}
debug::setmetatable(function() { }, Function)

_G.Coroutine = setmetatable(newtable(), Type)
Coroutine.__name = 'Coroutine'
Coroutine.__index = Coroutine
for k,v in pairs(coroutine) {
   Coroutine[k] = v
}
debug::setmetatable(coroutine::create(function() { }), Coroutine)

_G.Pattern = setmetatable(getmetatable(__patt::P(1)), Type)
Pattern.__call = function(patt, subj) {
   return patt.match(subj)
}
Pattern.__match = function(patt, subj) {
   return patt.match(subj)
}

class Lupa {

    class Scope {
        has entries = { }
        has outer   = _G
        method __init(outer) {
            self.outer = outer
        }
        method lookup(name) {
            if name in self.entries {
                return self.entries[name]
            }
            else if 'outer' in self {
                return self.outer.lookup(name)
            }
        }
        method define(name, info) {
            self.entries[name] = info
        }
    }

    class Context {
        has scope = Lupa.Scope.new()
        method enter() {
            self.scope = Lupa.Scope.new(self.scope)
        }
        method leave() {
            if 'outer' in self.scope {
               var outer = self.scope.outer
               self.scope = outer
               return outer
            }
            error("no outer scope")
        }
        method define(name, info) {
            self.scope.define(name, info || { })
        }
        method lookup(name) {
            self.scope.lookup(name)
        }
    }

    grammar Grammar {

        function error_line(src, pos) {
            var line = 1
            var index, limit = 1, pos
            while index <= limit {
                var s, e = src.find("\n", index, true)
                if s == nil || e > limit { break }
                index = e + 1
                line  = line + 1
            }
            return line
        }
        function error_near(src, pos) {
            if (#src < pos + 20) {
                return src.sub(pos)
            }
            else {
                return src.sub(pos, pos + 20)~"..."
            }
        }
        function syntax_error(m) {
            return function(src, pos) {
                var line, near = error_line(src, pos), error_near(src, pos)
                error("SyntaxError: ${m||''} on line ${line} near '${near}'")
            }
        }

        var id_counter = 9
        function genid() {
            id_counter += 1
            return '_'~id_counter
        }

        function quote(c) { "%q".format(c) }

        var nl      = / "\n" /
        var comment = / {~
            | ((!nl %s)* ("//" -> '--') (!nl .)* nl)
            | ("/*" -> '--[=[') (']=]' -> ']\=]' | !"*/" .)* ("*/" -> ']=]')
        ~} /
        var idsafe  = / !(%alnum | "_") /
        var s       = / (comment | %s)* /
        var semicol = / (";" -> '')? /
        var digits  = / (%digit {~ "_" -> '' ~}?)+ /
        var keyword = / (
              "var" | "function" | "class" | "with" | "like" | "in"
            | "nil" | "true" | "false" | "typeof" | "return" | "as"
            | "for" | "throw" | "method" | "has" | "from" | "break"
            | "continue" | "package" | "import" | "try" | "catch"
            | "finally" | "if" | "else" | "yield" | "grammar" | "rule"
        ) idsafe /

        var prec = {
            ["^^"]  = 4,
            ["*"]   = 5,
            ["/"]   = 5,
            ["%"]   = 5,
            ["+"]   = 6,
            ["-"]   = 6,
            ["~"]   = 6,
            [">>"]  = 7,
            ["<<"]  = 7,
            [">>>"] = 7,
            ["<="]  = 8,
            [">="]  = 8,
            ["<"]   = 8,
            [">"]   = 8,
            ["in"]  = 8,
            ["as"]  = 8,
            ["=="]  = 9,
            ["!="]  = 9,
            ["&"]   = 10,
            ["^"]   = 11,
            ["|"]   = 12,
            ["&&"]  = 13,
            ["||"]  = 14,
        }

        var unrops = {
            ["!"] = "not(%s)",
            ["#"] = "#(%s)",
            ["-"] = "-(%s)",
            ["~"] = "__op_bnot(%s)",
            ["@"] = "__op_spread(%s)",
            ["throw"] = "__op_throw(%s)",
            ["typeof"] = "__op_typeof(%s)",
        }

        var binops = {
            ["^^"] = "(%s)^(%s)",
            ["*"] = "(%s)*(%s)",
            ["/"] = "(%s)/(%s)",
            ["%"] = "(%s)%%(%s)",
            ["+"] = "(%s)+(%s)",
            ["-"] = "(%s)-(%s)",
            ["~"] = "(%s)..(%s)",
            [">>"] = "__op_rshift(%s,%s)",
            ["<<"] = "__op_lshift(%s,%s)",
            [">>>"] = "__op_arshift(%s,%s)",
            ["<="] = "(%s)<=(%s)",
            [">="] = "(%s)>=(%s)",
            ["<"] = "(%s)<(%s)",
            [">"] = "(%s)>(%s)",
            ["in"] = "__op_in(%s,%s)",
            ["as"] = "__op_as(%s,%s)",
            ["=="] = "(%s)==(%s)",
            ["!="] = "(%s)~=(%s)",
            ["&"] = "__op_band(%s,%s)",
            ["^"] = "__op_bxor(%s,%s)",
            ["|"] = "__op_bor(%s,%s)",
            ["&&"] = "(%s)and(%s)",
            ["||"] = "(%s)or(%s)",
        }

        function fold_prefix(o,e) {
            if o == '#' && e.match('^%s*%.%.%.%s*$') {
                return 'select("#",...)'
            }
            return unrops[o].format(e)
        }

        ///*
        function fold_infix(e) {
            var s = [ e[1] ]
            for i=2, #e {
                s[#s + 1] = e[i]
                while !binops[s[#s]] && s[#s - 1] {
                    var p = s[#s - 1]
                    var n = e[i + 1]
                    if n == nil || prec[p] <= prec[n] {
                        var b, o, a = s.pop(), s.pop(), s.pop()
                        if !binops[o] {
                            error("bad expression: ${e}, stack: ${s}")
                        }
                        s.push(binops[o].format(a, b))
                    }
                    else {
                        break
                    }
                }
            }
            return s[1]
        }
        //*/

        /* enable for recursive descent expr parsing
        function fold_infix(a,o,b) {
            return binops[o].format(a,b)
        }
        //*/

        function make_binop_bind(a, o, b) {
            return a~"="~binops[o].format(a,b)
        }

        function make_params(p) {
            var h = ''
            if #p > 0 && p[#p].find('...', 1, true) {
                var r = p[#p]
                var n = r.match('%.%.%.([%w_0-9]+)')
                p[#p] = "..."
                if n {
                    h = "local %s=Array(...);".format(n)
                }
            }
            return p.concat(","), h
        }

        function make_func(p,b) {
            var p, h = make_params(p)
            return "function(%s) %s%s end".format(p,h,b)
        }

        function make_short_func(p,b) {
            if #p == 0 { p.push('_') }
            var p, h = make_params(p)
            return "function(%s) %s%s end".format(p,h,b)
        }

        function make_func_decl(c,n,p,b,s) {
            var p, h = make_params(p)
            if s == 'lexical' && #n == 1 {
                c.define(n[1])
                return "local function %s(%s) %s%s end".format(n[1],p,h,b)
            }
            else if #n == 1 {
                return "function __env.%s(%s) %s%s end".format(n[1],p,h,b)
            }
            return "function %s(%s) %s%s end".format(n.concat('.'),p,h,b)
        }

        function make_meth_decl(ctx,n,p,b) {
            p.unshift('self')
            var p, h = make_params(p)
            return "__method(self,%q,function(%s) %s%s end);".format(n,p,h,b)
        }

        function make_trait_decl(n,p,w,b) {
            var p, h = make_params(p)
            return
                'self.%s=__trait(__env,%q,{%s},function(__env,self,%s) %s%s end);'
                .format(n,n,w,p,h,b)
        }

        function make_try_stmt(try_body, catch_args, catch_body) {
            return (
                'do local __return;'~
                '__try(function() %s end,function(%s) %s end);' ~
                'if __return then return __op_spread(__return) end'~
                ' end'
            ).format(try_body, catch_args || '', catch_body || '')
        }

        function make_import_stmt(n,f) {
            var q = [ ]
            for i=1, #n { q[i] = quote(n[i]) }
            return "local %s=__import(%q,{%s});".format(n.concat(','), f, q.concat(','))
        }
        function make_export_stmt(n) {
            var b = [ ]
            for i=1, #n {
                var q = quote(n[i])
                b[i] = '__export[%s]=true;'.format(q)
            }
            return b.concat('')
        }
        function define(name, ctx, base) {
            ctx.define(name, { base = base })
            return name
        }
        function define_const(name, ctx) {
            ctx.define(name)
            return
        }
        function enter(ctx) {
            ctx.enter()
            return
        }
        function leave(ctx) {
            ctx.leave()
            return
        }
        function lookup(name, ctx) {
            var info = ctx.lookup(name)
            if info {
                if info.base { return info.base~'.'~name }
                return name
            }
            return '__env.'~name
        }
        function lookup_or_define(name, ctx) {
            var info = ctx.lookup(name)
            if !info {
                define(name, ctx, '__env')
                return '__env.'~name
            }
            if info.base {
                return info.base~'.'~name
            }
            return name
        }

        rule __init {
            {~ <unit> ~} (!. | <{syntax_error("expected <EOF>")}>)
        }
        rule unit {
            {:set_return: {`false`} :}
            {:scope: {`'global'`} :}
            { %s* '#!' (!nl .)* %s* }? s
            {`'local __env=setmetatable({},{__index=_G});local self={};'`}
            (%1 -> enter)
            {~ (s <main_body_stmt>)* s ~}
            (%1 -> leave)
        }
        rule main_body_stmt {
            | <var_decl>
            | <func_decl>
            | <class_decl>
            | <trait_decl>
            | <object_decl>
            | <grammar_decl>
            | <package_decl>
            | <import_stmt>
            | <statement>
        }
        rule statement {
            | <if_stmt>
            | <try_stmt>
            | <for_stmt>
            | <for_in_stmt>
            | <do_while_stmt>
            | <while_stmt>
            | <break_stmt>
            | <continue_stmt>
            | <yield_stmt>
            | <block_stmt>
            | <bind_stmt>
            | <call_stmt>
        }
        rule call_stmt {
            {~ {~ <primary> s (
                <invoke_expr> | <{syntax_error("expected <invoke_expr>") }>
            ) ~} -> '%1;' semicol ~}
        }
        rule return_stmt {
            {~ "return" -> '' idsafe s (
            =set_return (<expr_list> | {`''`}) -> function(l,e) {
                if l {
                    return "do __return = {%s}; return end".format(e)
                }
                return "do return %s end".format(e)
            }) ~}
        }
        rule yield_stmt {
            'yield' idsafe {~ s <expr_list> ~} -> '__op_yield(%1);' semicol
        }
        rule break_stmt {
            {~ { "break" idsafe } -> "do __break = true; break end" ~}
        }
        rule continue_stmt {
            {~ { "continue" idsafe } -> "do break end" ~}
        }
        rule if_stmt {
            {~
            "if" idsafe s <expr> {`" then "`} s <block> (
                (s ({"else" idsafe s "if" idsafe} -> " elseif") s
                    <expr> {`" then "`} s <block>
                )*
                (s "else" idsafe s <block> {`" end "`} | {`" end "`})
            )
            ~}
        }
        rule try_stmt {
            {~
            "try" idsafe s
            "{" {~ <lambda_body> s ~} ("}" | <{ syntax_error("expected '}'") }>)
            (s "catch" idsafe s
                "(" s {~ (%1 -> enter) <param> ~} s ")" s
                "{" {~ <lambda_body> s (%1 -> leave) ~} "}"
            )?
            -> make_try_stmt
            ~}
        }
        rule import_stmt {
            {~ ("import" idsafe s
               {@ <param> (s "," s <param>)* @} s "from" s { <name> ("." <name>)* }
            ) -> make_import_stmt ~}
        }
        rule export_stmt {
            {~ "export" idsafe s {@ <name_list> @} -> make_export_stmt ~}
        }
        rule for_stmt {
            {~ "for" idsafe s <param> s "=" s <expr> s "," s <expr>
                (s "," s <expr>)? s <loop_body>
            ~}
        }
        rule for_in_stmt {
            {~ "for" idsafe s <param> (s "," s <param>)* s "in" idsafe s
                (<expr> -> "__op_each(%1)") s <loop_body>
            ~}
        }
        rule while_stmt {
            {~ "while" idsafe s <expr> s <loop_body> ~}
        }
        rule do_while_stmt {
            {~
               "do" idsafe {~ s <loop_body> s ~}
               "while" idsafe {~ s <expr> ~} -> 'repeat %1 until not(%2)'
            ~}
        }
        rule loop_body {
            ("{" -> " do local __break repeat ") <block_body> s
            (
                ("}" | <{ syntax_error("expected '}'") }>)
                -> " until true if __break then break end end "
            )
        }
        rule block {
            {~ ("{" -> "") <block_body> s (("}" | <{ syntax_error("expected '}'") }>) -> "") ~}
        }
        rule block_stmt {
            {~ ("{" -> "do ") <block_body> s (("}" | <{ syntax_error("expected '}'") }>) -> " end") ~}
        }
        rule block_body {
            {:scope: {`'lexical'`} :}
            (%1 -> enter)
            (s <block_body_stmt>)*
            (%1 -> leave)
        }
        rule block_body_stmt {
            | <var_decl>
            | <func_decl>
            | <return_stmt>
            | <statement>
        }
        rule lambda_body {
            {:set_return: {`true`} :}
            <block_body> s
        }

        rule var_decl {
            {~ "var" idsafe -> "local" s
                <var_list> (s "=" s <expr> (s "," s <expr>)*)?
            ~} -> '%1;' semicol
        }
        rule var_list {
            (<name> %1 -> define) (s "," s (<name> %1 -> define))*
            //<name> (s "," s <name>)*
        }
        rule slot_decl {
            {~ ("has" idsafe s <name> (s "=" s <expr> | {`""`}) semicol)
                -> '__has(self,"%1",function(self) return %2 end);'
            ~}
        }
        rule meth_decl {
            {~ ("method" idsafe %1 s <name> s
            "(" s <param_list> s ")" s
            "{" {~ <func_body> s ~} "}"
            ) -> make_meth_decl ~}
        }
        rule func_decl {
            {~ ("function" idsafe %1 s {@ <name> (s "." s <name>)* @} s
            "(" s <param_list> s ")" s
            "{" {~ <func_body> s ~} "}"
            =scope) -> make_func_decl ~}
        }
        rule func_body {
            {:scope: {`'lexical'`} :}
            (s <func_body_stmt>)*
            (%1 -> leave)
        }
        rule func_body_stmt {
            | <var_decl>
            | <func_decl>
            | <return_stmt>
            | <block_stmt>
            | (<expr> &(s "}") -> "do return %1 end")
            | <statement>
        }
        rule func {
            {~ ("function" idsafe s
            "(" s <param_list> s (")" | <{ syntax_error("expected ')'") }>) s "{"
                {~ <func_body> s ~}
            ("}" | <{ syntax_error("expected '}'") }>))
            -> make_func ~}
        }
        rule short_func {
            (":" -> '')
            ((s "(" s <param_list> s ")" | {`['_']`}) s "{" {~ <func_body> s ~} "}"
            -> make_short_func) {`')'`}
        }
        rule package_decl {
            "package" idsafe s {~
               {~ <name> %1 {`'__env'`} -> define ~} (s '.' s <name>)*
            ~} s
            "{" {~ (%1 -> enter) (s <main_body_stmt>)* s (%1 -> leave) ~}
            ("}" | <{ syntax_error("expected '}'") }>)
            -> '__package(__env,"%1",function(__env,self) %2 end);'
        }
        rule class_decl {
            "class" idsafe s {~ <name> %1 {`'__env'`} -> define ~} s
            (<class_from> | {`""`}) s
            (<class_with> | {`""`}) s
            "{" {~ <class_body> s ~} "}"
            -> 'self.%1=__class(__env,"%1",{%2},{%3},function(__env,self,super) %4 end);'
        }
        rule trait_decl {
            "trait" idsafe s {~ <name> %1 {`'__env'`} -> define ~} s
            ("(" s <param_list> s ")" | {`'...'`} {`''`}) s
            (<class_with> | {`""`}) s
            "{" {~ <class_body> s ~} "}"
            (%1 -> leave)
            -> make_trait_decl
        }
        rule object_decl {
            "object" idsafe s {~ <name> %1 {`'__env'`} -> define ~} s
            (<class_from> | {`""`}) s
            (<class_with> | {`""`}) s
            "{" {~ <class_body> s ~} "}"
            -> 'self.%1=__object(__env,"%1",{%2},{%3},function(__env,self,super) %4 end);'
        }
        rule class_body {
            {:scope: {`'lexical'`} :}
            (%1 -> enter)
            ({`'super'`} %1 -> define_const)
            {~ (s <class_body_stmt>)* ~}
            (%1 -> leave)
        }
        rule class_from {
            "from" idsafe s {~ <expr> (s "," s <expr>)* ~}
        }
        rule class_with {
            "with" idsafe s {~ <expr> (s "," s <expr>)* ~}
        }
        rule class_body_stmt {
            | <var_decl>
            | <slot_decl>
            | <func_decl>
            | <meth_decl>
            | <class_decl>
            | <trait_decl>
            | <object_decl>
            | <grammar_decl>
            | <statement>
        }
        rule rest {
            {~ {"..."} <param>? ~}
        }
        rule stack {
            {~
            | ("..." s "[" s <expr> s ("]" | <{ syntax_error("expected ']'") }>)) -> 'select(%1,...)'
            | {"..."}
            ~}
        }
        rule param_list {
            (%1 -> enter)
            {@
            | {~ <param> s ~} ("," {~ s <param> s ~})* ("," {~ s <rest> s ~})?
            | <rest>
            | {`nil`}
            @}
        }
        rule ident {
            {~ <name> %1 -> lookup ~}
        }
        rule param {
            <name> %1 -> define
        }
        rule name {
            { !keyword ((%alpha | "_") (%alnum | "_")*) }
        }
        rule name_list {
            {~ <name> (s "," s <name>)* ~}
        }
        rule qname {
            {~ <ident> ("." <name>)* ~}
        }
        rule hexadec {
            "-"? "0x" %xdigit+
        }
        rule decimal {
            "-"? digits ("." digits)? (("e"|"E") "-"? digits)?
        }
        rule number {
            {~ <hexadec> | <decimal> ~}
        }
        rule string {
            {~ (<qstring> | <astring>) ~} -> '(%1)'
        }
        rule special {
            {~
            | "\n"  -> "\\\n"
            | "\\$" -> "$"
            | "\\\\"
            | "\\" .
            ~}
        }
        rule qstring {
            | '"""' -> '"' {~ (
                | <string_expr>
                | {~ (<special> | !'"""'('"' -> '\"') | !(<string_expr> | "\"\"\"") .)+ ~}
            )* ~} ('"""' -> '"' | <{ syntax_error("expected '\"\"\"'") }>)
            | '"' {~ (
                | <string_expr>
                | {~ (<special> | !(<string_expr> | "\"") .)+ ~}
            )* ~} ('"' | <{ syntax_error("expected '\"'") }>)
        }
        rule astring {
            {~
                | ("'''" -> "") ('\\' | '\'' | (!"'''" .))* ("'''" -> "")
                | ("'"   -> "") ('\\' | '\'' | (!"'"   .))* ("'"   -> "")
            ~} -> quote
        }
        rule string_expr {
            ('${' -> '"..') {~ s (<expr> -> 'tostring(%1)') s ~} ("}" -> '.."')
        }
        rule vnil {
            {~ { "nil" } idsafe -> '(nil)' ~}
        }
        rule vtrue {
            {~ { "true" } idsafe -> '(true)' ~}
        }
        rule vfalse {
            {~ { "false" } idsafe -> '(false)' ~}
        }
        rule range {
            {~ (
                "[" s <expr> s ":" s <expr> ( s ":" s <expr> | {`"1"`} ) s "]"
            ) -> "Range(%1,%2,%3)" ~}
        }
        rule array {
            {~
                ("[" -> "Array(") s
                (<array_elements> | {`""`}) s
                ("]" -> ")" | <{syntax_error("expected ']'")}>)
            ~}
        }
        rule array_elements {
            <expr> ( s "," s <expr> )* (s ",")?
        }
        rule hash {
            {~
                ("{" -> "Hash({") s
                (<hash_pairs> | {`""`}) s
                ("}" -> "})" | <{syntax_error("expected '}'")}>)
            ~}
        }
        rule hash_pairs {
            <hash_pair> (s "," s <hash_pair>)* (s ",")?
        }
        rule hash_pair {
            (<name> | "[" s <expr> s ("]" | <{syntax_error("expected ']'")}>)) s
            "=" s <expr>
        }
        rule primary {
            | <ident>
            | <range>
            | <number>
            | <string>
            | <vnil>
            | <vtrue>
            | <vfalse>
            | <stack>
            | <array>
            | <hash>
            | <func>
            | <short_func>
            | <pattern>
            | "(" s <expr> s (")" | <{ syntax_error("expected ')'") }>)
        }
        rule paren_expr {
            "(" s ( <expr_list> | {`""`} ) s (")" | <{ syntax_error("expected ')'") }>)
        }
        rule member_expr {
            {~
            | "." s <name>
            | "[" s <expr> s ("]" | <{ syntax_error("expected ']'") }>)
            ~}
        }
        rule method_expr {
            {~
            | ("."  -> ":" | "::" -> ".") s <name> s (<short_expr> | <paren_expr>)
            ~}
        }
        rule access_expr {
            {~
            | <invoke_expr> s <access_expr>
            | <member_expr>
            ~}
        }
        rule invoke_expr {
            {~
            | (
                | <method_expr>
                | <member_expr>
                | <short_expr>
                | <paren_expr>
            ) s <invoke_expr>
            | <method_expr>
            | <short_expr>
            | <paren_expr>
            ~}
        }
        rule short_expr {
            (":" -> "(")
            ((s "(" s <param_list> s ")" | {`['_']`}) s "{" {~ <func_body> s ~} "}"
            -> make_short_func) {`')'`}
        }
        rule suffix_expr {
            | <invoke_expr>
            | <access_expr>
        }
        rule term {
            {~ <primary> (s <suffix_expr>)* ~}
        }
        rule expr_list {
            {~ <expr> (s "," s <expr>)* ~}
        }
        rule expr {
            {~ (<infix_expr> | <prefix_expr>) (
                s ("?" -> ' and ') s <expr> s (":" -> ' or ') s <expr>
            )? ~}
        }

        ///*
        var binop_patt = /(
            "+" | "-" | "~" | "^^" | "*" | "/" | "%" | "^" | ">>>" | ">>" | "<<"
            | "||" | "&&" | "|" | "&" | "==" | "!=" | ">="| "<=" | "<" | ">"
            | ("as" | "in") idsafe
        )/

        rule infix_expr {
            {@ {~ <prefix_expr> s ~} (
                { binop_patt }
                {~ s <prefix_expr> (&(s binop_patt) s)? ~}
            )+ @} -> fold_infix
        }
        //*/

        /*
        // recursive descent is faster for stock Lua, but LJ2 is faster
        // with shift-reduce, so right now I'm biased towards LJ2 ;)
        rule infix_expr {
            {~ <bool_or_expr> ~}
        }
        function make_infix_expr(oper, term) {
            / (({~ term (&(s oper) s)? ~} {: {oper} {~ s term ~} :}*) ~> fold_infix) /
        }
        rule bool_or_expr {
            <{ make_infix_expr(/"||"/, /<bool_and_expr>/ }>
        }
        rule bool_and_expr {
            <{ make_infix_expr(/"&&"/, /<bit_or_expr>/ }>
        }
        rule bit_or_expr {
            <{ make_infix_expr(/"|"/,  /<bit_xor_expr>/ }>
        }
        rule bit_xor_expr {
            <{ make_infix_expr(/"^"/,  /<bit_and_expr>/ }>
        }
        rule bit_and_expr {
            <{ make_infix_expr(/"&"/,  /<equals_expr>/ }>
        }
        rule equals_expr {
            <{ make_infix_expr(/"=="|"!="/, /<cmp_expr>/ }>
        }
        rule cmp_expr {
            <{ make_infix_expr(/"<="|">="|"<"|">"/, /<shift_expr>/ }>
        }
        rule shift_expr {
            <{ make_infix_expr(/">>>"|">>"|"<<"|("as"|"in") idsafe/, /<add_expr>/ }>
        }
        rule add_expr {
            <{ make_infix_expr(/"+"|"-"|"~"/, /<mul_expr>/ }>
        }
        rule mul_expr {
            <{ make_infix_expr(/"*"|"/"|"%"/, /<pow_expr>/ }>
        }
        rule pow_expr {
            <{ make_infix_expr(/"^^"/, /<prefix_expr>/ }>
        }
        //*/

        rule prefix_expr {
            {: {
                | "@" | "!" | "#" | "-" | "~"
                | ("throw" | "typeof") idsafe
            } s <prefix_expr> :} -> fold_prefix
            | {~ s <term> ~}
        }

        // binding expression rules
        rule bind_stmt {
            {~ (<bind_expr> | <bind_binop_expr>) -> '%1;' semicol ~}
        }
        rule bind_expr {
            {~ <bind_list> s "=" s (
                | <expr> (s "," s <expr>)*
                | <{syntax_error("bad right hand <expr>")}>
            ) ~}
        }
        rule bind_binop {
            { "+" | "-" | "*" | "/" | "%" | "||" | "|"| "&&"
            | "&" | "^^" | "^" | "~" | ">>>" | ">>" | "<<"
            } "="
        }
        rule bind_binop_expr {
            {~ <bind_term> s <bind_binop> s <expr> -> make_binop_bind ~}
        }
        rule bind_list {
            <bind_term> (s "," s <bind_term>)*
        }
        rule bind_term {
            {~
            | <primary> (s <bind_member>)+
            | {~ <name> %1 -> lookup_or_define ~}
            ~}
        }
        rule bind_member {
            {~
            | <suffix_expr> s <bind_member>
            | <bind_suffix>
            ~}
        }
        rule bind_suffix {
            {~
            | "." s <name> s
            | "[" s <expr>  s "]"
            ~}
        }

        // PEG grammar and pattern rules
        rule pattern {
            "/" {~ s <rule_alt> s ~} "/" -> '__patt.P(%1)'
        }
        rule grammar_decl {
            {~ (
            "grammar" idsafe s {~ <name> %1 {`'__env'`} -> define ~} s
            "{" {~ <grammar_body> s ~} "}"
            ) -> 'self.%1=__grammar(__env,"%1",function(__env,self) %2 end);' ~}
        }
        rule grammar_body {
            {:scope: {`'lexical'`} :}
            (%1 -> enter)
            (s <grammar_body_stmt>)*
            (%1 -> leave)
        }
        rule grammar_body_stmt {
            | <rule_decl>
            | <var_decl>
            | <func_decl>
            | &<return_stmt> <{syntax_error("return outside of function body")}>
            | <statement>
        }
        rule rule_decl {
            "rule" idsafe s <name> s "{" {~ s <rule_body> s ~} "}"
            -> '__rule(self,"%1",%2);'
        }
        rule rule_body {
            <rule_alt> | {`'__patt.P(nil)'`}
        }
        rule rule_alt {
            {~ ("|" -> '' s)? <rule_seq> (s ("|" -> "+") s <rule_seq>)* ~}
        }
        rule rule_seq {
            {@ {~ s <rule_suffix> ~}+ @} -> function(a) { a.concat('*') }
        }
        rule rule_rep {
            {~ "+" -> "^1" | "*" -> "^0" | "?" -> "^-1" | "^"s("+"|"-")?s[0-9]+ ~}
        }
        rule rule_prefix {
            {~ (("&" -> "#") | ("!" -> "-")) {~ s <rule_prefix> ~} -> '%1%2'
            | <rule_primary>
            ~}
        }

        var prod_oper = / "->" | "~>" | "=>" /

        rule rule_suffix {
            ({~ <rule_prefix> (&(s prod_oper) s)? ~}
            {: {prod_oper} {~ s <rule_prod> ~} :}*) ~> function(a,o,b,t) {
                if o == "=>" {
                    return '__patt.Cmt(%s,%s)'.format(a,b)
                }
                else if o == "~>" {
                    return '__patt.Cf(%s,%s)'.format(a,b)
                }
                else {
                    if t == 'array' {
                        return '__patt.Ca(%s,%s)'.format(a,b)
                    }
                    else if t == 'hash' {
                        return '__patt.Ch(%s,%s)'.format(a,b)
                    }
                    else {
                        return '(%s)/(%s)'.format(a,b)
                    }
                }
            }
        }
        rule rule_prod {
            {~
            | <array> {`'array'`}
            | <hash>  {`'hash'`}
            | <term>
            ~}
        }
        rule rule_primary {
            ( <rule_group>
            | <rule_term>
            | <rule_class>
            | <rule_predef>
            | <rule_back_capt>
            | <rule_group_capt>
            | <rule_sub_capt>
            | <rule_const_capt>
            | <rule_hash_capt>
            | <rule_array_capt>
            | <rule_simple_capt>
            | <rule_any>
            | <rule_ref>
            ) (s <rule_rep>)*
        }
        rule rule_group {
            {~ "(" s (<rule_alt> | <{ syntax_error("expected <rule_alt>") }>) s
                (")" | <{ syntax_error("expected ')'") }>)
            ~}
        }
        rule rule_term {
            {~ <string> -> '__patt.P(%1)' ~}
        }
        rule rule_class {
            {~
                ("[" -> '(') ("^" -> '__patt.P(1)-')?
                ({@ (!"]" <rule_item>)+ @} -> function(a) { "("~a.concat("+")~")" })
                ("]" -> ')')
            ~}
        }
        rule rule_item {
            {~ <rule_predef> | <rule_range>
            | {.} -> function(c) { '__patt.P(%q)'.format(c) }
            ~}
        }
        rule rule_predef {
            {~ ('%' -> '') (
                | { [0-9]+ } -> '__patt.Carg(%1)'
                | <name> -> '__patt.Def("%1")'
            ) ~}
        }
        rule rule_range {
            {~ . ("-"->'') !"]" . ~} -> function(r) { '__patt.R(%q)'.format(r) }
        }
        rule rule_any {
            {~ "." -> '__patt.P(1)' ~}
        }
        rule rule_ref {
            {~
            ("<" -> '') s
                ( <name> -> '__patt.V("%1")'
                | {~ ("{" -> '__patt.P(') s <expr> s ("}" -> ")") ~}
                ) s
            (">" -> '')
            | <qname>
            ~}
        }
        rule rule_group_capt {
            {~ "{:" ((<name> -> quote ":") | {`'nil'`}) {~ s <rule_alt> ~} s ":}"
            -> '__patt.Cg(%2,%1)'
            ~}
        }
        rule rule_back_capt {
            "=" (<name> -> quote) -> '__patt.Cb(%1)'
        }
        rule rule_sub_capt {
            "{~" {~ s <rule_alt> s ~} "~}" -> '__patt.Cs(%1)'
        }
        rule rule_const_capt {
            "{`" {~ s <expr> s ~} "`}" -> '__patt.Cc(%1)'
        }
        rule rule_hash_capt {
            "{%" {~ s <rule_alt> s ~} "%}" -> '__patt.Ch(%1)'
        }
        rule rule_array_capt {
            "{@" {~ s <rule_alt> s ~} "@}" -> '__patt.Ca(%1)'
        }
        rule rule_simple_capt {
            "{" {~ s <rule_alt> s ~} "}" -> '__patt.C(%1)'
        }
    }
    method compile(lupa, name) {
        var ctx = Lupa.Context.new()
        ctx.enter()
        ctx.define('_G')
        ctx.define('self')
        var lua = Lupa.Grammar.match(lupa, 1, ctx)
        ctx.leave()
        return lua
    }
}

_G.eval = function(src) {
    var eval = assert(loadstring(Lupa.compile(src),'=eval:'~src))
    return eval()
}

var getopt = function(...args) {
   var opt = { }
   var idx = 0
   var len = #args
   while idx < len {
      idx = idx + 1
      var arg = args[idx]
      if arg.sub(1,1) == '-' {
         var o = arg.sub(2)
         if o == 'o' {
            idx = idx + 1
            opt['o'] = args[idx]
         }
         else if o == 'l' {
            opt['l'] = true
         }
         else if o == 'b' {
            idx = idx + 1
            opt['b'] = args[idx]
         }
         else {
            error('unknown option: '~arg, 2)
         }
      }
      else {
         opt['file'] = arg
      }
   }
   return opt
}

var run = function(...) {
   var opt = getopt(...)
   var sfh = assert(io::open(opt['file']))
   var src = sfh.read('*a')
   sfh.close()

   var lua = Lupa.compile(src)
   if opt['l'] {
      io.stdout.write(lua)
      os::exit(0)
   }

   if opt['o'] {
      var outc = io::open(opt['o'], "w+")
      outc.write(lua)
      outc.close()
   }
   else {
      lua = lua.gsub("^%s*#![^\n]*",'')
      var main = assert(loadstring(lua,'='~opt['file']))
      if opt['b'] {
         var outc = io::open(opt.b, "wb+")
         outc.write(String::dump(main))
         outc.close()
      }
      else {
         var main_env = setmetatable({ }, { __index = _G })
         setfenv(main, main_env)
         main(opt['file'], ...)
      }
   }
}

arg = arg ? [ unpack(arg) ] : [ ]
{
   // from strict.lua
   var mt = getmetatable(_G)
   if mt == nil {
      mt = newtable()
      setmetatable(_G, mt)
   }

   mt.__declared = newtable()

   function what() {
      var d = debug::getinfo(3, "S")
      return d && d.what || "C"
   }

   mt.__newindex = function(t, n, v) {
      if !mt.__declared[n] {
         var w = what()
         if w != "main" && w != "C" {
            error("assign to undeclared variable '${n}'", 2)
         }
         mt.__declared[n] = true
      }
      rawset(t, n, v)
   }

   mt.__index = function(t, n) {
      if !mt.__declared[n] && what() != "C" {
         error("variable '${n}' is not declared", 2)
      }
      return rawget(t, n)
   }
}

Lupa.PATH = "./?.lu;./lib/?.lu;./src/?.lu"
{
   var P = _G['package']
   P.loaders[#P.loaders + 1] = function(modname) {
      var filename = modname.gsub("%.", "/")
      for path in Lupa.PATH.gmatch("([^;]+)") {
         if path != "" {
            var filepath = path.gsub("?", filename)
            var file = io::open(filepath, "r")
            if file {
               var src = file.read("*a")
               var lua = Lupa.compile(src)
               var mod = assert(loadstring(lua, '='~filepath))()
               P.loaded[modname] = mod
               return mod
            }
         }
      }
   }
}

if arg[1] { run(unpack(arg)) }
// vim: ft=lupa

