grammar Kula {

    function error_line(src, pos) {
        var line = 1
        var index, limit = 1, pos
        while index <= limit {
            var s, e = src.find("\n", index, true)
            if s == nil || e > limit { break }
            index = e + 1
            line  = line + 1
        }
        return line
    }
    function error_near(src, pos) {
        if (#src < pos + 20) {
            return src.sub(pos)
        }
        else {
            return src.sub(pos, pos + 20)~"..."
        }
    }
    function syntax_error(m) {
        return function(src, pos) {
            var line, near = error_line(src, pos), error_near(src, pos)
            error("SyntaxError: ${m||''} on line ${line} near '${near}'")
        }
    }

    var id_counter = 9
    function genid() {
        id_counter += 1
        return '_'~id_counter
    }

    function quote(c) { "%q".format(c) }

    var nl      = / "\n" /
    var comment = / {~
        | (((!nl %s)* "//" (!nl .)* nl) -> "\n")
        | ("/*"->'' (!"*/" (nl -> "\n" | . -> ''))* ("*/" -> ''))
    ~} /
    var idsafe  = / !(%alnum | "_") /
    var s       = / (comment | %s)* /
    var semicol = / (";" -> '')? /
    var digits  = / (%digit "_"?)+ /
    var keyword = / (
          "var" | "function" | "class" | "with" | "like" | "in"
        | "nil" | "true" | "false" | "typeof" | "return" | "as"
        | "for" | "throw" | "method" | "has" | "from" | "break"
        | "continue" | "package" | "import" | "try" | "catch"
        | "finally" | "if" | "else" | "yield" | "grammar"
    ) idsafe /

    var prec = {
        ["^^"]  = 4,
        ["*"]   = 5,
        ["/"]   = 5,
        ["%"]   = 5,
        ["+"]   = 6,
        ["-"]   = 6,
        ["~"]   = 6,
        [">>"]  = 7,
        ["<<"]  = 7,
        [">>>"] = 7,
        ["<="]  = 8,
        [">="]  = 8,
        ["<"]   = 8,
        [">"]   = 8,
        ["in"]  = 8,
        ["as"]  = 8,
        ["=="]  = 9,
        ["!="]  = 9,
        ["&"]   = 10,
        ["^"]   = 11,
        ["|"]   = 12,
        ["&&"]  = 13,
        ["||"]  = 14,
    }

    var unrops = {
        ["!"] = "not(%s)",
        ["#"] = "#(%s)",
        ["-"] = "-(%s)",
        ["~"] = "__op_bnot(%s)",
        ["..."] = "__op_spread(%s)",
    }

    var binops = {
        ["^^"] = "(%s)^(%s)",
        ["*"] = "(%s)*(%s)",
        ["/"] = "(%s)/(%s)",
        ["%"] = "(%s)%%(%s)",
        ["+"] = "(%s)+(%s)",
        ["-"] = "(%s)-(%s)",
        ["~"] = "(%s)..(%s)",
        [">>"] = "__op_rshift(%s,%s)",
        ["<<"] = "__op_lshift(%s,%s)",
        [">>>"] = "__op_arshift(%s,%s)",
        ["<="] = "(%s)<=(%s)",
        [">="] = "(%s)>=(%s)",
        ["<"] = "(%s)<(%s)",
        [">"] = "(%s)>(%s)",
        ["in"] = "__op_in(%s,%s)",
        ["as"] = "__op_as(%s,%s)",
        ["=="] = "(%s)==(%s)",
        ["!="] = "(%s)~=(%s)",
        ["&"] = "__op_band(%s,%s)",
        ["^"] = "__op_bxor(%s,%s)",
        ["|"] = "__op_bor(%s,%s)",
        ["&&"] = "(%s)and(%s)",
        ["||"] = "(%s)or(%s)",
    }

    function fold_prefix(o,e) {
        return unrops[o].format(e)
    }

    ///*
    function fold_infix(e) {
        var s = [ e[1] ]
        for i=2, #e {
            s[#s + 1] = e[i]
            while !binops[s[#s]] && s[#s - 1] {
                var p = s[#s - 1]
                var n = e[i + 1]
                if n == nil || prec[p] <= prec[n] {
                    var b, o, a = s.pop(), s.pop(), s.pop()
                    if !binops[o] {
                        error("bad expression: ${e}, stack: ${s}")
                    }
                    s.push(binops[o].format(a, b))
                }
                else {
                    break
                }
            }
        }
        return s[1]
    }
    //*/

    /* enable for recursive descent expr parsing
    function fold_infix(a,o,b) {
        return binops[o].format(a,b)
    }
    //*/

    function fold_bind(f,...e) {
        if #f == 1 {
            return f[1].format(...e)
        }
        var b, r = [ ], [ ...e ]
        var t = f.map(genid)
        b.push("local %s=%s".format(t.concat(","),r.concat(",")))
        for i=1, #f {
            b[#b + 1] = f[i].format(t[i])
        }
        return b.concat(";")
    }
    function make_binop_bind(a, o, b) {
        Kula.bind_expr.match(a~"="~a~o~b)
    }

    function make_params(p) {
        var h = ''
        if #p > 0 && p[#p].match("^%.%.%.") {
            var r = p[#p]
            p[#p] = "..."
            h = "local %s=Tuple(...);".format(r.sub(4))
        }
        return p.concat(","), h
    }

    function make_func(p,b) {
        var p, h = make_params(p)
        return "function(%s) %s%s end".format(p,h,b)
    }

    function make_func_decl(n,p,b,s) {
        var p, h = make_params(p)
        if s == 'lexical' && !n.find('.',1,true) {
            return "local function %s(%s) %s%s end".format(n,p,h,b)
        }
        else {
            return "function %s(%s) %s%s end".format(n,p,h,b)
        }
    }

    function make_meth_decl(n,p,b) {
        p.unshift('self')
        var p, h = make_params(p)
        return "__method(self,%q,function(%s) %s%s end);".format(n,p,h,b)
    }

    function make_trait_decl(n,p,w,b) {
        var p, h = make_params(p)
        return
            '__trait(self,%q,{%s},function(self,%s) %s%s end);'
            .format(n,w,p,h,b)
    }

    function make_try_stmt(try_body, catch_args, catch_body) {
        return (
            'do local __return;'~
            '__try(function() %s end,function(%s) %s end);' ~
            'if __return then return __spread(__return) end'~
            ' end'
        ).format(try_body, catch_args || '', catch_body || '')
    }

    function make_import_stmt(n,f,a) {
        if f == nil {
            // import from <path>
            return "__import(self,%s);".format(n)
        }
        else if n.isa(Array) {
            // import <list> from <path> (in <qname>)
            if a {
                return "__import(self,%s,Array(%s),%s);".format(f,n.concat(","),a)
            } else {
                return "__import(self,%s,Array(%s));".format(f,n.concat(","))
            }
        }
        else {
            // import <name> from <path> (as <alias>)
            return "__import(self,%s,Hash({[%s]=%s}));".format(f,n,a)
        }
    }

    rule __init {
        {~ <unit> ~} (!. | <{syntax_error("expected <EOF>")}>)
    }
    rule unit {
        {:set_return: {`false`} :}
        {:scope: {`'global'`} :}
        (
            {~ (s <main_body_stmt>)* s ~}
            -> "return __unit(function(self,...) %1 end,...)"
        )
    }
    rule main_body_stmt {
        | <var_decl>
        | <func_decl>
        | <class_decl>
        | <trait_decl>
        | <grammar_decl>
        | <package_decl>
        | <import_stmt>
        | <statement>
    }
    rule statement {
        | <if_stmt>
        | <try_stmt>
        | <for_stmt>
        | <for_in_stmt>
        | <while_stmt>
        | <break_stmt>
        | <continue_stmt>
        | <block_stmt>
        | <bind_stmt>
        | <expr_stmt>
    }
    rule expr_stmt {
        {~ <expr> -> '%1;' semicol ~}
    }
    rule return_stmt {
        {~ "return" -> '' idsafe s (=set_return <expr_list> -> function(l,e) {
            if l {
                return "do __return = {%s}; return end".format(e)
            }
            return "do return %s end".format(e)
        }) ~}
    }
    rule break_stmt {
        {~ { "break" idsafe } -> "do __break = true; break end" ~}
    }
    rule continue_stmt {
        {~ { "continue" idsafe } -> "do break end" ~}
    }
    rule if_stmt {
        {~
        "if" idsafe s <expr> {`" then "`} s <block> (
            (s ({"else" idsafe s "if" idsafe} -> " elseif") s
                <expr> {`" then "`} s <block>
            )*
            (s "else" idsafe s <block> {`" end "`} | {`" end "`})
        )
        ~}
    }
    rule try_stmt {
        "try" idsafe s "{" {~ <lambda_body> s ~} "}"
        (s "catch" idsafe s "(" s <ident> s ")" s "{" {~ <lambda_body> s ~} "}")?
        -> make_try_stmt
    }
    rule import_stmt {
        {~ (
            "import" idsafe s (<import_in> | <import_as> | <import_from>)
        ) -> make_import_stmt ~}
    }
    rule import_as {
        (<ident> -> quote) s "from" idsafe s (<qname> -> quote)
        "as" idsafe s (<ident> -> quote)
    }
    rule import_in {
        {@ (<ident> -> quote) (s "," s (<ident> -> quote))* @} s
        "from" idsafe s (<qname> -> quote)
        (s "in" idsafe s (<ident> -> quote))?
    }
    rule import_from {
        "from" idsafe s (<qname> -> quote)
    }
    rule for_stmt {
        {~ "for" idsafe s <ident> s "=" s <expr> s "," s <expr>
            (s "," s <expr>)? s <loop_body>
        ~}
    }
    rule for_in_stmt {
        {~ "for" idsafe s <ident_list> s "in" s
            (<expr> -> "__op_each(%1)") s <loop_body>
        ~}
    }
    rule while_stmt {
        {~ "while" idsafe s <expr> s <loop_body> ~}
    }
    rule loop_body {
        ("{" -> " do local __break repeat ") <block_body> s
        ("}" -> " until true if __break then break end end ")
    }
    rule block {
        {~ ("{" -> "") <block_body> s ("}" -> "") ~}
    }
    rule block_stmt {
        {~ ("{" -> "do ") <block_body> s ("}" -> " end") ~}
    }
    rule block_body {
        {:outer: =scope :} {:scope: {`'lexical'`} :}
        (s <block_body_stmt>)*
        {:scope: =outer :}
    }
    rule block_body_stmt {
        | <var_decl>
        | <func_decl>
        | <return_stmt>
        | <statement>
    }
    rule lambda_body {
        {:old_set_return: =set_return :} {:set_return: {`true`} :}
        <block_body> s
        {:set_return: =old_set_return :}
    }
    rule slot_decl {
        {~ ("has" idsafe s <ident> (s "=" s (<expr> | {`""`}))? semicol)
            -> '__has(self,"%1",function(self) return %2 end);'
        ~}
    }
    rule meth_decl {
        {~ ("method" idsafe s <qname> s "(" s <param_list> s ")" s "{"
            {~ <func_body> s ~}
        "}") -> make_meth_decl ~}
    }
    rule func_decl {
        {~ ("function" idsafe s <qname> s "(" s <param_list> s ")" s "{"
            {~ <func_body> s ~}
        "}" =scope) -> make_func_decl ~}
    }
    rule func_body {
        {:outer: =scope :} {:scope: {`'lexical'`} :}
        (s <func_body_stmt>)*
        {:scope: =outer :}
    }
    rule func_body_stmt {
        | <var_decl>
        | <func_decl>
        | <return_stmt>
        | (<expr> &(s "}") -> "do return %1 end")
        | <statement>
    }
    rule func {
        {~ ("function" idsafe s "(" s <param_list> s ")" s "{"
            {~ (s <func_body_stmt>)* s ~}
        "}") -> make_func ~}
    }
    rule package_decl {
        "package" idsafe s (<qname> -> quote) s "{"
            {~ (s <main_body_stmt>)* s ~}
        "}" -> '__package(self,%1,function(self) %2 end);'
    }
    rule class_decl {
        "class" idsafe s <ident> s
        (<class_from> | {`""`}) s
        (<class_with> | {`""`}) s
        "{" {~ <class_body> s ~} "}"
        -> '__class(self,"%1",{%2},{%3},function(self,super) %4 end);'
    }
    rule trait_decl {
        "trait" idsafe s <ident> s
        ("(" s <param_list> s ")" | {`'...'`} {`''`}) s
        (<class_with> | {`""`}) s
        "{" {~ <class_body> s ~} "}"
        -> make_trait_decl
    }
    rule class_body {
        {:outer: =scope :} {:scope: {`'lexical'`} :}
        (s <class_body_stmt>)*
        {:scope: =outer :}
    }
    rule class_from {
        "from" idsafe s {~ <expr> (s "," s <expr>)* ~}
    }
    rule class_with {
        "with" idsafe s {~ <expr> (s "," s <expr>)* ~}
    }
    rule class_body_stmt {
        | <var_decl>
        | <slot_decl>
        | <func_decl>
        | <meth_decl>
        | <statement>
    }
    rule rest {
        {~ {"..."} <ident> ~}
    }
    rule param_list {
        {@ <ident> (s "," s <ident>)* (s "," s <rest>)? | <rest> | {`nil`} @}
    }
    rule ident {
        { !keyword ((%alpha | "_") (%alnum | "_")*) }
    }
    rule ident_list {
        {~ <ident> (s "," s <ident>)* ~}
    }
    rule qname {
        {~ <ident> ({"::"} -> '.' <ident>)* ~}
    }
    rule hexadec {
        "-"? "0x" %xdigit+
    }
    rule decimal {
        "-"? digits ("." digits)? (("e"|"E") "-"? digits)?
    }
    rule number {
        { <hexadec> | <decimal> }
    }
    rule string {
        {~ (<qstring> | <astring>) -> '(%1)' ~}
    }
    rule qstring {
        {~
            (('"""' -> '"') (
                <string_expr>
                | {~ ('\\' | '\"' | '\$'->'$' | !('"""' | <string_expr>).)+ ~}
            )* ('"""' -> '"'))
            |
            ('"' (
                <string_expr>
                | {~ ('\\' | '\"' | '\$'->'$' | !('"' | <string_expr>).)+ ~}
            )* '"')
        ~}
    }
    rule astring {
        {~
            ("'''" -> "")
            ('\\' | '\'' | (!"'''" .))*
            ("'''" -> "")
            |
            ("'" -> "") ('\\' | '\'' | (!"'" .))* ("'" -> "")
        ~} -> quote
    }
    rule string_expr {
        {~ ("${" -> '') s (<expr> -> '"..tostring(%1).."') s ("}" -> '') ~}
    }
    rule vnil {
        {~ { "nil" } idsafe -> '(nil)' ~}
    }
    rule vtrue {
        {~ { "true" } idsafe -> '(true)' ~}
    }
    rule vfalse {
        {~ { "false" } idsafe -> '(false)' ~}
    }
    rule range {
        {~ (
            "[" s <expr> s ":" s <expr> ( s ":" s <expr> | {`"1"`} ) s "]"
        ) -> "Range(%1,%2,%3)" ~}
    }
    rule array {
        {~
            ({"["} -> "Array(") s
            (<array_elements> | {`""`}) s
            ({"]"} -> ")" | <{syntax_error("expected ']'")}>)
        ~}
    }
    rule array_elements {
        <expr> ( s "," s <expr> )* (s ",")?
    }
    rule hash {
        {~
            ({"{"} -> "Hash({") s
            (<hash_pairs> | {`""`}) s
            ({"}"} -> "})" | <{syntax_error("expected '}'")}>)
        ~}
    }
    rule hash_pairs {
        <hash_pair> (s "," s <hash_pair>)* (s ",")?
    }
    rule hash_pair {
        (<ident> | "[" s <expr> s ("]" | <{syntax_error("expected ']'")}>)) s
        "=" s <expr>
    }
    rule primary {
        | <ident>
        | <range>
        | <number>
        | <string>
        | <vnil>
        | <vtrue>
        | <vfalse>
        | <array>
        | <hash>
        | <func>
        | <pattern>
        | "(" s <expr> s ")"
    }
    rule call_expr {
        <ident> s <paren_expr>
    }
    rule paren_expr {
        "(" s ( <expr_list> | {`""`} ) s ")"
    }
    rule member_expr {
        {~ s ({"."} -> ":") (s <ident> -> "__get_%1()") | ({"::"} -> ".") s <ident> ~}
    }
    rule method_expr {
        {~ s ({"."} -> ":" | {"::"} -> ".") (s <call_expr> -> "%1(%2)") ~}
    }
    rule term {
        {~ <primary> (
            <suffix_expr> | <method_expr> | <member_expr>
        )* ~}
    }
    rule suffix_expr {
        | {~ ("[" -> ":__getitem(") s <expr> s ("]" -> ")") ~}
        | {~ "(" s <expr_list>? s ")" ~}
    }
    rule expr_list {
        {~ <expr> (s "," s <expr>)* ~}
    }
    rule expr {
        {~ <infix_expr> | <prefix_expr> ~}
    }

    ///*
    var binop_patt = /(
        "+" | "-" | "~" | "^^" | "*" | "/" | "%" | "^" | ">>>" | ">>" | "<<"
        | "||" | "&&" | "|" | "&" | "==" | "!=" | ">="| "<=" | "<" | ">"
        | "in" idsafe | "like" idsafe
    )/

    rule infix_expr {
        {@ {~ <prefix_expr> s ~} (
            { binop_patt }
            {~ s <prefix_expr> (&(s binop_patt) s)? ~}
        )+ @} -> fold_infix
    }
    //*/

    /*
    // recursive descent is faster for stock Lua, but LJ2 is faster
    // with shift-reduce, so right now I'm biased towards LJ2 ;)
    rule infix_expr {
        {~ <bool_or_expr> ~}
    }
    function make_infix_expr(oper, term) {
        / (({~ term (&(s oper) s)? ~} {: {oper} {~ s term ~} :}*) ~> fold_infix) /
    }
    rule bool_or_expr {
        <{ make_infix_expr(/"||"/, /<bool_and_expr>/ }>
    }
    rule bool_and_expr {
        <{ make_infix_expr(/"&&"/, /<bit_or_expr>/ }>
    }
    rule bit_or_expr {
        <{ make_infix_expr(/"|"/,  /<bit_xor_expr>/ }>
    }
    rule bit_xor_expr {
        <{ make_infix_expr(/"^"/,  /<bit_and_expr>/ }>
    }
    rule bit_and_expr {
        <{ make_infix_expr(/"&"/,  /<equals_expr>/ }>
    }
    rule equals_expr {
        <{ make_infix_expr(/"=="|"!="/, /<cmp_expr>/ }>
    }
    rule cmp_expr {
        <{ make_infix_expr(/"<="|">="|"<"|">"/, /<shift_expr>/ }>
    }
    rule shift_expr {
        <{ make_infix_expr(/">>>"|">>"|"<<"/, /<add_expr>/ }>
    }
    rule add_expr {
        <{ make_infix_expr(/"+"|"-"|"~"/, /<mul_expr>/ }>
    }
    rule mul_expr {
        <{ make_infix_expr(/"*"|"/"|"%"/, /<pow_expr>/ }>
    }
    rule pow_expr {
        <{ make_infix_expr(/"^^"/, /<prefix_expr>/ }>
    }
    //*/

    rule prefix_expr {
        {: { "..." | "!" | "#" | "-" | "~" } s <prefix_expr> :} -> fold_prefix
        | {~ s <term> ~}
    }

    rule var_decl {
        {~
            {"var" idsafe} -> "local" s
            <ident_list> (s "=" s <expr> (s "," s <expr>)*)?
        ~} -> '%1;' semicol
    }

    // binding expression rules
    rule bind_stmt {
        {~ (<bind_expr> | <bind_binop_expr>) -> '%1;' semicol ~}
    }
    rule bind_expr {
        {~ <bind_list> s "=" s {: <expr> (s "," s <expr>)* :} -> fold_bind ~}
     }
    rule bind_binop {
        { "+" | "-" | "*" | "/" | "%" | "||" | "|"| "&&"
        | "&" | "^^" | "^" | "~" | ">>>" | ">>" | "<<"
        } "="
    }
    rule bind_binop_expr {
        {~ {:
        &(<bind_term> s <bind_binop>) {(!<bind_binop> .)+} s <bind_binop> s <expr>
        :} -> make_binop_bind ~}
    }
    rule bind_list {
        {@ <bind_term> (s "," s <bind_term>)* @}
    }
    rule bind_term {
        {~ (<call_expr>|<primary>) <bind_member> | (<ident> -> "%1=%%s") ~}
    }
    rule bind_member {
        | (<bind_slot>|<bind_name>|<bind_item>) &(s (<bind_binop>|"="|","))
        | (<method_expr>|<member_expr>) <bind_member>
    }
    rule bind_slot {
        {~ ({"."} -> ":") (s <ident> -> "__set_%1(%%s)") ~}
    }
    rule bind_item {
        {~ ({"["} -> ":") (s <expr> -> "__setitem(%1,%%s)") ({"]"} -> "") ~}
    }
    rule bind_name {
        {~ ({"::"} -> ".") (s <ident> -> "%1=%%s") ~}
    }

    // PEG grammar and pattern rules
    rule pattern {
        "/" {~ s <rule_alt> s ~} "/" -> '__patt.P(%1)'
    }
    rule grammar_decl {
        {~ (
            "grammar" idsafe s <ident> s
            "{" {~ <grammar_body> s ~} "}"
        ) -> '__grammar(self,"%1",function(self) %2 end);' ~}
    }
    rule grammar_body {
        {:outer: =scope :} {:scope: {`'lexical'`} :}
        (s <grammar_body_stmt>)*
        {:scope: =outer :}
    }
    rule grammar_body_stmt {
        | <rule_decl>
        | <var_decl>
        | <func_decl>
        | &<return_stmt> <{syntax_error("return outside of function body")}>
        | <statement>
    }
    rule rule_decl {
        "rule" idsafe s <ident> s "{" {~ s <rule_body> s ~} "}"
        -> '__rule(self,"%1",%2);'
    }
    rule rule_body {
        <rule_alt> | {`'__patt.P(nil)'`}
    }
    rule rule_alt {
        {~ ({"|"} -> '' s)? <rule_seq> (s ({"|"} -> "+") s <rule_seq>)* ~}
    }
    rule rule_seq {
        {@ {~ s <rule_suffix> ~}+ @} -> function(a) { a.concat('*') }
    }
    rule rule_rep {
        {~ {"+"}->"^1"|{"*"}->"^0"|{"?"}->"^-1"|{"^"s("+"|"-")s[0-9]+} ~}
    }
    rule rule_prefix {
        {~ (({"&"} -> "#") | ({"!"} -> "-")) {~ s <rule_prefix> ~} -> '%1%2'
        | <rule_primary>
        ~}
    }

    var prod_oper = / "->" | "~>" | "=>" /

    rule rule_suffix {
        ({~ <rule_prefix> (&(s prod_oper) s)? ~} {: {prod_oper} {~ s <term> ~} :}*) ~> function(a,o,b) {
            if o == "=>" {
                return '__patt.Cmt(%s,%s)'.format(a,b)
            }
            else if o == "~>" {
                return '__patt.Cf(%s,%s)'.format(a,b)
            }
            return "(%s)/(%s)".format(a,b)
        }
    }
    rule rule_primary {
        ( <rule_group>
        | <rule_term>
        | <rule_class>
        | <rule_predef>
        | <rule_group_capt>
        | <rule_back_capt>
        | <rule_sub_capt>
        | <rule_const_capt>
        | <rule_hash_capt>
        | <rule_array_capt>
        | <rule_simple_capt>
        | <rule_any>
        | <rule_ref>
        ) (s <rule_rep>)*
    }
    rule rule_group {
        {~ "(" s <rule_alt> s ")" ~}
    }
    rule rule_term {
        {~ <string> -> '__patt.P(%1)' ~}
    }
    rule rule_class {
        {~
            ("[" -> '') ("^" -> '__patt.P(1)-')?
            ({@ (!"]" <rule_item>)+ @} -> function(a) { "("~a.concat("+")~")" })
            ("]" -> '')
        ~}
    }
    rule rule_item {
        {~ <rule_predef> | <rule_range>
        | {.} -> function(c) { '__patt.P(%q)'.format(c) }
        ~}
    }
    rule rule_predef {
        {~ "%" <ident> -> '__patt.Def("%1")' ~}
    }
    rule rule_range {
        {~ . ("-"->'') !"]" . ~} -> function(r) { '__patt.R(%q)'.format(r) }
    }
    rule rule_any {
        {~ "." -> '__patt.P(1)' ~}
    }
    rule rule_ref {
        {~
        ("<" -> '') s
            ( <ident> -> '__patt.V("%1")'
            | ("{" -> "(") s <expr> s ("}" -> ")")
            ) s
        (">" -> '')
        | <qname>
        ~}
    }
    rule rule_group_capt {
        {~ "{:" ((<ident> -> quote ":") | {`'nil'`}) {~ s <rule_alt> ~} s ":}"
        -> '__patt.Cg(%2,%1)'
        ~}
    }
    rule rule_back_capt {
        "=" (<ident> -> quote) -> '__patt.Cb(%1)'
    }
    rule rule_sub_capt {
        "{~" {~ s <rule_alt> s ~} "~}" -> '__patt.Cs(%1)'
    }
    rule rule_const_capt {
        "{`" {~ s <expr> s ~} "`}" -> '__patt.Cc(%1)'
    }
    rule rule_hash_capt {
        "{%" {~ s <rule_alt> s ~} "%}" -> '__patt.Ch(%1)'
    }
    rule rule_array_capt {
        "{@" {~ s <rule_alt> s ~} "@}" -> '__patt.Ca(%1)'
    }
    rule rule_simple_capt {
        "{" {~ s <rule_alt> s ~} "}" -> '__patt.C(%1)'
    }
}

