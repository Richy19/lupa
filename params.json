{"name":"Lupa","body":"![logo](https://github.com/richardhundt/lupa/wiki/lupa_logo.png)\r\n\r\n# NAME\r\n\r\nLupa - multi-paradigm object oriented, dynamic language\r\n\r\n# SYNOPSIS\r\n\r\n    lupa <file>\r\n        run the script\r\n    lupa <file> -l\r\n        list generated Lua\r\n\r\n# INTRODUCTION\r\n\r\n*NOTE:* This is alpha software and is therefore very likey to change\r\n\r\nLupa is a language which translates to Lua. So, bowing to the\r\nmandatory justification of \"why yet another language\", here's the\r\nreasoning. LuaJIT2 is fast. Very fast. I like fast in a language\r\nruntime. LuaJIT2 also has a low memory footprint. Which is also\r\nnice.\r\n\r\nHowever, although a beautiful language, Lua is also very minimal.\r\nI want a language with a bit more meat. More than that though, I\r\nwant a language which gives me the most syntactic and semantic\r\nflexibility possible, while allowing me to write code which is\r\nrun-time safe. Not type safe, neccessarily, but more generally,\r\nconstraint safe, where a constraint may be a type check.\r\n\r\nFor syntactic and semantic flexibility, Lupa borrows an idea from\r\nScala in that infix and prefix operators are method calls. That's\r\nprobably where the similarity ends. Lupa is a dynamic language.\r\n\r\nFor safety, Lupa provides compile-time symbol checks to catch typos,\r\nand for the rest we have guard expressions.\r\n\r\nLupa to Lua source translation is done without the use of abstract\r\nsyntax trees in a single pass, using essentially a big substitution\r\ncapture with LPeg. This limits static checks and early binding\r\nacross source files, but compilation is fast and within a given\r\ncompilation unit we can still perform some checks. It also allows\r\nus to call from Lupa into Lua.\r\n\r\n## Features\r\n\r\nMost of Lua's semantics shine through, such as Lua's for loops,\r\n1-based arrays, first-class functions, and late binding.\r\n\r\nHowever, Lupa adds several features, such as:\r\n\r\n* classes with single inheritance\r\n* parameterisable traits and mixin composition\r\n* everything-is-an-object semantics\r\n* static symbol resolution\r\n* type guards and assertions\r\n* language integrated grammars (via LPeg)\r\n* operators as method calls\r\n* continue statement\r\n* string interpolation\r\n* builtin Array type\r\n* short function literals\r\n* switch-case statement\r\n* try-catch statement\r\n* and more...\r\n\r\n# LANGUAGE\r\n\r\nSyntactically Lupa belongs to the C family of languages, in that\r\nit has curly braces delimiting blocks and includes familiar constructs\r\nsuch as switch statements and while loops.\r\n\r\n## Sample\r\n\r\n```ActionScript\r\ntrait Pet[T] {\r\n   // parameterised traits with lexical scoping\r\n   has size : T\r\n}\r\n \r\nclass Mammal {\r\n   has blood = \"warm\"\r\n}\r\n\r\ntrait Named {\r\n   // default property values are lazy expressions\r\n   has name = error(\"A pet needs a name!\")\r\n}\r\n \r\n// single inheritance with trait mixins\r\nclass Hamster from Mammal with Pet[Number], Named {\r\n\r\n   // default initializer\r\n   method init(name) {\r\n      self.size = 42\r\n      .name = name // short for self.name = name\r\n   }\r\n\r\n   method greet(whom : String) {\r\n      // string interpolation\r\n      print(\"Hi ${whom}, I am ${.name}, a ${.size}, ${.blood}, ${typeof self}!\")\r\n   }\r\n\r\n   // class bodies have lexical scope\r\n   var numbers = [ \"one\", \"two\", \"three\", \"four\", \"five\" ]\r\n\r\n   method count(upto) {\r\n      // short functions\r\n      upto.times((_) => { print(numbers[_]) })\r\n\r\n      // same thing, but `times' as infix operator\r\n      upto times => print(numbers[_])\r\n   }\r\n}\r\n \r\nvar rudy = Hamster.new(\"Rudy\")\r\nrudy.greet(\"Jack\")\r\nrudy.count(5)\r\n```\r\n\r\n## Tutorial\r\n\r\nTo introduce the language, we start with a tutorial, where we\r\nimplement a naive NumArray type which simply wraps an Array, and\r\nconstrains values to be of type Number. Our first attempt might\r\nlook as follows:\r\n\r\n```ActionScript\r\nclass NumArray {\r\n    // a \"public\" read-write property with lazy constructor\r\n    has data = [ ]\r\n\r\n    // initializer\r\n    method init(data) {\r\n        self.data = data || [ ]\r\n    }\r\n\r\n    method set(index, value) {\r\n        if !value is Number {\r\n            throw \"${value} is not a Number\"\r\n        }\r\n        self.data[index] = value\r\n    }\r\n\r\n    method get(index) {\r\n        return self.data[index]\r\n    }\r\n}\r\n```\r\n\r\nThis has several problems. One problem is that it doesn't\r\nimplement the same interface as the built-in Array type which\r\nit is wrapping. Lupa provides postcircumfix operator methods\r\nwhich allow us to make this more consistent:\r\n\r\n```ActionScript\r\nclass NumArray {\r\n    has data = [ ]\r\n    method init(data) {\r\n        self.data = data || [ ]\r\n    }\r\n    method _[]=(index, value) {\r\n        if !value is Number {\r\n            throw \"${value} is not a Number\"\r\n        }\r\n        self.data[index] = value\r\n    }\r\n    method _[](index) {\r\n        return self.data[index]\r\n    }\r\n}\r\n```\r\n\r\nThe `_[]` and `_[]=` methods are called when getting or\r\nsetting a value using array subscript.\r\n\r\nA second thing which can make our implementation nicer is\r\nto use guard annotations instead of explicitly checking\r\nthat our value is a `Number`.\r\n\r\n```ActionScript\r\nclass NumArray {\r\n    has data = [ ]\r\n    method init(data) {\r\n        self.data = data || [ ]\r\n    }\r\n    method _[]=(index, value : Number) {\r\n        self.data[index] = value\r\n    }\r\n    method _[](index) {\r\n        return self.data[index]\r\n    }\r\n    method len {\r\n        self.data.len\r\n    }\r\n}\r\n```\r\n\r\nThe Array class also implements a `len` property which is\r\nreadonly. Properties introduced by `has` are actually just\r\nsugar for creating a getter/setter method pair. Therefore\r\nto create a readonly property, simply define the method\r\nand call it without parameters:\r\n\r\n```ActionScript\r\nclass NumArray {\r\n    has data = [ ]\r\n    method init(data) {\r\n        self.data = data || [ ]\r\n    }\r\n    method _[]=(index, value : Number) {\r\n        self.data[index] = value\r\n    }\r\n    method _[](index) {\r\n        return self.data[index]\r\n    }\r\n    method len {\r\n        .data.len\r\n    }\r\n}\r\n```\r\n\r\nNote that the `return` keyword is missing from our `len` method.\r\nThis is because the last expression evaluated in a function\r\nbody has an implicit return. Similarly we could have left\r\nout the `_[]` method's return.\r\n\r\nThis makes it convenient to use `map` and similar functions\r\nfor transforming list-like objects. More on that later.\r\n\r\nWe've also left out `self`, which is implied by the leading `.`.\r\n\r\nA class body is actually a closure which can have lexical variables\r\nwhich are not accessible from outside. This can be used to make our\r\ninner array private. You could do the following:\r\n\r\n```ActionScript\r\nclass NumArray {\r\n    // create a table with weak keys\r\n    var private = { } weak 'k'\r\n\r\n    method init(data) {\r\n        private[self] = data || [ ]\r\n    }\r\n    method _[]=(index, value : Number) {\r\n        private[self][index] = value\r\n    }\r\n    method _[](index) {\r\n        private[self][index]\r\n    }\r\n    method len {\r\n        private[self].len\r\n    }\r\n}\r\n```\r\n\r\nIt's not all that pretty, but then again, Lupa is more interested\r\nin being flexible than carrying around a shotgun. Another thing\r\nyou could do is to use the low-level direct table access operator `#`.\r\n\r\nThis operator exists for interop with Lua and Lua libraries (and for\r\nmaking hard things possible):\r\n\r\n```ActionScript\r\nclass NumArray {\r\n    method init(data : Array = [ ]) {\r\n        self#data = data\r\n    }\r\n    method _[]=(index, value : Number) {\r\n        self#data[index] = value\r\n    }\r\n    method _[](index) {\r\n        self#data[index]\r\n    }\r\n    method len {\r\n        self#data.len\r\n    }\r\n}\r\n```\r\n\r\nThis is also not pretty, but it is noticeable. Which is good. The\r\n`#` operator is associated with accessing something's private parts\r\nin that member accesses via `.` are method calls. Names following\r\nthe `#` operator are also not mangled, which is needed for calling\r\ninto Lua and FFI code.\r\n\r\nYou could, of course, save yourself all the above trouble if you're\r\njust interested in constraint checking and create a guard:\r\n\r\n```ActionScript\r\nguard NumArray(sample : Array) {\r\n    // the Number annotation on the value does the coercion\r\n    for index, value : Number in sample {\r\n        // in-place, although we could return a copy\r\n        sample[index] = value\r\n    }\r\n    return sample\r\n}\r\n\r\nvar foo : NumArray = [ 1, 2, \"three\" ] // KABOOM! cannot coerce \"three\" to Number\r\n```\r\n\r\nAlternatively you could save yourself even that much trouble and just say:\r\n\r\n```ActionScript\r\nvar foo : Array[Number] = [ 1, 2, 3 ]\r\n```\r\n\r\nThis works simply because the Array class itself implements a static\r\nmethod `_[]` which constructs a guard on demand and returns it.\r\n\r\n## Scoping\r\n\r\nLupa has two kinds of scopes. The first is simple lexical scoping,\r\nwhich is seen in function and class bodies, and control structures.\r\n\r\nThe second kind of scope is the environment scope, which is modeled\r\nafter Lua 5.2's `_ENV` idea, where symbols which are not declared in\r\na compilation unit, are looked up in a special `__env` table, which\r\ndelegates to Lua's `_G` global table.\r\n\r\nAt the top level of a script, class, object, trait and function\r\ndeclarations are bound to `__env`, while variable declarations\r\nremain lexical.\r\n\r\nInside class, object and trait bodies, only function declarations\r\nbind to `__env`. Method and property declarations bind to `self`\r\n(the class or object).\r\n\r\nInside function bodies, function declarations are lexical and are\r\n*not* hoisted to the top of the scope, meaning they are only visible\r\nafter they are declared.\r\n\r\nVariable declarations declared as `var` are always lexical. To declare\r\na variable bound to the environment, use `our`:\r\n\r\n```ActionScript\r\nvar answer = 42  // ordinary lexical\r\nour DEBUG = true // bound to environment\r\n```\r\n\r\n```ActionScript\r\n// bound to the environment (__env.envfunc)\r\nfunction envfunc() {\r\n    // ...\r\n}\r\n// a lexical function\r\nvar localfunc = function() {\r\n    // ...\r\n}\r\nclass MyClass {\r\n    // this function is only visible in this block\r\n    function hidden() {\r\n        // ...\r\n    }\r\n    method munge() {\r\n        hidden()\r\n    }\r\n}\r\n```\r\n\r\nNested function declarations are also lexical, however the differ\r\nfrom function literals in that inside a function declaration, the\r\nfunction itself is always visible, so can be called recursively:\r\n\r\n```ActionScript\r\nfunction outer() {\r\n\r\n    // inner function is lexical\r\n    function inner() {\r\n        // inner itself is visible here\r\n    }\r\n\r\n    // not quite the same thing\r\n    var inner = function() {\r\n        // inner itself is not visible here\r\n    }\r\n}\r\n```\r\n\r\n## Variables\r\n\r\nLexical variables are introduced with the `var` keyword, followed\r\nby a comma separated list of identifiers, and an optional `=`\r\nfollowed by a list of expressions.\r\n\r\n```ActionScript\r\nvar a, b         // declare only\r\nvar c, d = 1, 2  // declare and assign\r\n```\r\n\r\nVariables can also be introduced using the `our` keyword, which, as\r\nmentioned earlier binds to the environment table:\r\n\r\n```ActionScript\r\nfunction life_etc() {\r\n    print(\"the answer is ${answer}\")\r\n}\r\nour answer = 42\r\nlife_etc()\r\n```\r\n\r\n## Guards\r\n\r\nVarious declarations may also include guard expressions:\r\n\r\n```ActionScript\r\nvar s : String = \"first\"\r\n```\r\n\r\nFuture updates to guarded variables within a given scope cause the\r\nguard's `coerce` method to be called with the value as argument to\r\nallow the guard to coerce the value or raise an exception.\r\n\r\nThe above statement (loosely) translates to the following Lua snippet:\r\n\r\n```Lua\r\nlocal s = String:coerce(\"first\")\r\n```\r\n\r\nClasses and traits, as well as built-in types `Number`, `String`,\r\n`Boolean`, `Array`, `Table` and `Function` can be used as guards.\r\n\r\nCustom guards can also be created using a `guard` declaration:\r\n\r\n```ActionScript\r\nguard Size(sample : Number) {\r\n    if !sample > 0 {\r\n        throw TypeError.new(\"${sample} does not pass Size constraint\")\r\n    }\r\n    return sample\r\n}\r\nvar size : Size = 4.2\r\n```\r\n\r\n## Assignment\r\n\r\nAssignments can be simple binding expressions:\r\n\r\n```ActionScript\r\neverything.answer = 42\r\n```\r\n... or compound:\r\n\r\n```ActionScript\r\na += 1\r\n```\r\n\r\n## Operators\r\n\r\nMost operators in Lupa are method calls. For example:\r\n\r\n```ActionScript\r\na + 42\r\n```\r\n\r\nwhich is the same as:\r\n```ActionScript\r\na.+(42)\r\n```\r\n\r\nThis syntax applies to all method calls, so the following are equivalent:\r\n\r\n```ActionScript\r\nvar d = Dog.new(\"Fido\")\r\nvar d = Dog new \"Fido\"\r\n10.times((i) => { print(i) })\r\n10 times (i) => { print(i) }\r\n10 times => print(_) // same as above\r\n```\r\n\r\nA notable exception are `===` and `!==` which are raw identity comparisons.\r\n\r\nInfix operator precedences are determined by their first character and are\r\nalways left associative. In the order of highest to lowest precedence:\r\n\r\n### Infix operator precedence\r\n\r\n* alphanumeric word\r\n* /, *, %\r\n* +, -, ~\r\n* :, ?\r\n* =, !\r\n* <, >\r\n* ^\r\n* &\r\n* |\r\n\r\nPrefix operators can also be defined as methods. The following may be used:\r\n\r\n* @\r\n* #\r\n* -\r\n* ~\r\n* *\r\n\r\nTo define a prefix operator method, the method name must be suffixed\r\nwith an underscore. For example:\r\n```ActionScript\r\nclass A {\r\n    // unary minus\r\n    method -_(b) {\r\n        ...\r\n    }\r\n}\r\n```\r\n\r\nAdditionally, postcircumfix operators are allowed in certain contexts. Array and\r\nTable subscripts are actually defined as `_[]` and `_[]=` methods. These\r\ncan be used to implement your own collection:\r\n\r\n```ActionScript\r\nclass NumberArray {\r\n    has data = [ ]\r\n    method _[](index) {\r\n        .data[index]\r\n    }\r\n    method _[]=(index, value : Number) {\r\n        .data[index] = value\r\n    }\r\n}\r\nvar nums = NumberArray.new\r\nnums[1] = 42\r\n```\r\n\r\nProperty assignment is also a bit special, in that `foo.bar = 42` translates\r\nto `foo.bar_eq(42)`.\r\n\r\n## Identifiers\r\n\r\nIndentifiers in Lupa come in two flavours. The first type are the\r\nfamiliar type seen in most languages (currently `?` and `!` are\r\nsupported in the first and last positions respectively). The following\r\npattern describes these:\r\n\r\n```\r\nname = / (%alpha | \"_\" | \"$\" | \"?\") (%alnum | \"_\" | \"$\")* \"!\"? /\r\n```\r\n\r\nOther other kind of identifiers consist only of punctuation as described\r\nearlier under Operators. These are used in method declarations:\r\n\r\n```ActionScript\r\nclass Point {\r\n    has x : Number = 0\r\n    has y : Number = 0\r\n    method +(b : Point) : Point {\r\n        Point.new(.x + b.x, .y + b.y)\r\n    }\r\n}\r\n```\r\n\r\n## Patterns\r\n\r\nLupa integrates LPeg into the language and supports pattern literals\r\ndelimited by a starting and ending `/`:\r\n\r\n```ActionScript\r\nvar ident = / { [a-zA-Z_] ([a-zA-Z_0-9]+) } /\r\n```\r\n\r\nPatterns are also composable. Here the lexical pattern `a` is\r\nreferenced from within the second pattern:\r\n\r\n```ActionScript\r\nvar a = / '42' /\r\nprint(/ { 'answer' | <{a}> } /.match(\"42\"))\r\n```\r\n\r\nGrammars are constructed in that nominal types can declare patterns\r\nas rules in their body. Here's the example macro expander from the\r\nLPeg website translated to Lupa:\r\n\r\n```ActionScript\r\nobject Macro {\r\n\r\n    rule text {\r\n        {~ <item>* ~}\r\n    }\r\n    rule item {\r\n        <macro> | [^()] | '(' <item>* ')'\r\n    }\r\n    rule arg {\r\n        ' '* {~ (!',' <item>)* ~}\r\n    }\r\n    rule args {\r\n        '(' <arg> (',' <arg>)* ')'\r\n    }\r\n    rule macro {\r\n        | ('apply' <args>) -> '%1(%2)'\r\n        | ('add'   <args>) -> '%1 + %2'\r\n        | ('mul'   <args>) -> '%1 * %2'\r\n    }\r\n}\r\n\r\nvar s = \"add(mul(a,b),apply(f,x))\"\r\nprint(Macro.text(s))\r\n```\r\n\r\nThe Lupa grammar is self bootstrapped, so hopefully that can serve\r\nas a reference until I finish this document. ;)\r\n\r\n## Modules\r\n\r\nModules are simply Lupa source files. There are no additional\r\nnamespaces constructs within the language to declare modules or\r\npackages.\r\n\r\nSymbols are not exported by default. To export symbols, the `export`\r\nstatement can be used. It has the form `export <name> [, <name>]*`\r\nSymbols can be imported using the `import` statement, which takes\r\nthe form `import [<name> [, <name>] from <dotted_path>`.\r\n\r\nFor example:\r\n\r\n```ActionScript\r\n/*--- file: ./my/shapes.lu ---*/\r\nexport Point, Point3D\r\n\r\nclass Point {\r\n    has x = 0\r\n    has y = 0\r\n    method move(x, y) {\r\n        self.x = x\r\n        self.y = y\r\n    }\r\n}\r\nclass Point3D from Point {\r\n    has z = 0\r\n    method move(x, y, z) {\r\n        super.move(x, y)\r\n        self.z = z\r\n    }\r\n}\r\n\r\n/*--- file: test.lu ---*/\r\nimport Point, Point3D from my.shapes\r\n\r\nvar p = Point3D.new\r\np.move(1, 2, 3)\r\n```\r\n\r\nIt is an error to attempt to export a symbol which is never declared,\r\nor is declared but evaluates to `nil`.\r\n","tagline":"OO language targetting Lua","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}