export ffi, FFI, C, OS, ARCH, ABI

var ffi  = require('ffi')
var OS   = ffi#os
var ARCH = ffi#arch
var C    = ffi#C
var ABI  = ffi#abi

class FFI {

   our OS   = ffi#os
   our ARCH = ffi#arch
   our C    = ffi#C

   object CDEF {
      method << (defs : String) {
         ffi#cdef(defs)
      }
   }

   static method defs { CDEF }

   trait MetaType[type] {

      var ffi     = require('ffi')
      var C       = ffi#C
      var ctype_t = ffi#typeof(type)

      static method new(...args) {
         var inst = ctype_t()
         if self#__slots#init {
            self#__slots#init(inst, ...args)
         }
         return inst
      }

      static method apply(arg) {
         return ffi#cast(ctype_t, arg)
      }

      static method check(that) {
         return ffi#istype(type, that)
      }

      static method __finalize__ {
         ffi#metatype(ctype_t, self)
      }

      self#__tostring = nil
      method toString {
         return tostring(ctype_t)+': '+global#__LUPA__#refaddr(self)
      }
   }

   static method new(ctype, ...args) {
      ffi#new(ctype, ...args)
   }
   static method cast(this, that) {
      ffi#cast(this, that)
   }
   static method typeof(obj, nelem) {
      if nelem !== nil {
         return ffi#typeof(obj, nelem)
      }
      else {
         return ffi#typeof(obj)
      }
   }
   static method sizeof(obj) {
      ffi#sizeof(obj)
   }
   static method alignof(obj) {
      ffi#sizeof(obj)
   }
   static method istype(this, that) {
      ffi#istype(this, that)
   }
   static method fill(dst, len, c) {
      if c !== nil {
         return ffi#fill(dst, len, c)
      }
      else {
         return ffi#fill(dst, len)
      }
   }
   static method cdef(defs) {
      ffi#cdef(defs)
   }
   static method abi(param) {
      ffi#abi(param)
   }
   static method metatype(ct, metatable) {
      ffi#metatype(ct, metatable)
   }
   static method copy(dst, src, len) {
      if len !== nil {
         return ffi#copy(dst, src, len)
      }
      else {
         return ffi#copy(dst, src, len)
      }
   }
   static method string(obj, len) {
      if len !== nil {
         return ffi#string(obj, len)
      }
      else {
         return ffi#string(obj)
      }
   }
   static method gc(obj, fun) {
      ffi#gc(obj, fun)
   }
   static method load(path, global) {
      ffi#load(path, global)
   }
   static method errno(newerr) {
      if newerr !== nil {
         return ffi#errno(newerr)
      }
      else {
         return ffi#errno()
      }
   }
   static method offsetof(ct, field) {
      ffi#offsetof(ct, field)
   }
}

FFI::CDEF << """
   void *malloc(size_t);
   void free(void *);
"""

if OS === 'OSX' {
   FFI::CDEF << """
      typedef int64_t quad_t;
      typedef long ssize_t;
      typedef unsigned long u_long;

      typedef uint32_t ino_t; /* XXX: 32 bit inodes for now */
      typedef int64_t  off_t;
      typedef int32_t  dev_t;
      typedef uint32_t uid_t;
      typedef uint32_t gid_t;
      typedef uint16_t mode_t;
      typedef uint16_t nlink_t;
      typedef int64_t  blkcnt_t;
      typedef int32_t  blksize_t;
   """
}
else if OS === 'Linux' {

}

