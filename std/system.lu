export ffi, FFI, C, OS, ARCH, ABI

var ffi  = require('ffi')
var OS   = ffi#os
var ARCH = ffi#arch
var C    = ffi#C
var ABI  = ffi#abi

class FFI {

   our OS   = ffi#os
   our ARCH = ffi#arch
   our C    = ffi#C

   object CDEF {
      method << (defs : String) {
         ffi#cdef(defs)
      }
   }

   static method defs { CDEF }

   trait MetaType[type] {

      var ffi     = require('ffi')
      var C       = ffi#C
      var ctype_t = ffi#typeof(type)

      static method new(...args) {
         var inst = ctype_t()
         if self#__slots#init {
            self#__slots#init(inst, ...args)
         }
         return inst
      }

      static method apply(arg) {
         return ffi#cast(ctype_t, arg)
      }

      static method check(that) {
         return ffi#istype(type, that)
      }

      static method __finalize__ {
         ffi#metatype(ctype_t, self)
      }

      self#__tostring = nil
      method toString {
         return tostring(ctype_t)+': '+global#__LUPA__#refaddr(self)
      }
   }

   static method new(ctype, ...args) {
      ffi#new(ctype, ...args)
   }
   static method cast(this, that) {
      ffi#cast(this, that)
   }
   static method typeof(obj, nelem) {
      if nelem !== nil {
         return ffi#typeof(obj, nelem)
      }
      else {
         return ffi#typeof(obj)
      }
   }
   static method sizeof(obj) {
      ffi#sizeof(obj)
   }
   static method alignof(obj) {
      ffi#sizeof(obj)
   }
   static method istype(this, that) {
      ffi#istype(this, that)
   }
   static method fill(dst, len, c) {
      if c !== nil {
         return ffi#fill(dst, len, c)
      }
      else {
         return ffi#fill(dst, len)
      }
   }
   static method cdef(defs) {
      ffi#cdef(defs)
   }
   static method abi(param) {
      ffi#abi(param)
   }
   static method metatype(ct, metatable) {
      ffi#metatype(ct, metatable)
   }
   static method copy(dst, src, len) {
      if len !== nil {
         return ffi#copy(dst, src, len)
      }
      else {
         return ffi#copy(dst, src, len)
      }
   }
   static method string(obj, len) {
      if len !== nil {
         return ffi#string(obj, len)
      }
      else {
         return ffi#string(obj)
      }
   }
   static method gc(obj, fun) {
      ffi#gc(obj, fun)
   }
   static method load(path, global) {
      ffi#load(path, global)
   }
   static method errno(newerr) {
      if newerr !== nil {
         return ffi#errno(newerr)
      }
      else {
         return ffi#errno()
      }
   }
   static method offsetof(ct, field) {
      ffi#offsetof(ct, field)
   }
   static method strerror(errnum) {
      var len = 256
      var buf = FFI.new('char[?]', len)
      FFI::C#strerror_r(errnum, buf, len)
      return FFI.string(buf)
   }
}

if FFI::OS === 'OSX' {
   FFI::CDEF << """
      typedef uint32_t ino_t;
      typedef int64_t  off_t;
      typedef int32_t  dev_t;
      typedef uint32_t uid_t;
      typedef uint32_t gid_t;
      typedef uint16_t mode_t;
      typedef uint16_t nlink_t;
      typedef int64_t  blkcnt_t;
      typedef int32_t  blksize_t;
      typedef int32_t  suseconds_t;
      typedef uint32_t useconds_t;
   """
}
else if FFI::OS === 'Windows' {
   // TODO: port this whole mess
   throw "get a *real* operating system!"
}
else {
   FFI::CDEF << """
      typedef unsigned long ino_t;
      typedef unsigned long nlink_t;

      typedef long off_t;
      typedef long blksize_t;
      typedef long blkcnt_t;

      typedef uint32_t mode_t;
      typedef uint32_t uid_t;
      typedef uint32_t gid_t;
      typedef uint64_t dev_t;

      typedef long suseconds_t;
      typedef unsigned long useconds_t;
   """
}
FFI::CDEF << """
   // 16 bit
   typedef uint16_t in_port_t;

   // 32 bit
   typedef uint32_t socklen_t;
   typedef uint32_t id_t;
   typedef int32_t  pid_t;
   typedef int32_t  clockid_t;

   // 64 bit
   typedef uint64_t loff_t;
   typedef uint64_t off64_t;

   // posix standards
   typedef unsigned short int sa_family_t;

   // typedefs which are word length
   typedef unsigned long size_t;
   typedef long ssize_t;
   typedef long kernel_off_t;
   typedef long time_t;
   typedef long clock_t;
   typedef unsigned long rlim_t;
   typedef unsigned long aio_context_t;
   typedef unsigned long nfds_t;

   // overridden (should be word length)
   typedef int32_t fd_mask;

   void *malloc(size_t);
   void free(void *);
   int strerror_r(int errnum, char *strerrbuf, size_t buflen);
"""


