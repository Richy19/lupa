export Fiber, Channel, Semaphore, File

our ffi = require('ffi')
our jit = require('jit')

var uid_type, gid_type
if jit#os == 'Windows' {
   gid_type = 'unsigned char'
   uid_type = 'unsigned char'
}
else {
   gid_type = 'unsigned int'
   uid_type = 'unsigned int'
}

ffi#cdef("""
   void *malloc (size_t __size);
   void free (void *__ptr);

   typedef struct ngx_queue_s ngx_queue_t;
   struct ngx_queue_s {
     ngx_queue_t *prev;
     ngx_queue_t *next;
   };

   typedef intptr_t ssize_t;

   typedef enum {
     UV_UNKNOWN = -1,
     UV_OK = 0,
     UV_EOF = 1,
     UV_EADDRINFO = 2,
     UV_EACCES = 3,
     UV_EAGAIN = 4,
     UV_EADDRINUSE = 5,
     UV_EADDRNOTAVAIL = 6,
     UV_EAFNOSUPPORT = 7,
     UV_EALREADY = 8,
     UV_EBADF = 9,
     UV_EBUSY = 10,
     UV_ECONNABORTED = 11,
     UV_ECONNREFUSED = 12,
     UV_ECONNRESET = 13,
     UV_EDESTADDRREQ = 14,
     UV_EFAULT = 15,
     UV_EHOSTUNREACH = 16,
     UV_EINTR = 17,
     UV_EINVAL = 18,
     UV_EISCONN = 19,
     UV_EMFILE = 20,
     UV_EMSGSIZE = 21,
     UV_ENETDOWN = 22,
     UV_ENETUNREACH = 23,
     UV_ENFILE = 24,
     UV_ENOBUFS = 25,
     UV_ENOMEM = 26,
     UV_ENOTDIR = 27,
     UV_EISDIR = 28,
     UV_ENONET = 29,
     UV_ENOTCONN = 31,
     UV_ENOTSOCK = 32,
     UV_ENOTSUP = 33,
     UV_ENOENT = 34,
     UV_ENOSYS = 35,
     UV_EPIPE = 36,
     UV_EPROTO = 37,
     UV_EPROTONOSUPPORT = 38,
     UV_EPROTOTYPE = 39,
     UV_ETIMEDOUT = 40,
     UV_ECHARSET = 41,
     UV_EAIFAMNOSUPPORT = 42,
     UV_EAISERVICE = 44,
     UV_EAISOCKTYPE = 45,
     UV_ESHUTDOWN = 46,
     UV_EEXIST = 47,
     UV_ESRCH = 48,
     UV_ENAMETOOLONG = 49,
     UV_EPERM = 50,
     UV_ELOOP = 51,
     UV_EXDEV = 52,
     UV_ENOTEMPTY = 53,
     UV_ENOSPC = 54,
     UV_EIO = 55,
     UV_EROFS = 56,
     UV_MAX_ERRORS
   } uv_err_code;


   typedef enum {
     UV_UNKNOWN_HANDLE = 0,
     UV_ASYNC,
     UV_CHECK,
     UV_FS_EVENT,
     UV_IDLE,
     UV_NAMED_PIPE,
     UV_POLL,
     UV_PREPARE,
     UV_PROCESS,
     UV_TCP,
     UV_TIMER,
     UV_TTY,
     UV_UDP,
     UV_ARES_TASK,
     UV_FILE,
     UV_HANDLE_TYPE_MAX
   } uv_handle_type;

   typedef enum {
     UV_UNKNOWN_REQ = 0,
     UV_CONNECT,
     UV_WRITE,
     UV_SHUTDOWN,
     UV_UDP_SEND,
     UV_FS,
     UV_WORK,
     UV_GETADDRINFO,
     UV_REQ_TYPE_MAX
   } uv_req_type;

   typedef enum {
     UV_FS_UNKNOWN = -1,
     UV_FS_CUSTOM,
     UV_FS_OPEN,
     UV_FS_CLOSE,
     UV_FS_READ,
     UV_FS_WRITE,
     UV_FS_SENDFILE,
     UV_FS_STAT,
     UV_FS_LSTAT,
     UV_FS_FSTAT,
     UV_FS_FTRUNCATE,
     UV_FS_UTIME,
     UV_FS_FUTIME,
     UV_FS_CHMOD,
     UV_FS_FCHMOD,
     UV_FS_FSYNC,
     UV_FS_FDATASYNC,
     UV_FS_UNLINK,
     UV_FS_RMDIR,
     UV_FS_MKDIR,
     UV_FS_RENAME,
     UV_FS_READDIR,
     UV_FS_LINK,
     UV_FS_SYMLINK,
     UV_FS_READLINK,
     UV_FS_CHOWN,
     UV_FS_FCHOWN
   } uv_fs_type;

   typedef struct {
     char* base;
     size_t len;
   } uv_buf_t;

   typedef struct uv_loop_s uv_loop_t;
   typedef struct uv_ares_task_s uv_ares_task_t;
   typedef struct uv_err_s uv_err_t;
   typedef struct uv_handle_s uv_handle_t;
   typedef struct uv_stream_s uv_stream_t;
   typedef struct uv_tcp_s uv_tcp_t;
   typedef struct uv_udp_s uv_udp_t;
   typedef struct uv_pipe_s uv_pipe_t;
   typedef struct uv_tty_s uv_tty_t;
   typedef struct uv_poll_s uv_poll_t;
   typedef struct uv_timer_s uv_timer_t;
   typedef struct uv_prepare_s uv_prepare_t;
   typedef struct uv_check_s uv_check_t;
   typedef struct uv_idle_s uv_idle_t;
   typedef struct uv_async_s uv_async_t;
   typedef struct uv_getaddrinfo_s uv_getaddrinfo_t;
   typedef struct uv_process_s uv_process_t;
   typedef struct uv_counters_s uv_counters_t;
   typedef struct uv_cpu_info_s uv_cpu_info_t;
   typedef struct uv_interface_address_s uv_interface_address_t;

   typedef struct uv_req_s uv_req_t;
   typedef struct uv_shutdown_s uv_shutdown_t;
   typedef struct uv_write_s uv_write_t;
   typedef struct uv_connect_s uv_connect_t;
   typedef struct uv_udp_send_s uv_udp_send_t;
   typedef struct uv_fs_s uv_fs_t;

   typedef struct uv_fs_event_s uv_fs_event_t;
   typedef struct uv_work_s uv_work_t;

   typedef int uv_os_sock_t;
   typedef int uv_file;
   typedef uv_buf_t (*uv_alloc_cb)(uv_handle_t* handle, size_t suggested_size);

   typedef void (*uv_read_cb)(uv_stream_t* stream, ssize_t nread, uv_buf_t buf);
   typedef void (*uv_read2_cb)(uv_pipe_t* pipe, ssize_t nread, uv_buf_t buf,
      uv_handle_type pending);

   typedef void (*uv_write_cb)(uv_write_t* req, int status);
   typedef void (*uv_connect_cb)(uv_connect_t* req, int status);
   typedef void (*uv_shutdown_cb)(uv_shutdown_t* req, int status);
   typedef void (*uv_connection_cb)(uv_stream_t* server, int status);
   typedef void (*uv_close_cb)(uv_handle_t* handle);
   typedef void (*uv_poll_cb)(uv_poll_t* handle, int status, int events);
   typedef void (*uv_timer_cb)(uv_timer_t* handle, int status);
   typedef void (*uv_async_cb)(uv_async_t* handle, int status);
   typedef void (*uv_prepare_cb)(uv_prepare_t* handle, int status);
   typedef void (*uv_check_cb)(uv_check_t* handle, int status);
   typedef void (*uv_idle_cb)(uv_idle_t* handle, int status);
   typedef void (*uv_getaddrinfo_cb)(uv_getaddrinfo_t* handle, int status,
       struct addrinfo* res);
   typedef void (*uv_exit_cb)(uv_process_t*, int exit_status, int term_signal);
   typedef void (*uv_fs_cb)(uv_fs_t* req);
   typedef void (*uv_work_cb)(uv_work_t* req);
   typedef void (*uv_after_work_cb)(uv_work_t* req);

   typedef void (*uv_fs_event_cb)(uv_fs_event_t* handle, const char* filename,
       int events, int status);

   size_t uv_handle_size(uv_handle_type type);
   size_t uv_req_size(uv_req_type type);

   uv_loop_t* uv_loop_new(void);
   void uv_loop_delete(uv_loop_t*);
   uv_loop_t* uv_default_loop(void);
   int uv_run(uv_loop_t*);
   int uv_run_once(uv_loop_t*);

   void uv_ref(uv_handle_t*);
   void uv_unref(uv_handle_t*);

   void uv_update_time(uv_loop_t*);
   int64_t uv_now(uv_loop_t*);

   typedef enum {
     UV_LEAVE_GROUP = 0,
     UV_JOIN_GROUP
   } uv_membership;

   struct uv_err_s {
     uv_err_code code;
     int sys_errno_;
   };

   uv_err_t uv_last_error(uv_loop_t*);
   const char* uv_strerror(uv_err_t err);
   const char* uv_err_name(uv_err_t err);

   int uv_shutdown(uv_shutdown_t* req, uv_stream_t* handle,
      uv_shutdown_cb cb);

   int uv_is_active(const uv_handle_t* handle);

   void uv_close(uv_handle_t* handle, uv_close_cb close_cb);

   uv_buf_t uv_buf_init(char* base, size_t len);
   size_t uv_strlcpy(char* dst, const char* src, size_t size);
   size_t uv_strlcat(char* dst, const char* src, size_t size);

   int uv_listen(uv_stream_t* stream, int backlog, uv_connection_cb cb);
   int uv_accept(uv_stream_t* server, uv_stream_t* client);

   int uv_read_start(uv_stream_t*, uv_alloc_cb alloc_cb,
      uv_read_cb read_cb);
   int uv_read_stop(uv_stream_t*);
   int uv_read2_start(uv_stream_t*, uv_alloc_cb alloc_cb,
      uv_read2_cb read_cb);

   int uv_write(uv_write_t* req, uv_stream_t* handle,
       uv_buf_t bufs[], int bufcnt, uv_write_cb cb);
   int uv_write2(uv_write_t* req, uv_stream_t* handle, uv_buf_t bufs[],
       int bufcnt, uv_stream_t* send_handle, uv_write_cb cb);

   int uv_is_readable(const uv_stream_t* handle);
   int uv_is_writable(const uv_stream_t* handle);

   int uv_is_closing(const uv_handle_t* handle);
   int uv_tcp_init(uv_loop_t*, uv_tcp_t* handle);
   int uv_tcp_nodelay(uv_tcp_t* handle, int enable);
   int uv_tcp_keepalive(uv_tcp_t* handle, int enable,
      unsigned int delay);

   int uv_tcp_bind(uv_tcp_t* handle, struct sockaddr_in);
   int uv_tcp_bind6(uv_tcp_t* handle, struct sockaddr_in6);
   int uv_tcp_getsockname(uv_tcp_t* handle, struct sockaddr* name,
       int* namelen);
   int uv_tcp_getpeername(uv_tcp_t* handle, struct sockaddr* name,
       int* namelen);

   int uv_tcp_connect(uv_connect_t* req, uv_tcp_t* handle,
       struct sockaddr_in address, uv_connect_cb cb);
   int uv_tcp_connect6(uv_connect_t* req, uv_tcp_t* handle,
       struct sockaddr_in6 address, uv_connect_cb cb);


   typedef void (*uv_udp_send_cb)(uv_udp_send_t* req, int status);
   typedef void (*uv_udp_recv_cb)(uv_udp_t* handle, ssize_t nread, uv_buf_t buf,
       struct sockaddr* addr, unsigned flags);

   int uv_udp_init(uv_loop_t*, uv_udp_t* handle);
   int uv_udp_bind(uv_udp_t* handle, struct sockaddr_in addr,
       unsigned flags);
   int uv_udp_bind6(uv_udp_t* handle, struct sockaddr_in6 addr,
       unsigned flags);
   int uv_udp_getsockname(uv_udp_t* handle, struct sockaddr* name,
       int* namelen);
   int uv_udp_set_membership(uv_udp_t* handle,
       const char* multicast_addr, const char* interface_addr,
       uv_membership membership);
   int uv_udp_set_multicast_loop(uv_udp_t* handle, int on);
   int uv_udp_set_multicast_ttl(uv_udp_t* handle, int ttl);
   int uv_udp_set_broadcast(uv_udp_t* handle, int on);
   int uv_udp_set_ttl(uv_udp_t* handle, int ttl);
   int uv_udp_send(uv_udp_send_t* req, uv_udp_t* handle,
       uv_buf_t bufs[], int bufcnt, struct sockaddr_in addr,
       uv_udp_send_cb send_cb);
   int uv_udp_send6(uv_udp_send_t* req, uv_udp_t* handle,
       uv_buf_t bufs[], int bufcnt, struct sockaddr_in6 addr,
       uv_udp_send_cb send_cb);
   int uv_udp_recv_start(uv_udp_t* handle, uv_alloc_cb alloc_cb,
       uv_udp_recv_cb recv_cb);
   int uv_udp_recv_stop(uv_udp_t* handle);

   int uv_tty_init(uv_loop_t*, uv_tty_t*, uv_file fd, int readable);
   int uv_tty_set_mode(uv_tty_t*, int mode);
   void uv_tty_reset_mode(void);
   int uv_tty_get_winsize(uv_tty_t*, int* width, int* height);

   uv_handle_type uv_guess_handle(uv_file file);

   int uv_pipe_init(uv_loop_t*, uv_pipe_t* handle, int ipc);
   void uv_pipe_open(uv_pipe_t*, uv_file file);
   int uv_pipe_bind(uv_pipe_t* handle, const char* name);
   void uv_pipe_connect(uv_connect_t* req, uv_pipe_t* handle,
       const char* name, uv_connect_cb cb);

   int uv_poll_init(uv_loop_t* loop, uv_poll_t* handle, int fd);
   int uv_poll_init_socket(uv_loop_t* loop, uv_poll_t* handle,
       uv_os_sock_t socket);

   int uv_poll_start(uv_poll_t* handle, int events, uv_poll_cb cb);
   int uv_poll_stop(uv_poll_t* handle);

   int uv_prepare_init(uv_loop_t*, uv_prepare_t* prepare);
   int uv_prepare_start(uv_prepare_t* prepare, uv_prepare_cb cb);
   int uv_prepare_stop(uv_prepare_t* prepare);

   int uv_check_init(uv_loop_t*, uv_check_t* check);
   int uv_check_start(uv_check_t* check, uv_check_cb cb);
   int uv_check_stop(uv_check_t* check);

   int uv_idle_init(uv_loop_t*, uv_idle_t* idle);
   int uv_idle_start(uv_idle_t* idle, uv_idle_cb cb);
   int uv_idle_stop(uv_idle_t* idle);

   int uv_async_init(uv_loop_t*, uv_async_t* async,
       uv_async_cb async_cb);
   int uv_async_send(uv_async_t* async);

   int uv_timer_init(uv_loop_t*, uv_timer_t* timer);
   int uv_timer_start(uv_timer_t* timer, uv_timer_cb cb,
       int64_t timeout, int64_t repeat);
   int uv_timer_stop(uv_timer_t* timer);
   int uv_timer_again(uv_timer_t* timer);
   void uv_timer_set_repeat(uv_timer_t* timer, int64_t repeat);
   int64_t uv_timer_get_repeat(uv_timer_t* timer);

   struct ares_channeldata;
   typedef struct ares_channeldata *ares_channel;
   int uv_ares_init_options(uv_loop_t*,
       ares_channel *channelptr, struct ares_options *options, int optmask);
   void uv_ares_destroy(uv_loop_t*, ares_channel channel);

   int uv_getaddrinfo(uv_loop_t*, uv_getaddrinfo_t* handle,
       uv_getaddrinfo_cb getaddrinfo_cb, const char* node, const char* service,
       const struct addrinfo* hints);
   void uv_freeaddrinfo(struct addrinfo* ai);

   typedef ${gid_type} uv_gid_t;
   typedef ${uid_type} uv_uid_t;

   typedef struct uv_process_options_s {
     uv_exit_cb exit_cb;
     const char* file;
     char** args;
     char** env;
     char* cwd;
     unsigned int flags;
     uv_uid_t uid;
     uv_gid_t gid;
     uv_pipe_t* stdin_stream;
     uv_pipe_t* stdout_stream;
     uv_pipe_t* stderr_stream;
   } uv_process_options_t;

   int uv_spawn(uv_loop_t*, uv_process_t*,
       uv_process_options_t options);
   int uv_process_kill(uv_process_t*, int signum);
   uv_err_t uv_kill(int pid, int signum);

   int uv_queue_work(uv_loop_t* loop, uv_work_t* req,
       uv_work_cb work_cb, uv_after_work_cb after_work_cb);

   char** uv_setup_args(int argc, char** argv);

   uv_err_t uv_get_process_title(char* buffer, size_t size);
   uv_err_t uv_set_process_title(const char* title);
   uv_err_t uv_resident_set_memory(size_t* rss);
   uv_err_t uv_uptime(double* uptime);

   uv_err_t uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count);
   void uv_free_cpu_info(uv_cpu_info_t* cpu_infos, int count);

   uv_err_t uv_interface_addresses(uv_interface_address_t** addresses,
     int* count);
   void uv_free_interface_addresses(uv_interface_address_t* addresses,
     int count);

   void uv_fs_req_cleanup(uv_fs_t* req);

   int uv_fs_close(uv_loop_t* loop, uv_fs_t* req, uv_file file,
       uv_fs_cb cb);

   int uv_fs_open(uv_loop_t* loop, uv_fs_t* req, const char* path,
       int flags, int mode, uv_fs_cb cb);

   int uv_fs_read(uv_loop_t* loop, uv_fs_t* req, uv_file file,
       void* buf, size_t length, int64_t offset, uv_fs_cb cb);

   int uv_fs_unlink(uv_loop_t* loop, uv_fs_t* req, const char* path,
       uv_fs_cb cb);

   int uv_fs_write(uv_loop_t* loop, uv_fs_t* req, uv_file file,
       void* buf, size_t length, int64_t offset, uv_fs_cb cb);

   int uv_fs_mkdir(uv_loop_t* loop, uv_fs_t* req, const char* path,
       int mode, uv_fs_cb cb);

   int uv_fs_rmdir(uv_loop_t* loop, uv_fs_t* req, const char* path,
       uv_fs_cb cb);

   int uv_fs_readdir(uv_loop_t* loop, uv_fs_t* req,
       const char* path, int flags, uv_fs_cb cb);

   int uv_fs_stat(uv_loop_t* loop, uv_fs_t* req, const char* path,
       uv_fs_cb cb);

   int uv_fs_fstat(uv_loop_t* loop, uv_fs_t* req, uv_file file,
       uv_fs_cb cb);

   int uv_fs_rename(uv_loop_t* loop, uv_fs_t* req, const char* path,
       const char* new_path, uv_fs_cb cb);

   int uv_fs_fsync(uv_loop_t* loop, uv_fs_t* req, uv_file file,
       uv_fs_cb cb);

   int uv_fs_fdatasync(uv_loop_t* loop, uv_fs_t* req, uv_file file,
       uv_fs_cb cb);

   int uv_fs_ftruncate(uv_loop_t* loop, uv_fs_t* req, uv_file file,
       int64_t offset, uv_fs_cb cb);

   int uv_fs_sendfile(uv_loop_t* loop, uv_fs_t* req, uv_file out_fd,
       uv_file in_fd, int64_t in_offset, size_t length, uv_fs_cb cb);

   int uv_fs_chmod(uv_loop_t* loop, uv_fs_t* req, const char* path,
       int mode, uv_fs_cb cb);

   int uv_fs_utime(uv_loop_t* loop, uv_fs_t* req, const char* path,
       double atime, double mtime, uv_fs_cb cb);

   int uv_fs_futime(uv_loop_t* loop, uv_fs_t* req, uv_file file,
       double atime, double mtime, uv_fs_cb cb);

   int uv_fs_lstat(uv_loop_t* loop, uv_fs_t* req, const char* path,
       uv_fs_cb cb);

   int uv_fs_link(uv_loop_t* loop, uv_fs_t* req, const char* path,
       const char* new_path, uv_fs_cb cb);

   int uv_fs_symlink(uv_loop_t* loop, uv_fs_t* req, const char* path,
       const char* new_path, int flags, uv_fs_cb cb);

   int uv_fs_readlink(uv_loop_t* loop, uv_fs_t* req, const char* path,
       uv_fs_cb cb);

   int uv_fs_fchmod(uv_loop_t* loop, uv_fs_t* req, uv_file file,
       int mode, uv_fs_cb cb);

   int uv_fs_chown(uv_loop_t* loop, uv_fs_t* req, const char* path,
       int uid, int gid, uv_fs_cb cb);

   int uv_fs_fchown(uv_loop_t* loop, uv_fs_t* req, uv_file file,
       int uid, int gid, uv_fs_cb cb);

   void uv_loadavg(double avg[3]);

   int uv_fs_event_init(uv_loop_t* loop, uv_fs_event_t* handle,
       const char* filename, uv_fs_event_cb cb, int flags);

   struct sockaddr_in uv_ip4_addr(const char* ip, int port);
   struct sockaddr_in6 uv_ip6_addr(const char* ip, int port);

   int uv_ip4_name(struct sockaddr_in* src, char* dst, size_t size);
   int uv_ip6_name(struct sockaddr_in6* src, char* dst, size_t size);

   int uv_exepath(char* buffer, size_t* size);

   uv_err_t uv_cwd(char* buffer, size_t size);
   uv_err_t uv_chdir(const char* dir);

   uint64_t uv_get_free_memory(void);
   uint64_t uv_get_total_memory(void);

   extern uint64_t uv_hrtime(void);
""")

our sys  = ffi#C
our LOOP = sys#uv_default_loop()

var handle_type = {
   ['uv_async_t']       = sys#UV_ASYNC,
   ['uv_check_t']       = sys#UV_CHECK,
   ['uv_fs_event_t']    = sys#UV_FS_EVENT,
   ['uv_fs_idle_t']     = sys#UV_IDLE,
   ['uv_pipe_t']        = sys#UV_NAMED_PIPE,
   ['uv_poll_t']        = sys#UV_POLL,
   ['uv_prepare_t']     = sys#UV_PREPARE,
   ['uv_process_t']     = sys#UV_PROCESS,
   ['uv_tcp_t']         = sys#UV_TCP,
   ['uv_timer_t']       = sys#UV_TIMER,
   ['uv_tty_t']         = sys#UV_TTY,
   ['uv_udp_t']         = sys#UV_UDP,
   ['uv_ares_task_t']   = sys#UV_ARES_TASK,
   ['uv_file']          = sys#UV_FILE,
}

var req_type = {
   ['uv_connect_t']     = sys#UV_CONNECT,
   ['uv_write_t']       = sys#UV_WRITE,
   ['uv_shutdown_t']    = sys#UV_SHUTDOWN,
   ['uv_udp_send_t']    = sys#UV_UDP_SEND,
   ['uv_fs_t']          = sys#UV_FS,
   ['uv_work_t']        = sys#UV_WORK,
   ['uv_getaddrinfo_t'] = sys#UV_GETADDRINFO,
}

function handle_size(name) {
   sys#uv_handle_size(handle_type[name])
}
function req_size(name) {
   sys#uv_req_size(req_type[name])
}
function mk_handle(name) {
   ffi#gc(ffi#cast(name+'*',sys#malloc(handle_size(name))), sys#free)
}
function mk_req(name) {
   ffi#gc(ffi#cast(name+'*',sys#malloc(req_size(name))), sys#free)
}

var NREF = 0

class Timer {
   has delay = 0

   var ROUSE = { }
   var TI_CB = ffi#cast('uv_timer_cb', function(req) {
      var key = tostring(req)
      if ROUSE[key] {
         ROUSE[key](req)
         ROUSE[key] = nil
      }
   })

   method init(delay = 0, repeat = 0) {
      self.delay  = delay
      self.repeat = repeat
   }

   method start {
      var curr = Fiber.self
      var key  = tostring(ffi#cast('uv_timer_t *', .handle))
      ROUSE[key] = function(req) { curr.ready }
      sys#uv_timer_start(.handle, TI_CB, .delay, .repeat)
      curr.suspend
      if .repeat == 0 { self.cancel }
   }
   method handle {
      if rawget(self,'_handle') {
         return self#_handle
      }
      self#_handle = mk_handle('uv_timer_t')
      sys#uv_timer_init(LOOP, self#_handle)
      NREF += 1
      self#_handle
   }
   method handle=(val) {
      if rawget(self,'_handle') {
         sys#uv_close(ffi#cast('uv_handle_t *', self#_handle), nil)
         NREF -= 1
      }
      self#_handle = val
   }
   method cancel {
      self.handle = nil
   }
   method stop {
      sys#uv_timer_stop(.handle)
   }
   method again {
      sys#uv_timer_again(.handle)
   }
   method repeat=(val) {
      sys#uv_timer_set_repeat(.handle, val)
   }
   method repeat {
      tonumber(sys#uv_timer_get_repeat(.handle))
   }
}

class Fiber {
   has on_cleanup = [ ]

   var READY = [ ]
   method init(body, ...args) {
      self#state = coroutine#create(function() { body(...args) })
   }   

   var MAIN       = setmetatable({ }, Fiber)
   MAIN#terminate = function(self) { }
   MAIN#suspend   = function(self) { Fiber.dispatch }
   MAIN#join      = function(self) { Fiber.dispatch }

   var current
   static method self() {
      return current || MAIN
   }

   static method yield() {
      if coroutine#running() {
         coroutine#yield()
      }
      else {
         self.dispatch()
      }
   }
   static method dispatch() {
      while true {
         var n = READY.len
         if n === 0 {
            while NREF > 0 && READY.len === 0 {
               sys#uv_run_once(LOOP)
            }
            n = READY.len
            if n === 0 { break }
         }
         for i=1, n {
            current = READY[i]
            if current === MAIN {
               current = nil
               READY.remove(i)
               break
            }
            var co = current#state
            var ok, rv = coroutine#resume(co)
            current = nil
            if ok {
               if rv === 'suspend' || coroutine#status(co) === 'dead' {
                  READY.remove(i)
                  break
               }
            }
            else {
               throw rv
            }
         }
      }
   }
   static method run(func) {
      var fiber = self.new(func)
      fiber.ready
      fiber
   }

   static method sleep(delay) {
      Timer.new(delay, 0).start
   }

   method ready() {
      READY.push(self)
      self
   }

   method suspend() {
      coroutine#yield("suspend")
      self
   }

   method terminate() {
      self.on_cleanup each => { _(self) }
   }

   method join() {
      var curr = Fiber.self
      self.on_cleanup push => { curr.ready() }
      curr.suspend()
   }

   method status() {
      return coroutine#status(self#state)
   }
}

class Semaphore {
   method init(count = 1) {
      self#_count = count
      self#_wait  = [ ]
   }
   method up {
      self#_count += 1
      if self#_count > 0 && self#_wait.len > 0 {
         self#_wait.shift.ready
      }
   }
   method down {
      while self#_count < 1 {
         var curr = Fiber.self
         var seen
         for i=1, self#_wait.len {
            if self#_wait[i] == curr {
               seen = true
               break
            }
         }
         if !seen { self#_wait.push(curr) }
         curr.suspend
      }
      self#_count -= 1
   }
}

class Channel {
   method init(size = math#huge) {
      self#_data = [ ]
      self#_sget = Semaphore.new(0)
      self#_sput = Semaphore.new(size)
   }
   method put(val) {
      self#_sput.down
      self#_data.push(val)
      self#_sget.up
   }
   method get() {
      self#_sget.down
      self#_sput.up
      self#_data.shift
   }
}

class File {
   has fd
   has ofs = 0

   our O_RDONLY   = 0x0000
   our O_WRONLY   = 0x0001
   our O_RDWR     = 0x0002
   our O_ACCMODE  = 0x0003
   our O_NONBLOCK = 0x0004
   our O_APPEND   = 0x0008
   our O_CREAT    = 0x0200
   our O_TRUNC    = 0x0400
   our O_EXCL     = 0x0800

   var FLAGS = {
      ["r"]  = O_RDONLY,
      ["r+"] = O_RDWR,
      ["w"]  = O_CREAT  | O_TRUNC | O_WRONLY,
      ["w+"] = O_CREAT  | O_TRUNC | O_RDWR,
      ["a"]  = O_APPEND | O_CREAT | O_WRONLY,
      ["a+"] = O_APPEND | O_CREAT | O_RDWR,
   }

   static method open(path, how, mode) {
      var req  = mk_req('uv_fs_t')
      var file = self.new()
      file.fd = sys#uv_fs_open(LOOP, req, path, FLAGS[how], mode, nil)
      NREF += 1
      return file
   }

   var ROUSE = { }
   var FS_CB = ffi#cast('uv_fs_cb', function(req) {
      var key = tostring(req)
      if ROUSE[key] {
         ROUSE[key](req)
         ROUSE[key] = nil
      }
   })
   method write(str : String, ofs : Number = 0) {
      var req = mk_req('uv_fs_t')
      var buf = ffi#cast('void *', str)
      var curr = Fiber.self
      var key  = tostring(req)
      ROUSE[key] = function(req) {
         sys#uv_fs_req_cleanup(req)
         curr.ready
      }
      sys#uv_fs_write(LOOP, req, .fd, buf, str.len, ofs, FS_CB)
      curr.suspend
   }
   method close() {
      var req = mk_req('uv_fs_t')
      var curr = Fiber.self
      var key  = tostring(req)
      ROUSE[key] = function(req) {
         sys#uv_fs_req_cleanup(req)
         NREF -= 1
         curr.ready
      }
      sys#uv_fs_close(LOOP, req, .fd, FS_CB)
      curr.suspend
   }
}

