export Stat

import FFI from std.system

require('std.time')

if FFI::OS === 'OSX' {
   FFI::CDEF << """
      typedef struct Stat {
         int32_t       st_dev;
         uint32_t      st_ino;
         mode_t        st_mode;
         nlink_t       st_nlink;
         uid_t         st_uid;
         gid_t         st_gid;
         int32_t       st_rdev;
         timespec_t    st_atimespec;
         timespec_t    st_mtimespec;
         timespec_t    st_ctimespec;
         off_t         st_size;
         long          st_blocks;
         unsigned long st_blksize;
         unsigned long st_flags;
         unsigned long st_gen;
      } stat_t;
      int fstat(int, stat_t *);
      int lstat(const char *, stat_t *);
      int stat(const char *, stat_t *);
   """
}
else if FFI::OS === 'Linux' {
   if FFI::ARCH === 'x86' {
      FFI::CDEF << """
         static const int STAT_VER = 1;
         typedef struct Stat {
           unsigned long  st_dev;
           unsigned long  st_ino;
           unsigned short st_mode;
           unsigned short st_nlink;
           unsigned short st_uid;
           unsigned short st_gid;
           unsigned long  st_rdev;
           unsigned long  st_size;
           unsigned long  st_blksize;
           unsigned long  st_blocks;
           timespec_t     st_atimespec;
           timespec_t     st_mtimespec;
           timespec_t     st_ctimespec;
           unsigned long  __unused4;
           unsigned long  __unused5;
         } stat_t;
      """
   }
   else if FFI::ARCH === 'x64' {
      FFI::CDEF << """
         static const int STAT_VER = 1;
         typedef struct Stat {
           unsigned long   st_dev;
           unsigned long   st_ino;
           unsigned long   st_nlink;
           unsigned int    st_mode;
           unsigned int    st_uid;
           unsigned int    st_gid;
           unsigned int    __pad0;
           unsigned long   st_rdev;
           long            st_size;
           long            st_blksize;
           long            st_blocks;
           timespec_t      st_atimespec;
           timespec_t      st_mtimespec;
           timespec_t      st_ctimespec;
           long            __unused[3];
         } stat_t;
      """ 
   }
   else if FFI::ARCH === 'arm' {
      if FFI.abi("le") {
         FFI::CDEF << """
            typedef struct Stat {
              unsigned long  st_dev;
              unsigned long  st_ino;
              unsigned short st_mode;
              unsigned short st_nlink;
              unsigned short st_uid;
              unsigned short st_gid;
              unsigned long  st_rdev;
              unsigned long  st_size;
              unsigned long  st_blksize;
              unsigned long  st_blocks;
              timespec_t     st_atimespec;
              timespec_t     st_mtimespec;
              timespec_t     st_ctimespec;
              unsigned long  st_ctime_nsec;
              unsigned long  __unused4;
              unsigned long  __unused5;
            } stat_t;
         """
      }
      else {
         FFI::CDEF << """
            struct Stat {
              unsigned long  st_dev;
              unsigned short __pad1;
              unsigned long  st_ino;
              unsigned short st_mode;
              unsigned short st_nlink;
              unsigned short st_uid;
              unsigned short st_gid;
              unsigned long  st_rdev;
              unsigned short __pad2;
              unsigned long  st_size;
              unsigned long  st_blksize;
              unsigned long  st_blocks;
              timespec_t     st_atimespec;
              timespec_t     st_mtimespec;
              timespec_t     st_ctimespec;
              unsigned long  __unused4;
              unsigned long  __unused5;
            } stat_t;
         """
      }
   }
   FFI::CDEF << """
      int __xlstat(int, const char *, stat_t *);
      int __xfstat(int, const char *, stat_t *);
      int __xstat(int, const char *, stat_t *);
   """
}
else {
   throw "NYI: ${FFI::OS} supported"
}

class Stat with FFI::MetaType['stat_t'] {
   var C = FFI::C

   var STAT_IMPL
   if FFI::OS === 'Linux' {
      STAT_IMPL = function(path, stat) {
         C#__xstat(C#STAT_VER, path, stat)
      }
   }
   else {
      STAT_IMPL = function(path, stat) {
         C#stat(path, stat)
      }
   }

   static method stat(path) {
      var inst = self.new(path)
      var retv = STAT_IMPL(path, inst)
      if retv !== 0 {
         error(FFI.strerror(retv), 2)
      }
      return inst
   }
   static method new(path : String = '.') {
      var stat = FFI.cast('stat_t *', C#malloc(FFI.sizeof('stat_t')))
      return stat
   }

   self#__gc = C#free

   method size { self#st_size }
   method mode { self#st_mode }

   method atime { self#st_atimespec#tv_sec }
   method mtime { self#st_mtimespec#tv_sec }
   method ctime { self#st_ctimespec#tv_sec }

   method uid { self#st_uid }
   method gid { self#st_gid }
}


