import FFI     from std.system
import TimeVal from std.time

export SockAddr, Socket, TCP, SOCK, AF, PROTO, SocketError, AcceptError

FFI cdef """
   typedef uint16_t in_port_t;
   typedef uint32_t socklen_t;
   typedef unsigned short int sa_family_t;

   typedef struct SockAddr {
     sa_family_t sa_family;
     char        sa_data[14];
   } SockAddr;

   typedef struct INET_Addr {
     uint32_t       s_addr;
   } INET_Addr;

   typedef struct INET6_Addr {
     unsigned char  s6_addr[16];
   } INET6_Addr;

   typedef struct SockAddr_INET {
     sa_family_t    sin_family;
     in_port_t      sin_port;
     INET_Addr      sin_addr;
     unsigned char  sin_zero[8]; /* padding, should not vary by arch */
   } SockAddr_INET;

   typedef struct SockAddr_INET6 {
     sa_family_t    sin6_family;
     in_port_t      sin6_port;
     uint32_t       sin6_flowinfo;
     INET6_Addr     sin6_addr;
     uint32_t       sin6_scope_id;
   } SockAddr_INET6;

   typedef struct SockAddr_UNIX {
     sa_family_t sun_family;
     char        sun_path[108];
   } SockAddr_UNIX;

   typedef struct Socket {
      int        so_fd;
      SockAddr *so_addr;
   } Socket;

   int socket(int domain, int type, int protocol);
   int socketpair(int domain, int type, int protocol, int sv[2]);
   int bind(int sockfd, SockAddr *addr, socklen_t addrlen);
   int listen(int sockfd, int backlog);
   int connect(int sockfd, SockAddr *addr, socklen_t addrlen);
   int accept(int sockfd, SockAddr *addr, socklen_t *addrlen);
   int accept4(int sockfd, SockAddr *addr, socklen_t *addrlen, int flags);
   int getsockname(int sockfd, SockAddr *addr, socklen_t *addrlen);
   int getpeername(int sockfd, SockAddr *addr, socklen_t *addrlen);
   int shutdown(int sockfd, int how);

   typedef struct FDSet {
      int32_t fds_bits[32];
   } fd_set;

   int select(int nfds, fd_set *rfds, fd_set *wfds, fd_set *efds,
      timeval_t *timeout);

   typedef struct HostEnt {
      char    *h_name;        /* official name of host */
      char    **h_aliases;    /* alias list */
      int     h_addrtype;     /* host address type */
      int     h_length;       /* length of address */
      char    **h_addr_list;  /* list of addresses from name server */
   } HostEnt;

   HostEnt * gethostbyname(const char *name);

   int inet_aton(const char *cp, INET_Addr *pin);
   char * inet_ntoa(INET_Addr in);

   ssize_t read(int fildes, void *buf, size_t nbyte);
   ssize_t write(int fildes, const void *buf, size_t nbyte);

   /* FIXME: on BE arch this is a null macro */
   uint16_t htons(uint16_t hostshort);

   void bzero(void *s, size_t n);
   int fcntl(int fd, int cmd, ...);

   int getsockopt(int socket, int level, int option_name,
      void *option_value, socklen_t *option_len);

    int setsockopt(int socket, int level, int option_name,
      const void *option_value, socklen_t option_len);
"""

enum SOCK {
   STREAM    = 1,
   DGRAM     = 2,
   RAW       = 3,
   RDM       = 4,
   SEQPACKET = 5,
   DCCP      = 6,
   PACKET    = 10,

   CLOEXEC   = 02000000,
   NONBLOCK  = 04000,
}

enum AF {
   UNSPEC     = 0,
   LOCAL      = 1,
   UNIX       = 1, // AF_LOCAL
   FILE       = 1, // AF_LOCAL
   INET       = 2,
   AX25       = 3,
   IPX        = 4,
   APPLETALK  = 5,
   NETROM     = 6,
   BRIDGE     = 7,
   ATMPVC     = 8,
   X25        = 9,
   INET6      = 10,
   ROSE       = 11,
   DECnet     = 12,
   NETBEUI    = 13,
   SECURITY   = 14,
   KEY        = 15,
   NETLINK    = 16,
   ROUTE      = 16, // AF_NETLINK
   PACKET     = 17,
   ASH        = 18,
   ECONET     = 19,
   ATMSVC     = 20,
   RDS        = 21,
   SNA        = 22,
   IRDA       = 23,
   PPPOX      = 24,
   WANPIPE    = 25,
   LLC        = 26,
   CAN        = 29,
   TIPC       = 30,
   BLUETOOTH  = 31,
   IUCV       = 32,
   RXRPC      = 33,
   ISDN       = 34,
   PHONET     = 35,
   IEEE802154 = 36,
   CAIF       = 37,
   ALG        = 38,
   MAX        = 39,
}

enum PROTO {
   TCP = 6,
   UDP = 17,
}

// a few fcntl flags
enum FLAGS {
   F_GETFD = 1,
   F_SETFD = 2,
   F_GETFL = 3L,
   F_SETFL = 4L,
   O_NONBLOCK = 0x0004,
   O_APPEND   = 0x0008,
}

our SO
our SOL_SOCKET

if FFI::OS == 'Linux' {
   SOL_SOCKET = 1
   enum SO {
      REUSEADDR = 2,
      DONTROUTE = 5,
      BROADCAST = 6,
      KEEPALIVE = 9,
   }
}
else if FFI::OS == 'OSX' {
   SOL_SOCKET = 0xffff
   enum SO {
      REUSEADDR = 0x0004,
      KEEPALIVE = 0x0008,
      DONTROUTE = 0x0010,
      BROADCAST = 0x0020,
   }
}

class SockAddr with FFI::MetaType['SockAddr'] {
   var C = FFI::C

   method family { self::sa_family }
   method family=(f : AF) { self::sa_family = f }

   method data { self::sa_data }
   method data=(d) { self::sa_data = d }

   method len {
      switch self.family {
         case AF.INET:
            return FFI.sizeof('SockAddr_INET')
         case AF.UNIX:
            return FFI.sizeof('SockAddr_UNIX')
         case AF.INET6:
            return FFI.sizeof('SockAddr_INET6')
         default:
            throw "unkown address family ${self.family}"
      }
   }

   static method __coerce(that) {
      if that does SockAddr::Common {
         var v = FFI.cast('SockAddr*', FFI.cast('void*', that))
         return v
      }
      throw TypeError.new("cannot coerce ${that} to ${self}")
   }

   trait Common {
      method len { FFI.sizeof(self) }
      static method __coerce(that : SockAddr) {
         return FFI.cast(self, that)
      }
   }

   class INET with FFI::MetaType['SockAddr_INET'], Common {
      var C = FFI::C

      method family { self::sin_family }
      method family=(f : AF) { self::sin_family = f }

      method init(host, port) {
         self::sin_family = AF.INET
         if port {
            self::sin_port = C::htons(port)
         }
         if host {
            self::sin_addr = SockAddr::INET::Addr.new(host)
         }
      }
      class Addr with FFI::MetaType['INET_Addr'] {
         method init(host) {
            if host is String {
               var stat = Socket.inet_aton(host, self)
               if stat != 1 {
                  Error raise FFI.strerror(FFI.errno)
               }
            }
            else if host is int32 {
               self::s_addr = host
            }
            else {
               TypeError raise "host ${host} not valid"
            }
         }
      }
   }
   class UNIX with FFI::MetaType['SockAddr_UNIX'], Common {
   }
   class INET6 with FFI::MetaType['SockAddr_INET6'], Common {
      class Addr with FFI::MetaType['INET6_Addr'] {

      }
   }
}

class FDSet with FFI::MetaType['fd_set'] {

   var NFDBITS     = 32
   var NFD_SETSIZE = 1024 // TODO: allow unlimited

   method insert(fd) {
      var word = fd / NFDBITS
      var mask = 1 << (fd % NFDBITS)
      self::fds_bits::[word] |= mask // TODO: check and realloc
   }
   method remove(fd) {
      var word = fd / NFDBITS
      var mask = 1 << (fd % NFDBITS)
      self::fds_bits::[word] &= ~mask
   }
   method contains(fd) {
      var word = fd / NFDBITS
      var mask = 1 << (fd % NFDBITS)
      self::fds_bits::[word] & mask
   }
   method clear {
      FFI::C::bzero(self::fds_bits, NFD_SETSIZE / 8)
   }
}

class Socket with FFI::MetaType['Socket'] {
   var C = FFI::C

   method init(domain : AF, type : SOCK, proto : PROTO) {
      var fd = C::socket(domain, type, proto)
      if fd == -1 { return nil, FFI.strerror(FFI.errno) }
      self::so_fd   = fd
      self::so_addr = nil
   }

   method flags {
      var flags = C::fcntl(self::so_fd, FLAGS.F_GETFL)
      if flags < 0 { SocketError raise FFI.strerror(FFI.errno) }
      return flags
   }
   method flags=(val : int32) {
      var stat = C::fcntl(self::so_fd, FLAGS.F_SETFL, val)
      if stat == -1 { SocketError raise FFI.strerror(FFI.errno) }
      return stat
   }
   method setoption(key : SO, val) {
      var len = FFI.sizeof(val)
      var val = FFI.cast('char *', FFI.new('int[1]', val))
      print("key:", key, "val:", val::[0], "len:", len)
      C::setsockopt(self::so_fd, SOL_SOCKET, key, val, len)
   }
   method reuseAddr(val) {
      if val {
         var v = FFI.cast('char *', FFI.new('int[1]', 1))
         var r = C::setsockopt(self::so_fd, SOL_SOCKET, SO.REUSEADDR, v, FFI.sizeof(v))
         if r == -1 { SocketError raise FFI.strerror(FFI.errno) }
         return r
      }
      else {
         var v = FFI.cast('char *', FFI.new('int[1]', 0))
         var r = C::setsockopt(self::so_fd, SOL_SOCKET, SO.REUSEADDR, v, FFI.sizeof(v))
         if r == -1 { SocketError raise FFI.strerror(FFI.errno) }
         return r
      }
   }


   method nonblocking=(val) {
      if val {
         .flags |= FLAGS.O_NONBLOCK
      }
      else {
         .flags &= ~FLAGS.O_NONBLOCK
      }
   }
   method nonblocking {
      .flags & FLAGS.O_NONBLOCK
   }
   method bind(addr : SockAddr) {
      var stat = C::bind(self::so_fd, addr, addr.len)
      if stat == -1 { SocketError raise FFI.strerror(FFI.errno) }
      self::so_addr = addr
      return stat
   }
   method connect(addr : SockAddr) {
      var stat = C::connect(self::so_fd, addr, addr.len)
      if stat == -1 { SocketError raise FFI.strerror(FFI.errno) }
      self::so_addr = addr
   }
   method listen(backlog = 16) {
      C::listen(self::so_fd, backlog)
   }

   method accept {
      var cli_addr     = FFI.new('SockAddr')
      cli_addr.family  = self::so_addr.family

      var cli_addr_len = FFI.new('socklen_t[1]', self::so_addr.len)
      var so_fd = C::accept(self::so_fd, cli_addr, cli_addr_len)

      if so_fd == -1 {
         AcceptError raise FFI.strerror(FFI.errno)
      }
      var sock = FFI.new('Socket')

      sock::so_fd   = so_fd
      sock::so_addr = cli_addr

      return sock
   }

   static method inet_aton(cp : String, pin : SockAddr::INET::Addr) {
      C::inet_aton(cp, pin)
   }
   static method inet_ntoa(n) {
      C::inet_ntoa(n)
   }

   static method select(rfds : FDSet, wfds : FDSet, efds : FDSet, wait : TimeVal) {
      C::select(rfds, wfds, efds, wait)
   }

   class INET from self {
      method init(type : SOCK, proto : PROTO) {
         super.init(AF.INET, type, proto)
      }
   }
}

class Select {
   has handles = [ ]
   has rfds = FDSet.new
   has wfds = FDSet.new
   has efds = FDSet.new
   has nfds = 0

   method init {
      .rfds.clear
      .wfds.clear
      .efds.clear
   }
   method insert(sock : Socket) {
      if .nfds < sock::so_fd {
         .nfds = sock::so_fd
      }
      self.handles.push(sock)
   }
   method remove(sock : Socket) {
      for i, s in self.handles {
         if s == sock {
            if sock::so_fd == .nfds {
               .nfds -= 1
            }
            self.handles.remove(i)
         }
      }
   }
   method can_read(timeout) {
      for i=1, self.handles.len {
         .rfds.insert(self.handles[i]::so_fd)
      }
      if timeout {
         timeout = TimeVal.new(timeout)
      }
      var n = FFI::C::select(.nfds + 1, .rfds, nil, nil, timeout)
      if n > 0 {
         var r = [ ]
         for i=1, self.handles.len {
            if .rfds.contains(self.handles[i]::so_fd) {
               r.push(self.handles[i])
            }
         }
         return r
      }
   }
   method can_write(timeout) {
      var n = FFI::C::select(.nfds + 1, nil, .wfds, nil, timeout)
   }
   method has_exceptions(timeout) {
      var n = FFI::C::select(.nfds + 1, nil, nil, .efds, timeout)
   }
}

class SocketError from Error { }
class AcceptError from SocketError { }

object TCP {
   class Client from Socket::INET {
      var C = FFI::C
      method init {
         super.init(SOCK.STREAM, PROTO.TCP)
      }
      method connect(host, port) {
         var addr = FFI.new('SockAddr_INET')
         var inet = FFI.new('INET_Addr')
         if C::inet_aton(host, inet) == 0 {
            var hostent = C::gethostbyname(host)
            if hostent == nil {
               SocketError raise FFI.strerror(FFI.errno)
            }
            var host = FFI.cast('INET_Addr*', hostent::h_addr_list::[0])
            addr = FFI.new('SockAddr_INET')
            addr::sin_family = AF.INET
            addr::sin_addr = host::[0]
            if port {
               addr::sin_port = C::htons(port)
            }
         }
         else {
            addr = SockAddr::INET.new(host, port)
         }
         super.connect(addr)
      }
      method read(buf, len) {
         C::read(self::so_fd, buf, len)
      }
      method write(buf, len) {
         C::write(self::so_fd, buf, len)
      }
   }
   class Server from Socket::INET {
      method init {
         super.init(SOCK.STREAM, PROTO.TCP)
      }
      method bind(host, port) {
         var addr = SockAddr::INET.new(host, port)
         super.bind(addr)
      }
   }
}

class AddrInfo {
   FFI cdef """
      typedef struct AddrInfo {
         int ai_flags;           /* input flags */
         int ai_family;          /* protocol family for socket */
         int ai_socktype;        /* socket type */
         int ai_protocol;        /* protocol for socket */
         socklen_t ai_addrlen;   /* length of socket-address */
         SockAddr *ai_addr;    /* socket-address for socket */
         char *ai_canonname;     /* canonical name for service location */
         struct AddrInfo *ai_next; /* pointer to next in list */
      } AddrInfo;

      int getaddrinfo(const char *host, const char *port, AddrInfo *hints, AddrInfo **res);
      void freeaddrinfo(AddrInfo *ai);
   """

   with FFI::MetaType['AddrInfo']

   method init(host : String, port : Number, hint : AddrInfo) {
      var info = FFI.new('AddrInfo[1]')
      var retv = FFI::C::getaddrinfo(host, FFI::C::htons(port), hint, info)
      if retv == -1 {
         Error raise FFI.strerror(FFI.errno)
      }
   }
}


