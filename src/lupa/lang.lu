export Compiler, Parser, Context

object ASTUtil {

   function _dump(node, buf, level) {
      var pad  = '  '.rep(level)
      var pad1 = '  '.rep(level - 1)
      if node is Table {
         var pos = node['pos'] && "@${node['pos']}" || ''
         buf.push("<${node['tag']}>${pos} {\n")
         var seen = { }
         var abuf = [ ]
         for i=1, rawlen(node) {
            seen[i] = true
            abuf.push("${pad}[${i}] = ")
            _dump(node::[i], abuf, level + 1)
            abuf.push(",\n")
         }
         for k,v in node {
            if !seen[k] && k != 'tag' && k != 'pos' {
               buf.push("${pad}${k} = ")
               _dump(v, buf, level + 1)
               buf.push(",\n")
            }
         }
         buf.push(abuf.concat())
         buf.push("${pad1}}")
      }
      else if node is Array {
         buf.push("[\n")
         for i=1, rawlen(node) {
            buf.push("${pad}[${i}] = ")
            _dump(node::[i], buf, level + 1)
            buf.push(",\n")
         }
         buf.push("${pad1}]")
      }
      else if type(node) == 'string' {
         buf.push("%q".format(node))
      }
      else {
         buf.push(tostring(node))
      }
   }

   method dump(node) {
      var buf = [ ]
      _dump(node, buf, 1)
      return buf.concat()
   }
}


object Parser {

   function error_line(src, pos) {
      var line = 1
      var index, limit = 1, pos
      while index <= limit {
         var s, e = src.find("\n", index, true)
         if s == nil || e > limit { break }
         index = e + 1
         line  = line + 1
      }
      return line
   }
   function error_near(src, pos) {
      if (src.len < pos + 20) {
         return src.sub(pos)
      }
      else {
         return src.sub(pos, pos + 20)+"..."
      }
   }
   function syntax_error(m) {
      return function(src, pos) {
         var line, near = error_line(src, pos), error_near(src, pos)
         error("SyntaxError: ${m||''} on line ${line} near '${near}'")
      }
   }
   function expect(p,m) {
      if !m { m = p }
      return / p | <{ syntax_error("expected '"+m+"'") }> /
   }

   function quote(c) { return "%q".format(c) }

   var nl      = / "\n" /
   var line_comment = /
      ((!nl %s)* "//" (!nl .)* nl)
   /
   var long_comment = /
      "/*" | (!"*/" .)* "*/"
   /
   var comment = / line_comment | long_comment /
   var idsafe  = / !(%alnum | "_") /
   var s       = / (comment | %s)* /
   var S       = / (comment | %s)+ /
   var hs      = / !nl %s /
   var udigit  = / %digit {~ "_" -> "" ~}? /
   var digits  = / %digit udigit* /
   var word    = / ((%alpha | "_") (%alnum | "_")*) /

   var keyword = / (
      | "var" | "function" | "class" | "with" | "in" | "our"
      | "nil" | "true" | "false" | "return" | "static"
      | "for" | "throw" | "method" | "has" | "from" | "break" | "guard"
      | "switch" | "case" | "default" | "do" | "while" | "needs"
      | "continue" | "import" | "export" | "try" | "catch" | "super"
      | "default" | "finally" | "if" | "else" | "rule" | "enum"
   ) idsafe /

   function make_infix_expr(oper, term) {
      / (term {: hs* {oper} s term :}*) ~> function(a, o, b) {
         return { tag = 'infix_expr', oper = o, a, b }
      } /
   }

   rule script {
      <unit> (!. | <{syntax_error("invalid syntax")}>)
   }
   rule unit {
      { %s* '#!' (!nl .)* %s* }?
      s <main_stmt_list>? s
      -> { tag = 'unit' }
   }

   rule sep {
      long_comment? ("\n" | ";" | &"}" | line_comment) | [\t ] <sep>
   }

   rule decl_stmt {
      | <var_decl>
      | <enum_decl>
      | <func_decl>
      | <class_decl>
      | <trait_decl>
      | <guard_decl>
      | <object_decl>
   }
   rule main_decl_stmt {
      {:pos: %pos :} (
         | <import_decl>
         | <export_decl>
      ) -> { tag = 'stmt' }
   }
   rule body_decl_stmt {
      {:pos: %pos :} (
         | <import_decl>
      ) -> {tag = 'stmt' }
   }
   rule stmt {
      {:pos: %pos :} (
         | <if_stmt>
         | <switch_stmt>
         | <throw_stmt>
         | <break_stmt>
         | <continue_stmt>
         | <for_stmt>
         | <for_in_stmt>
         | <do_while_stmt>
         | <while_stmt>
         | <try_stmt>
         | <decl_stmt>
         | <bind_stmt>
         | <expr_stmt>
         | <block_stmt>
         | <return_stmt>
      ) -> { tag = 'stmt' }
   }
   rule main_stmt {
      | <main_decl_stmt>
      | <stmt>
   }
   rule body_stmt {
      | <body_decl_stmt>
      | &<export_decl> <{ syntax_error("export in nested scope") }>
      | <stmt>
   }
   rule stmt_list {
      <stmt> (<sep> s <stmt>)* <sep>?
   }
   rule main_stmt_list {
      <main_stmt> (<sep> s <main_stmt>)* <sep>?
   }
   rule body_stmt_list {
      <body_stmt> (<sep> s <body_stmt>)* <sep>?
   }
   rule return_stmt {
      "return" idsafe s
      ((<expr> (s "," s <expr>)*)? -> [ ])
      -> { tag = 'return_stmt' }
   }
   rule block_stmt {
      <block> -> { tag = 'block_stmt' }
   }
   rule block_expr {
      <func_body> -> { tag = 'block_expr' }
   }
   rule block {
      '{' s <stmt_list> s <{ expect("}") }> -> { tag = 'block' }
   }
   rule import_decl {
      (
         "import" idsafe s
         ((<name> (s "," s <name>)*)? -> [ ]) s
         "from" idsafe s <name> ("." <name>)*
         (s "in" idsafe s <name>)?
      ) -> { tag = 'import_decl' }
   }
   rule export_decl {
      "export" idsafe s <name> (s "," s <name>)* -> { tag = 'export_decl' }
   }
   rule for_name {
      <name> (s <type_expr>)? -> { tag = 'for_name' }
   }
   rule for_in_stmt {
      "for" idsafe s
      (<for_name> (s "," s <for_name>)* -> [ ]) s
      "in" idsafe s <expr> s
      <block> -> { tag = 'for_in_stmt' }
   }
   rule for_stmt {
      "for" idsafe s <for_name> s "=" s <expr> s "," s <expr>
      (s "," s <expr>)? s <block> -> { tag = 'for_stmt' }
   }
   rule while_stmt {
      "while" idsafe s <expr> s <block>
      -> { tag = 'while_stmt' }
   }
   rule do_while_stmt {
      "do" idsafe s <block> s
      "while" idsafe s <expr> -> { tag = 'do_while_stmt' }
   }
   rule if_stmt {
      "if" idsafe s (<expr> s <block> -> [ ])
      (s "else" idsafe s "if" idsafe s <expr> s <block> -> [ ])*
      (s "else" idsafe s <block> -> [ ])?
      -> { tag = 'if_stmt' }
   }
   rule switch_stmt {
      "switch" idsafe s <expr> s
      <{ expect("{") }> {:loopy: {`true`} :}
      (s <case_stmt>)* (s <default_stmt>)? s
      <{ expect("}") }> -> { tag = 'switch_stmt' }
   }
   rule case_stmt {
      "case" idsafe hs* <expr> s <{ expect(":") }>
      s <case_body>?
      -> { tag = 'case_stmt' }
   }
   rule case_body {
      <case_body_stmt> (<sep> s <case_body_stmt>)* <sep>?
      -> { tag = 'case_body' }
   }
   rule case_body_stmt {
      !(("case" | "default") idsafe) <stmt>
   }
   rule default_stmt {
      "default" idsafe hs* ":" s <stmt_list>? -> { tag = 'default_stmt' }
   }
   rule throw_stmt {
      "throw" idsafe s <expr> -> { tag = 'throw_stmt' }
   }
   rule break_stmt {
      "break" idsafe -> { tag = 'break_stmt' }
   }
   rule continue_stmt {
      "continue" idsafe -> { tag = 'continue_stmt' }
   }
   rule try_stmt {
      "try" idsafe s
      "{" s <stmt_list> s <{ expect("}") }>
      ((s <catch_stmt>)* -> [ ])
      -> { tag = 'try_stmt' }
   }
   rule catch_stmt {
      "catch" idsafe s
      "(" s <name> (hs* <type_expr> | {`'Any'`})
      ")" s "{" s <stmt_list> s "}"
      -> { tag = 'catch_stmt' }
   }

   rule name_list {
      <name> (hs* "," s <name>)* -> { tag = 'name_list' }
   }
   rule type_term {
      <expr>
   }
   rule type_term_list {
      <type_term> (hs* "," s <type_term>)* -> { tag = 'type_term_list' }
   }
   rule type_expr {
      ":" hs* <type_term>
   }
   rule type_list {
      ":" hs* <type_term> (s "," s <type_term>)* -> { tag = 'type_list' }
   }
   rule typed_name {
      <name> (s <type_expr>)? -> function(node, type) {
         node::type = type
         return node
      }
   }

   rule var_decl {
      {:kind: {"var" | "our"} idsafe :} hs* (
         <var_list> (hs* "=" s <expr_list>)?
      ) -> { tag = 'var_decl' }
   }
   rule var_list {
      <typed_name> (hs* "," s <typed_name>)*
      -> { tag = 'var_list' }
   }

   rule attr {
      {:attr: { "static" } idsafe hs* | {`nil`} :}
   }
   rule has_decl {
      (<attr> "has" idsafe s <name>
         {:type: s <type_expr>  :}?
         {:expr: s "=" s <expr> :}?
      ) -> { tag = 'has_decl' }
   }

   rule needs_decl {
      <attr> "needs" idsafe hs* <meth_name> -> { tag = 'needs_decl' }
   }

   rule meth_name {
      | {: {"_[]=" | "_[]"} -> { tag = 'name' } :}
      | {: <name> "="? :}
   }

   rule meth_decl {
      (<attr> "method" idsafe hs* <meth_name> s
      ("(" s <param_list> s <{ expect(")") }> | {`[]`})
      (s <type_list>)? s
      "{" s <func_body> s <{ expect("}") }>
      ) -> { tag = 'meth_decl' }
   }
   rule func_decl {
      ("function" idsafe hs+ <name> s
      ("(" s <param_list> s <{ expect(")") }> s | {`[]`})
      <type_list>? s "{" s <func_body> s <{ expect("}") }>
      ) -> { tag = 'func_decl' }
   }
   rule func_body {
      <stmt_list>? -> { tag = 'func_body' }
   }
   rule func {
      ("function" idsafe s
      "(" s <param_list> s <{ expect(")") }> (s <type_list>)? s "{"
      s <func_body> s
      <{ expect("}") }>
      ) -> { tag = 'func' }
   }
   rule short_func {
      (
         ("(" s <param_list> s ")" (s <type_list>)? s
         | (({`'_'`}) -> [ ]))
         '=>' s (
            | "{" s <func_body> s <{ expect("}") }>
            | <expr_stmt> (s <sep>)?
         )
      ) -> { tag = 'short_func' }
   }

   rule guard_decl {
      (
         "guard" idsafe hs+ <name> s
         ("(" s <param_list> s <{ expect(")") }> s | {`[]`})
         <type_list>? s "{"
         s <func_body> s
         <{ expect("}") }>
      ) -> { tag = 'guard_decl' }
   }

   rule enum_decl {
      "enum" idsafe hs* <name> hs* "{"
      s <enum_members>* s <{ expect("}") }>
      -> { tag = 'enum_decl' }
   }
   rule enum_members {
      <enum_member> (hs* "," s <enum_member>)* (hs* ",")?
   }
   rule enum_member {
      <name> (hs* "=" hs* <number>)? -> { tag = 'enum_member' }
   }

   rule class_decl {
      "class" idsafe hs* <name> s
      (<class_from> | {`false`}) s
      (<class_with> | {`false`}) s
      "{" s <class_body> s <{ expect("}") }>
      -> { tag = 'class_decl' }
   }
   rule trait_decl {
      "trait" idsafe hs* <name> hs*
      ("[" hs* ((<name_list> -> [ ])) hs* "]" | {`[]`}) s
      (<class_with> | {`false`}) hs*
      "{" s <trait_body> s <{ expect("}") }>
      -> { tag = 'trait_decl' }
   }
   rule object_decl {
      "object" idsafe hs* <name> hs*
      (<class_from> | {`false`}) hs*
      (<class_with> | {`false`}) hs*
      "{" s <class_body> s <{ expect("}") }>
      -> { tag = 'object_decl' }
   }
   rule object_expr {
      "object" idsafe hs*
      (<class_from> | {`false`}) hs*
      (<class_with> | {`false`}) hs*
      "{" s <class_body> s <{ expect("}") }>
      -> { tag = 'object_expr' }
   }
   rule class_body {
      (<class_body_stmt> (<sep> s <class_body_stmt>)* <sep>?)?
      -> { tag = 'class_body' }
   }
   rule trait_body {
      (<trait_body_stmt> (<sep> s <trait_body_stmt>)* <sep>?)?
      -> { tag = 'trait_body' }
   }
   rule class_from {
      "from" idsafe hs* <type_term>
      -> { tag = 'class_from' }
   }
   rule class_with {
      "with" idsafe hs* <type_term> (hs* "," s <type_term>)*
      -> { tag = 'class_with' }
   }
   rule with_decl {
      <class_with> -> { tag = 'with_decl' }
   }
   rule class_body_stmt {
      | <has_decl>
      | <meth_decl>
      | <rule_decl>
      | <with_decl>
      | <body_stmt>
   }
   rule trait_body_stmt {
      <class_body_stmt> | <needs_decl>
   }
   rule rest {
      {'...'} (<name> (hs* <type_expr>)? &(s ")"))
      -> { tag = 'rest' }
   }
   rule param_list {
      (
      | <params>
      | {`nil`}
      ) -> [ ]
   }
   rule params {
      | <rest>
      | <param> s "," s <params>
      | <param>
   }
   rule ident {
      {:pos: %pos :} <name> -> { tag = 'ident' }
   }
   rule param {
      <name> s <type_expr>? (s "=" s <expr>)?
      -> { tag = 'param' }
   }
   rule name {
      !keyword (
         { (%alpha | "_" | "$") (%alnum | "_" | "$")* }
      ) -> { tag = 'name' }
   }
   rule hexadec {
      "-"? "0x" %xdigit+ ([Uu][Ll] -> 'ULL' | [Ll] -> 'LL')?
   }
   rule decimal {
      "-"? digits "." digits (("e"|"E") "-"? digits)?
   }
   rule integer {
      "-"? digits ([Uu][Ll] -> 'ULL' | [Ll] -> 'LL')?
   }
   rule octal {
      {~ { "-"? "0" [0-7]+ } -> function(s) { tostring(tonumber(s, 8)) } ~}
   }
   rule number {
      {~ <hexadec>
      |  <octal>
      |  <decimal>
      |  <integer>
      ~} -> tonumber -> { tag = 'number' }
   }
   rule string {
      (<qstring> | <astring>) -> { tag = 'string' }
   }
   rule special {
      {~
      | "\n"  -> "\\\n"
      | "\\$" -> "$"
      | "\\\\"
      | "\\" .
      ~}
   }
   rule qstring {
      | '"""' (
         | <string_expr>
         | {~ (<special> | !'"""'('"'->'\"') | !(<string_expr> | "\"\"\"") .)+ ~}
      )* ('"""' | <{ syntax_error("expected '\"\"\"'") }>)
      | '"' (
         | <string_expr>
         | {~ (<special> | !(<string_expr> | "\"") .)+ ~}
      )* ('"' | <{ syntax_error("expected '\"'") }>)
   }
   rule astring {
      {~
         | ("'''" -> "") ('\\' | '\'' | (!"'''" .))* ("'''" -> "")
         | ("'"   -> "") ('\\' | '\'' | (!"'"   .))* ("'"   -> "")
      ~}
   }
   rule string_expr {
      '${' s <expr> s "}"
   }
   rule vnil {
      "nil" idsafe -> { tag = 'vnil' }
   }
   rule vtrue {
      "true" idsafe -> { tag = 'vtrue' }
   }
   rule vfalse {
      "false" idsafe -> { tag = 'vfalse' }
   }
   rule range {
      (
         "[" s <expr> s ";" s <expr> ( s ";" s <expr> | {`"1"`} ) s "]"
      ) -> { tag = 'range' }
   }
   rule array {
      "[" s (<array_elements> | {`""`}) s <{expect("]")}>
      -> { tag = 'array' }
   }
   rule array_elements {
      <expr> ( s "," s <expr> )* (s ("," -> ''))?
   }

   rule table {
      "{" s <table_elems>? s <{expect('}')}>
      -> { tag = 'table' }
   }
   rule table_elems {
      <table_elem> ( s "," s <table_elem> )* (s ",")?
   }
   rule table_elem {
      | <table_pair>
      | <table_item>
   }
   rule table_item {
      <expr> -> { tag = 'table_item' }
   }
   rule table_pair {
      (
      | <name>
      | "[" s <expr> s <{ expect("]") }>
      ) s "=" s <expr>
      -> { tag = 'table_pair' }
   }
   rule primary {
      | <range>
      | <array>
      | <func>
      | <short_func>
      | <object_expr>
      | <pattern>
      | <ident>
      | &"." -> { tag = 'ident', { tag = 'name', 'self' } }
      | <number>
      | <string>
      | <vnil>
      | <vtrue>
      | <vfalse>
      | <table>
      | "(" s <expr> s <{ expect(")") }>
   }

   rule paren_expr {
      "(" s (<expr_list> | {`nil`} -> [ ]) s <{ expect(")") }>
      -> { tag = 'paren_expr' }
   }

   rule member_expr {
      (
      | {:oper: "[" :} s <expr> s "]"
      | {:oper: "::":} hs* "[" s <expr> s "]"
      | {:oper: "::":} hs* <name>
      ) -> { tag = 'member_expr' }
   }
   rule method_expr {
      {:oper: "." :} s <name> (hs* <paren_expr>)? -> { tag = 'method_expr' }
   }
   rule suffix_expr {
      | <member_expr>
      | <method_expr>
      | <paren_expr>
   }

   function fold_term(a, b) {
      table::insert(b, 1, a)
      return b
   }
   rule term {
      | <super_expr> (hs* <suffix_expr>)*
      | (<primary> {: hs* <suffix_expr> :}+) ~> fold_term
      | <primary>
   }
   rule super_expr {
      "super" idsafe hs* "." s <name> hs* (
         | "(" s <expr_list>? s ")"
         | {`[]`}
      ) -> { tag = 'super_expr' }
   }
   rule expr_stmt {
      | <super_expr> (hs* <suffix_expr>)* -> { tag = 'expr' }
      | <expr>
   }
   rule expr_list {
      <expr> (s "," s <expr>)* -> { tag = 'expr_list' }
   }
   rule expr {
      {:pos: %pos :} (
         | !<bind_binop_expr> <infix_expr>
         | <prefix_expr>
      ) -> { tag = 'expr' }
   }

   rule infix_expr {
      <{ make_infix_expr(/ !keyword word idsafe /, /<expr_1>/) }>
   }
   rule expr_1 {
      <{ make_infix_expr(/"||"/, /<expr_2>/) }>
   }
   rule expr_2 {
      <{ make_infix_expr(/"&&"/, /<expr_3>/) }>
   }
   rule expr_3 {
      <{ make_infix_expr(/"=="|"!="|"<="|">="|">"|"<"|"~~"|"!~"/, /<expr_4>/) }>
   }
   rule expr_4 {
      <{ make_infix_expr(/"<<"|">>>"|">>"|"^"|"|"|"&"/, /<expr_5>/) }>
   }
   rule expr_5 {
      <{ make_infix_expr(/"+"|"-"|"~"/, /<expr_6>/) }>
   }
   rule expr_6 {
      <{ make_infix_expr(/"*"|!("//"|"/*")"/"|"%"/, /<expr_7>/) }>
   }
   rule expr_7 {
      <{ make_infix_expr(/"**"/, /<prefix_expr>/) }>
   }

   var prefix_punct = / "..."|"!"|"#"|"-"|"~"|"?" /
   rule prefix_expr {
      | {:oper: { prefix_punct } :} hs* <prefix_expr> -> { tag = 'prefix_expr' }
      | <term> -> { tag = 'term' }
   }

   // binding expression rules
   rule bind_stmt {
      <bind_expr> | <bind_binop_expr>
   }
   rule bind_expr {
      <bind_list> hs* "=" s <expr_list>
      -> { tag = 'bind_expr' }
   }
   rule bind_binop {
      !('>=' | '<=' | '!=' | '==') {
         '+'|'-'|'**'|'*'|'/'|'%'|'^'|'~'|'||'|'|'|'&&'|'&'|'<<'|'>>'|'>>>'
      }'='
   }
   rule bind_binop_expr {
      <bind_term> hs* { <bind_binop> } s <expr> -> { tag = 'binop_bind_expr' }
   }
   rule bind_list {
      <bind_term> (hs* "," s <bind_term>)* -> { tag = 'bind_list' }
   }

   rule bind_term {
      ( <primary> (hs* <bind_member>)+
      | <name>
      ) -> { tag = 'bind_term' }
   }
   rule bind_member {
      ( <suffix_expr> <bind_member>
      | <bind_suffix>
      ) -> { tag = 'bind_member' }
   }
   rule bind_suffix {
      ( {:oper: "." :} hs* <name>
      | {:oper: "[" :} s <expr> s "]"
      | {:oper: "::" :} hs* <name>
      | {:oper: "::" :} hs* "[" s <expr> "]"
      ) -> { tag = 'bind_suffix' }
   }

   // PEG grammar and pattern rules
   rule pattern {
      "/" {~ s <rule_body> s ~} <{ expect("/") }> -> '__env.Pattern.P(%1)'
   }
   rule rule_decl {
      "rule" idsafe s <name> s "{" {~ s <rule_body> s ~} "}"
      -> '__env.rule(self,"%1",%2);'
   }
   rule rule_body {
      <rule_alt> | {`'__env.Pattern.P(nil)'`}
   }

   rule rule_alt {
      {~ ("|" -> '' s)? <rule_seq> (s ("|" -> "+") s <rule_seq>)* ~}
   }

   rule rule_seq {
      ({~ s <rule_suffix> ~}+ -> [ ]) -> function(a) { a.concat('*') }
   }
   rule rule_patt {
      ({~ s <rule_prefix> ~}+ -> [ ]) -> function(a) { a.concat('*') }
   }

   var prod_oper = / "->" | "~>" | "=>" /

   rule rule_suffix {
      ({~ <rule_patt> ~} {: {s} {prod_oper} {s} <rule_prod> :}*) ~> function(a,s1,o,s2,b,t) {
         if o == "=>" {
            return '__env.Pattern.Cmt(%s%s,%s%s)'.format(a,s1,s2,b)
         }
         else if o == "~>" {
            return '__env.Pattern.Cf(%s%s,%s%s)'.format(a,s1,s2,b)
         }
         else {
            if t == 'table' {
               return '__env.Pattern.Ch(%s%s,%s%s)'.format(a,s1,s2,b)
            }
            else if t == 'array' {
               return '__env.Pattern.Ca(%s%s,%s%s)'.format(a,s1,s2,b)
            }
            else {
               return '(%s)%s/%s(%s)'.format(a,s1,s2,b)
            }
         }
      }
   }

   rule rule_rep {
      {~ "+" -> "^1" | "*" -> "^0" | "?" -> "^-1" | "^"s("+"|"-")?s[0-9]+ ~}
   }
   rule rule_prefix {
      {~ (("&" -> "#") | ("!" -> "-")) {~ s <rule_prefix> ~} -> '%1%2'
      | <rule_primary>
      ~}
   }

   rule rule_prod {
      | <table> {`'table'`}
      | <array> {`'array'`}
      | <term>  {`'term'`}
   }
   rule rule_primary {
      ( <rule_group>
      | <rule_term>
      | <rule_class>
      | <rule_predef>
      | <rule_capt>
      | <rule_any>
      | <rule_ref>
      ) (s <rule_rep>)*
   }
   rule rule_group {
      {~ "(" s (<rule_alt> | <{ syntax_error("expected <rule_alt>") }>) s
         <{ expect(")") }>
      ~}
   }
   rule rule_term {
      {~ <string> -> '__env.Pattern.P(%1)' ~}
   }
   rule rule_class {
      {~
         ("[" -> '(') ("^" -> '__env.Pattern.P(1)-')?
         (((!"]" <rule_item>)+ -> [ ]) -> function(a) { "("+a.concat("+")+")" })
         ("]" -> ')')
      ~}
   }
   rule rule_item {
      {~ <rule_predef> | <rule_range>
      | {.} -> function(c) { '__env.Pattern.P(%q)'.format(c) }
      ~}
   }
   rule rule_predef {
      {~ ('%' -> '') (
         | { [0-9]+ } -> '__env.Pattern.Carg(%1)'
         | <name> -> '__env.Pattern.Def("%1")'
      ) ~}
   }
   rule rule_range {
      {~ . ("-"->'') !"]" . ~} -> function(r) { '__env.Pattern.R(%q)'.format(r) }
   }
   rule rule_any {
      {~ "." -> '__env.Pattern.P(1)' ~}
   }
   rule rule_ref {
      {~
      ("<" -> '') s
         ( <name> -> '__env.Pattern.V("%1")'
         | {~ ("{" -> '__env.Pattern.P(') s <expr> s ("}" -> ")") ~}
         ) s
      (">" -> '')
      | <ident> -> '__env.Pattern.P(%1)'
      ~}
   }
   rule rule_capt {
      | <rule_sub_capt>
      | <rule_const_capt>
      | <rule_simple_capt>
      | <rule_back_capt>
      | <rule_group_capt>
   }
   rule rule_group_capt {
      {~ "{:" ((<name> -> quote ":") | {`'nil'`}) {~ s <rule_alt> s ~} <{ expect(":}") }>
      -> '__env.Pattern.Cg(%2,%1)'
      ~}
   }
   rule rule_back_capt {
      "=" (<name> -> quote) -> '__env.Pattern.Cb(%1)'
   }
   rule rule_sub_capt {
      "{~" {~ s <rule_alt> s ~} <{ expect("~}") }> -> '__env.Pattern.Cs(%1)'
   }
   rule rule_const_capt {
      "{:" {~ s <rule_alt> s ~} <{ expect(":}") }> -> '__env.Pattern.Cg(%1)'
   }
   rule rule_const_capt {
      "{`" {~ s <expr_list> s ~} <{ expect("`}") }> -> '__env.Pattern.Cc(%1)'
   }
   rule rule_simple_capt {
      "{" {~ s <rule_alt> s ~} <{ expect("}") }> -> '__env.Pattern.C(%1)'
   }
}


object Compiler {

   method predef(ctx, env) {
      for k,v in (env || global)  {
         ctx.define(k, { base = '(environ)' })
      }
   }

   method compile(lupa, name, env) {
      var ctx = Context.new(lupa)
      ctx.enter('(environ)')
      self.predef(ctx, env || global)
      var lua = Parser.match(lupa, 1, ctx)
      ctx.leave()
      assert(ctx.scope.outer == nil, "scope is unbalanced")
      return lua
   }
}


class Scope {
   has entries = { }
   has resolve = { }
   has exports = [ ]
   has hoists  = [ ]
   has inner   = [ ]
   has outer
   has kind

   method init(outer) {
      .outer = outer
      if outer {
         outer.inner.push(self)
      }
   }
   method lookup(name, pos, orig) {
      orig ||= self
      if .entries[name] {
         return .entries[name]
      }
      else if .outer {
         return .outer.lookup(name, pos, orig)
      }
      orig.resolve[name] = pos
   }
   method define(name, info) {
      .entries[name] = info || { }
   }
   method unhoist(sep) {
      var code = .hoists.concat(sep)
      if .hoists.len > 0 {
         .hoists = [ ]
      }
      return code
   }
}

object Code {
   var ffi = require('ffi')

   our DEBUG = false

   var IDGEN = 0
   function genid {
      IDGEN += 1
      return '_'~IDGEN
   }

   var MAX_REG = 200
   var MAX_UVS = 60

   enum BC {
      ISLT, ISGE, ISLE, ISGT, ISEQV, ISNEV, ISEQS, ISNES,
      ISEQN, ISNEN, ISEQP, ISNEP, ISTC, ISFC, IST, ISF, MOV,
      NOT, UNM, LEN, ADDVN, SUBVN, MULVN, DIVVN, MODVN, ADDNV,
      SUBNV, MULNV, DIVNV, MODNV, ADDVV, SUBVV, MULVV, DIVVV,
      MODVV, POW, CAT, KSTR, KCDATA, KSHORT, KNUM, KPRI, KNIL,
      UGET, USETV, USETS, USETN, USETP, UCLO, FNEW, TNEW, TDUP,
      GGET, GSET, TGETV, TGETS, TGETB, TSETV, TSETS, TSETB,
      TSETM, CALLM, CALL, CALLMT, CALLT, ITERC, ITERN, VARG,
      ISNEXT, RETM, RET, RET0, RET1, FORI, JFORI, FORL, IFORL,
      JFORL, ITERL, IITERL, JITERL, LOOP, ILOOP, JLOOP, JMP,
      FUNCF, IFUNCF, JFUNCF, FUNCV, IFUNCV, JFUNCV, FUNCC, FUNCCW,
   }

   var BC_ABC = 0
   var BC_AD  = 1
   var BC_AJ  = 2

   var BC_MODE = {
      [0] = 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
      1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1,
      1, 0, 0, 0, 2, 1, 1, 1, 1, 2, 2, 2, 2, 1, 2, 2, 1, 2, 2, 1, 2, 1,
      1, 1, 1, 1, 1, 1, 1,
   }

   var VKNIL   = 0
   var VKFALSE = 1
   var VKTRUE  = 2

   var NO_JMP = ~0

   enum KOBJ {
      CHILD, TAB, I64, U64, COMPLEX, STR,
   }
   enum KTAB {
      NIL, FALSE, TRUE, INT, NUM, STR,
   }

   var FOR_IDX   = "(for index)"
   var FOR_STOP  = "(for limit)"
   var FOR_STEP  = "(for step)"
   var FOR_GEN   = "(for generator)"
   var FOR_STATE = "(for state)"
   var FOR_CTL   = "(for control)"

   ffi::cdef("""
      void *malloc(size_t);
      void *realloc(void*, size_t);
      int free(void*);

      typedef struct Buf {
        size_t size;
        size_t offs;
        uint8_t *data;
      } Buf;
   """)

   var double_1 = ffi::typeof('double[1]')
   var uint32_1 = ffi::typeof('uint32_t[1]')

   class Buf {
      static method new(size) {
         if !size { size = 1024 }
         var self = ffi::new('Buf', size)
         self::data  = ffi::C::malloc(size)
         self::offs  = 0
         return self
      }
      self::__gc = function(self) {
         ffi::C::free(self::data)
      }
      method need(size) {
         if self::size <= self::offs + size {
            var newsize = self::offs + size
            while newsize <= self::size {
               newsize *= 2
            }
            self::data = ffi::C::realloc(ffi::cast('void*', self::data), newsize)
            self::size = newsize
         }
      }
      method put(v) {
         self.need(1)
         var offs = self::offs
         self::data::[offs] = v
         self::offs = offs + 1
         return offs
      }

      self::__slots::put_uint8 = self::__slots::put

      method put_uint16(v) {
         self.need(2)
         var offs = self::offs
         var dptr = self::data + offs
         dptr::[0] = v
         v = v >> 8
         dptr::[1] = v
         self::offs = offs + 2
         return offs
      }

      method put_uint32(v) {
         self.need(4)
         var offs = self::offs
         var dptr = self::data + offs

         dptr::[0] = v
         v = v >> 8
         dptr::[1] = v
         v = v >> 8
         dptr::[2] = v
         v = v >> 8
         dptr::[3] = v

         self::offs = offs + 4
         return offs
      }

      method put_uleb128(v) {
         v = tonumber(v)
         var i, offs = 0, self::offs
         do {
            var b = v & 0x7f
            v = v >> 7
            if v != 0 {
               b = b | 0x80
            }
            self.put(b)
            i += 1
         }
         while v != 0
         return offs
      }

      method put_bytes(v) {
         var offs = self::offs
         self.need(#v)
         ffi::copy(self::data + offs, v)
         self::offs = offs + #v
         return offs
      }

      method pack {
         return ffi::string(self::data, self::offs)
      }

      method put_number(v) {
         var offs = self::offs
         var numv = double_1(v)
         var char = ffi::cast('uint8_t*', numv)

         var u32_lo, u32_hi = uint32_1(0), uint32_1(0)
         ffi::copy(u32_lo, char, 4)
         ffi::copy(u32_hi, char + 4, 4)

         self.put_uleb128(1 + 2 * u32_lo::[0]) // 33 bits with lsb set
         if u32_lo::[0] >= 0x80000000 {
            self::data[self::offs-1] = self::data::[self::offs-1] | 0x10
         }
         self.put_uleb128(u32_hi::[0])

         return offs
      }

      ffi::metatype('Buf', self)
   }

   class Ins {
      method init(op, a = 0, b = 0, c = 0) {
         self::[1] = op
         self::[2] = a
         self::[3] = b
         self::[4] = c
      }
      method write(buf) {
         var op, a = self::[1], self::[2]
         buf.put(op)
         buf.put(a)
         var mode = BC_MODE::[op]
         if mode == BC_ABC {
            var b, c = self::[3], self::[4]
            buf.put(c)
            buf.put(b)
         }
         else if mode == BC_AD {
            var d = self::[3]
            buf.put_uint16(d)
         }
         else if mode == BC_AJ {
            var j = self::[3]
            buf.put_uint16(j + 0x8000)
         }
         else {
            error("bad instruction [${op}] (op mode unknown)")
         }
      }
   }

   class KObj {
      method init(v) {
         self::[1] = v
      }
      method write(buf) {
         var t, v = type(self::[1]), self::[1]
         if t == "string" {
            self.write_string(buf, v)
         }
         else if t == 'table' {
            if typeof(v) == Proto {
               self.write_proto(buf, v)
            }
            else {
               self.write_table(buf, v)
            }
         }
      }
      method write_string(buf, v) {
         buf.put_uleb128(KOBJ.STR + #v)
         buf.put_bytes(v)
      }
      method write_table(buf, v) {
         error("NYI")
      }
   }

   class KNum {
      method init(v) {
         self::[1] = v
      }
      method write(buf) {
         buf.put_number(self::[1])
      }
   }

   class Proto {
      our CHILD  = 0x01 // Has child prototypes.
      our VARARG = 0x02 // Vararg function.
      our FFI    = 0x04 // Uses BC_KCDATA for FFI datatypes.
      our NOJIT  = 0x08 // JIT disabled for this function.
      our ILOOP  = 0x10 // Patched bytecode with ILOOP etc.
      
      has flags = 0
      has outer
      has params = { }
      has upvals = { }
      has code   = { }
      has kobj   = { }
      has knum   = { }
      has debug  = { }
      has lninfo = { }
      has labels = { }
      has tohere = { }
      has kcache = { }
      has varinfo = { }
      has actvars = { }
      has freereg = 0
      has currline = 0
      has firstline = 0
      has numlines = 0
      has framesize = 0

      method init(flags = 0, outer) {
         self.flags = flags
         self.outer = outer
      }

      method nextreg(num = 1) {
         var reg
         if num > 1 {
            reg = self.freereg
            for i=1, num {
               if self.freereg >= self.framesize {
                  self.framesize = self.freereg
               }
               self.freereg += 1
            }
         }
         else {
            reg = self.freereg
            if reg >= self.framesize {
               self.framesize = reg
            }
            self.freereg += 1
         }
         return reg
      }
      method enter {
         var outer = self.actvars
         self.actvars = setmetatable({ }, {
            freereg = self.freereg,
            __index = outer,
         })
      }
      method leave {
         var scope = assert(getmetatable(self.actvars), "cannot leave main scope")
         self.freereg = scope::freereg
         self.actvars = scope::__index
      }
      method child(flags) {
         self.flags |= CHILD
         var child = Proto.new(flags, self)
         child::idx = #self.kobj
         self.kobj[child] = #self.kobj
         self.kobj[#self.kobj + 1] = child
         return child
      }
      method const(val) {
         if type(val) == 'string' {
            if !self.kcache[val] {
               var item = KObj.new(val)
               item::idx = #self.kobj
               self.kcache[val] = item
               self.kobj[#self.kobj + 1] = item
            }
         }
         else if type(val) == 'number' {
            if !self.kcache[val] {
               var item = KNum.new(val)
               item::idx = #self.knum
               self.kcache[val] = item
               self.knum[#self.knum + 1] = item
            }
         }
         else {
            error("not a const: ${val}")
         }
         return self.kcache[val]::idx
      }
      method line(ln) {
         if self.firstline == 0 {
            self.firstline = ln
         }
         self.currline = ln
         if ln > self.numlines {
            self.numlines = ln
         }
      }
      method emit(op, a, b, c) {
         if DEBUG {
            print("Ins: %s %s %s %s".format(BC::[op], a, b, c || 0))
         }
         var ins = Ins.new(op, a, b, c)
         self.code[#self.code + 1] = ins
         self.lninfo[#self.lninfo + 1] = self.currline
         return ins
      }

      method write(buf) {
         var has_child
         if self.flags & CHILD != 0 {
            has_child = true
            for i=1, #self.kobj {
               var o = self.kobj[i]
               if typeof(o) == Proto {
                  o.write(buf)
               }
            }
         }

         var body = Buf.new
         if has_child {
            self.emit(BC.UCLO, 0, 0) // close upvals
         }
         self.emit(BC.RET0, 0, 1)

         self.write_body(body)

         var offs = body::offs
         self.write_debug(body)

         var head = Buf.new
         self.write_head(head, body::offs - offs)

         buf.put_uleb128(head::offs + body::offs) // length of the proto

         var head_pack = ffi::string(head::data, head::offs)
         var body_pack = ffi::string(body::data, body::offs)
         buf.put_bytes(head_pack)
         buf.put_bytes(body_pack)
      }
      method write_head(buf, size_debug = 0) {
         buf.put(self.flags)
         buf.put(#self.params)
         buf.put(self.framesize)
         buf.put(#self.upvals)
         buf.put_uleb128(#self.kobj)
         buf.put_uleb128(#self.knum)
         buf.put_uleb128(#self.code)
         buf.put_uleb128(size_debug)
         buf.put_uleb128(self.firstline)
         buf.put_uleb128(self.numlines)
      }
      method write_body(buf) {
         for i=1, #self.code {
            self.code::[i].write(buf)
         }
         for i=1, #self.upvals {
            var uval = self.upvals[i]
            if self.outer == uval::proto {
               buf.put_uint16(uval::idx | 0x8000)
            }
            else {
               self.outer.upval(uval::name)
               buf.put_uint16(uval::idx)
            }
         }
         for i=#self.kobj, 1, -1 {
            var o = self.kobj[i]
            if typeof(o) == Proto {
               buf.put_uleb128(KOBJ.CHILD)
            }
            else {
               self.kobj::[i].write(buf)
            }
         }
         for i=1, #self.knum {
            self.knum::[i].write(buf)   
         }
      }
      method write_debug(buf) {
         var first = self.firstline
         if self.numlines < 256 {
            for i=1, #self.lninfo {
               var delta = self.lninfo::[i] - first
               buf.put_uint8(delta)
            }
         }
         else if self.numlines < 65536 { 
            for i=1, #self.lninfo {
               var delta = self.lninfo::[i] - first
               buf.put_uint16(delta)
            }
         }
         else {
            for i=1, #self.lninfo {
               var delta = self.lninfo::[i] - first
               buf.put_uint32(delta)
            }
         }
         for i=1, #self.upvals {
            var uval = self.upvals::[i]
            buf.put_bytes(uval::name~"\0")
         }
         var lastpc = 0
         for i=1, #self.varinfo {
            var lvar = self.varinfo::[i]
            var startpc, endpc = (lvar::startpc || 0), (lvar::endpc || 0) + 1
            buf.put_bytes(lvar::name~"\0")
            buf.put_uleb128(startpc - lastpc)
            buf.put_uleb128(endpc - startpc)
            lastpc = startpc
         }
      }
      method newvar(name, reg = self.nextreg, ofs = #self.code) {
         var lvar = {
            idx      = reg,
            startpc  = ofs,
            endpc    = ofs,
            name     = name,
         }
         self.actvars::[name] = lvar
         self.actvars::[#self.actvars + 1] = lvar
         self.varinfo::[name] = lvar
         self.varinfo::[#self.varinfo + 1] = lvar
         return lvar
      }
      method getvar(name) {
         var info = self.actvars::[name]
         if !info { return nil }
         if !info::startpc {
            info::startpc = #self.code
         }
         info::endpc = #self.code
         return info::idx
      }
      method param(name, reg, ofs) {
         var lvar = self.newvar(name, reg, ofs)
         lvar::startpc = 0
         self.params::[#self.params + 1] = lvar
         return lvar::idx
      }
      method upval(name) {
         if !self.upvals::[name] {
            var proto, upval = self.outer
            while proto {
               if proto.varinfo::[name] {
                  upval = proto.varinfo::[name]
                  upval::proto = proto
                  break
               }
               proto = proto.outer
            }
            if !upval {
               error("not found upvalue:"~name)
            }
            self.upvals::[name] = upval
            self.upvals::[#self.upvals + 1] = upval
         }
         return self.upvals::[name]::idx
      }
      method here(name) {
         if name == nil { name = Code::genid() }
         if self.tohere::[name] {
            // forward jump, so back patch
            var back = self.tohere::[name]
            for i=1, #back {
               var offs = back::[i]
               self.code::[offs]::[3] = #self.code - offs
            }
            self.tohere::[name] = nil
         }
         else {
            // declare label before jumps (backward jump follows)
            self.labels::[name] = #self.code - 1
         }
         return name
      }
      method jump(name, base) {
         var free = self.freereg
         base ||= self.nextreg
         self.freereg = free
         if self.labels::[name] {
            // jump seen after declared label (backward jump)
            var offs = self.labels::[name]
            return self.emit(BC.JMP, base, offs - #self.code)
         }
         else {
            // unknown label, so remember the location and patch after
            var here = self.tohere::[name]
            if !here {
               here = { }
               self.tohere::[name] = here
            }
            here::[#here + 1] = #self.code + 1
            return self.emit(BC.JMP, base, NO_JMP)
         }
      }
      method op_jump(base, delta) {
         return self.emit(BC.JMP, base, delta)
      }
      method op_loop(base, delta) {
         return self.emit(BC.LOOP, base, delta)
      }

      // branch if condition
      method op_test(cond, a, here) {
         return self.emit(cond && BC.IST || BC.ISF, 0, a), self.jump(here)
      }
      // branch if comparison
      method op_comp(cond, a, b, here) {
         if cond == 'LE' {
            cond = 'GE'
            a, b = b, a
         }
         else if cond == 'LT' {
            cond = 'GT'
            a, b = b, a
         }
         else if cond == 'EQ' || cond == 'NE' {
            // invert, since we jump if not condition
            cond = cond == 'EQ' && 'NE' || 'EQ'
            var tb = type(b)
            if tb == 'nil' || tb == 'boolean' {
               cond = cond~'P'
               if tb == 'nil' {
                  b = VKNIL
               }
               else {
                  b = b == true && VKTRUE || VKFALSE
               }
            }
            else if tb == 'number' {
               cond = cond~'N'
            }
            else if tb == 'string' {
               cond = cond~'S'
            }
            else {
               cond = cond~'V'
            }
         }
         return self.emit(BC['IS'~cond], a, b), self.jump(here)
      }
      method op_add(dest, var1, var2) {
         return self.emit(BC.ADDVV, dest, var1, var2)
      }
      method op_sub(dest, var1, var2) {
         return self.emit(BC.SUBVV, dest, var1, var2)
      }
      method op_mul(dest, var1, var2) {
         return self.emit(BC.MULVV, dest, var1, var2)
      }
      method op_div(dest, var1, var2) {
         return self.emit(BC.DIVVV, dest, var1, var2)
      }
      method op_mod(dest, var1, var2) {
         return self.emit(BC.MODVV, dest, var1, var2)
      }
      method op_pow(dest, var1, var2) {
         return self.emit(BC.POWVV, dest, var1, var2)
      }
      method op_gget(dest, name) {
         return self.emit(BC.GGET, dest, self.const(name))
      }
      method op_gset(base, name) {
         return self.emit(BC.GSET, base, self.const(name))
      }

      method op_not(dest, var1) {
         return self.emit(BC.NOT, dest, var1)
      }
      method op_unm(dest, var1) {
         return self.emit(BC.UNM, dest, var1)
      }
      method op_len(dest, var1) {
         return self.emit(BC.LEN, dest, var1)
      }
      method op_move(dest, base) {
         return self.emit(BC.MOV, dest, base)
      }

      method op_load(dest, val) {
         var tv = type(val)
         if tv == 'nil' {
            return self.emit(BC.KPRI, dest, VKNIL)
         }
         else if tv == 'boolean' {
            return self.emit(BC.KPRI, dest, val && VKTRUE || VKFALSE)
         }
         else if tv == 'string' {
            return self.emit(BC.KSTR, dest, self.const(val))
         }
         else if tv == 'number' {
            if val < 0xff {
               return self.emit(BC.KSHORT, dest, val)
            }
            else {
               return self.emit(BC.KNUM, dest, self.const(val))
            }
         }
         else {
            error("cannot load as constant: ${val}")
         }
      }

      method op_tnew(dest, narry, nhash) {
         if narry {
            if narry < 3 {
               narry = 3
            }
            else if narry > 0x7ff {
               narry = 0x7ff
            }
         }
         else {
            narry = 0
         }
         if nhash {
            nhash = math::ceil(nhash / 2)
         }
         else {
            nhash = 0
         }
         return self.emit(BC.TNEW, dest, narry | (nhash << 11))
      }
      method op_tget(dest, tab, key) {
         if type(key) == 'string' {
            return self.emit(BC.TGETS, dest, tab, self.const(key))
         }
         else {
            return self.emit(BC.TGETV, dest, tab, key)
         }
      }
      method op_tset(tab, key, val) {
         if type(key) == 'string' {
            return self.emit(BC.TSETS, val, tab, self.const(key))
         }
         else {
            return self.emit(BC.TSETV, val, tab, key)
         }
      }
      method op_tsetm(base, vnum) {
         var knum = double_1(0)
         var vint = ffi::cast('uint8_t*', knum)
         vint::[0] = vnum & 0x00FF
         vint::[1] = vnum << 8
         var vidx = self::const(tonumber(knum[0]))
         return self.emit(BC.TSETM, base, vidx)
      }
      method op_fnew(dest, pidx) {
         return self.emit(BC.FNEW, dest, pidx)
      }
      method op_uclo(jump) {
         return self.emit(BC.UCLO, 0, jump || 0)
      }
      method op_uset(name, val) {
         var slot = self.upval(name)
         var tv   = type(val)
         if tv == 'string' {
            return self.emit(BC.USETS, slot, self.const(val))
         }
         else if tv == 'nil' || tv == 'boolean' {
            var pri
            if tv == 'nil' {
               pri = VKNIL
            }
            else {
               pri = val && VKTRUE || VKFALSE
            }
            return self.emit(BC.USETP, slot, pri)
         }
         else {
            return self.emit(BC.USETV, slot, val)
         }
      }
      method op_uget(dest, name) {
         var slot = self.upval(name)
         return self.emit(BC.UGET, dest, slot)
      }
      method op_ret(base, rnum) {
         return self.emit(BC.RET, base, rnum + 1)
      }
      method op_ret0 {
         return self.emit(BC.RET0, 0, 1)
      }
      method op_ret1(base) {
         return self.emit(BC.RET1, base, 2)
      }
      method op_retm(base, rnum) {
         return self.emit(BC.RETM, base, rnum)
      }
      method op_varg(base, want) {
         return self.emit(BC.VARG, base, want + 1, #self.params)
      }
      method op_call(base, want, narg) {
         return self.emit(BC.CALL, base, want + 1, narg + 1)
      }
      method op_callt(base, narg) {
         return self.emit(BC.CALLT, base, narg + 1)
      }
      method op_callm(base, want, narg) {
         return self.emit(BC.CALLM, base, want + 1, narg)
      }
      method op_callmt(base, narg) {
         return self.emit(BC.CALLMT, base, narg + 1)
      }
      method op_fori(base, stop, step) {
         var loop = self.emit(BC.FORI, base, NO_JMP)
         self.here(loop)
         return loop
      }
      method op_forl(base, loop) {
         var offs = self.labels::[loop]
         loop::[3] = #self.code - offs
         return self.emit(BC.FORL, base, offs - #self.code)
      }
      method op_iterc(base, want) {
         return self.emit(BC.ITERC, base, want + 1, 3)
      }
      method op_iterl(base, loop) {
         var offs = self.labels::[loop]
         return self.emit(BC.ITERL, base, offs - #self.code, 3)
      }
      method op_cat(base, rbot, rtop) {
         return self.emit(BC.CAT, base, rbot, rtop)
      }
   }

   class Dump {
      our HEAD_1 = 0x1b
      our HEAD_2 = 0x4c
      our HEAD_3 = 0x4a
      our VERS   = 0x01
      our BE     = 0x01
      our STRIP  = 0x02
      our FFI    = 0x04

      has main  = Proto.new(Proto::VARARG)
      has name  = '(binary)'
      has flags = 0

      method init(main, name, flags = 0) {
         self.main  = main
         self.name  = name
         self.flags = flags
      }

      method write_header(buf) {
         buf.put(HEAD_1)
         buf.put(HEAD_2)
         buf.put(HEAD_3)
         buf.put(VERS)
         buf.put(self.flags)
         if self.flags & STRIP == 0 {
            buf.put_uleb128(#self.name)
            buf.put_bytes(self.name)
         }
      }

      method write_footer(buf) {
         buf.put(0x00)
      }

      method pack {
         var buf = Buf.new
         self.write_header(buf)
         self.main.write(buf)
         self.write_footer(buf)
         return buf.pack
      }
   }
}


class Context {

   has scope  = Scope.new
   has source = ''

   has name
   has dump
   has main
   has proto
   has offs = 0
   has sync_line = 0
   has sync_seen = { }

   method init(name, source) {
      self.name = name
      self.main = Code::Proto.new(Code::Proto::VARARG)
      self.dump = Code::Dump.new(self.main, '='~self.name)
      self.proto = self.main
      self.source = source
   }

   method enter(kind) {
      kind ||= .scope.kind
      .scope = Scope.new(.scope)
      .scope.kind = kind
   }
   method leave() {
      if .scope.hoists.len > 0 {
         error("unhoisted code: ${.scope.hoists}", 2)
      }
      var outer = .scope.outer
      var inner = .scope
      if outer != nil {
         .scope = outer
         return inner
      }
      Error raise "no outer scope"
   }
   method define(name, info) {
      info ||= { }
      if info::base != '(environ)' {
         info::proto = self.proto
      }
      .scope.define(name, info)
   }
   method lookup(name, pos) {
      var info = .scope.lookup(name, pos || .offs)
      if info && info::base != '(environ)' {
         if info::proto == self.proto {
            self.proto.getvar(name)
         }
         else {
            self.proto.upval(name)
         }
      }
      return info
   }
   method update(name, pos, reg) {
      var info = self.lookup(name, pos)
      if info && info::base != '(environ)' {
         if info::proto == self.proto {
            self.proto.getvar(name)
         }
         else {
            self.proto.upval(name)
         }
      }
   }
   method getvar(name, dest) {
      dest ||= self.nextreg
      var info = self.scope.lookup(name, self.offs)
      if info == nil || info::base == '(environ)' {
         self.op_gget(dest, name)
         return dest
      }
      if info::proto == self.proto {
         self.proto.getvar(name)
         if info::idx != dest {
            self.op_move(dest, info::idx)
         }
      }
      else {
         self.op_uget(dest, name)
      }
      return dest
   }
   method invoke(base, meth, want, ...args) {
      var free = self.freereg
      var recv = self.nextreg
      self.op_move(recv, base)
      self.op_tget(base, base, meth)
      self.nextreg(args.len)
      for i=1, args.len {
         if args[i] != recv + i {
            self.op_move(recv + i, args[i])
         }
      }
      self.op_call(base, want, 1 + args.len)
      self.freereg = free
      return base
   }

   function count_lines(src, pos, idx) {
      var line = 0
      var index, limit = idx || 1, pos
      while index <= limit {
         var s, e = src.find("\n", index, true)
         if s == nil || e > limit { break }
         index = e + 1
         line  = line + 1
      }
      return line
   }

   for name, meth in Code::Proto::__slots {
      if self::__slots::[name] == nil {
         self::__slots::[name] = function(self, _1, _2, _3) {
            var proto = self.proto
            proto::[name](proto, _1, _2, _3)
         }
      }
   }

   method nextreg(num) {
      var next = .proto.nextreg()
      if num && num > 1 {
         for i=2, num {
            .proto.nextreg()
         }
      }
      return next
   }
   method sync(node) {
      var offs = node['pos']
      if offs != nil && offs > self.offs {
         var prev = self.offs
         var line = count_lines(self.source, offs, prev + 1) + self.sync_line
         self.sync_line = line
         self.offs = offs
         self.proto.line(line)
      }
   }
   method emit(node, _1, _2, _3, _4) {
      var emit = Handler::[node['tag']]
      self.sync(node)
      return emit(Handler, self, node, _1, _2, _3, _4)
   }
   method call(name, node, _1, _2, _3, _4) {
      var call = Handler::[name]
      self.sync(node)
      return call(Handler, self, node, _1, _2, _3, _4)
   }
   method transform(ast) {
      self.emit(ast)
      return self.dump.pack()
   }
}


object Handler {
   our BINOP = {
      ['+'] = true,
      ['-'] = true,
      ['*'] = true,
      ['/'] = true,
      ['%'] = true,
      ['~'] = true,
      ['**'] = true,
   }
   our UNOP = {
      ['-'] = true,
      ['!'] = true,
      ['#'] = true,
   }
   method expr(ctx, node, _1, _2, _3) {
      ctx.emit(node[1], _1, _2, _3)
   }
   method prefix_expr(ctx, node, dest) {
      var free = ctx.freereg
      dest ||= ctx.nextreg
      var oper = node::oper
      if UNOP[oper] {
         var a = ctx.emit(node[1], nil, 1)
         if      oper == '-' { ctx.op_unm(dest, a) }
         else if oper == '!' { ctx.op_not(dest, a) }
         else if oper == '#' { ctx.op_len(dest, a) }
      }
      else {
         error("NYI")
      }
      ctx.freereg = free
      return dest
   }
   method infix_expr(ctx, node, dest, want) {
      var free = ctx.freereg
      dest ||= ctx.nextreg
      var oper = node::oper

      if BINOP[oper] {
         var a = ctx.emit(node[1], ctx.nextreg, 1)
         var b = ctx.emit(node[2], ctx.nextreg, 1)
         if      oper == '+'  { ctx.op_add(dest, a, b) }
         else if oper == '-'  { ctx.op_sub(dest, a, b) }
         else if oper == '*'  { ctx.op_mul(dest, a, b) }
         else if oper == '/'  { ctx.op_div(dest, a, b) }
         else if oper == '%'  { ctx.op_mod(dest, a, b) }
         else if oper == '**' { ctx.op_pow(dest, a, b) }
         else if oper == '~'  { ctx.op_cat(dest, a, b) }
      }
      else {
         var expr = {
            oper = '.',
            node[1], { tag = 'name', oper },
            { [ node[2] ] }
         }
         ctx.call('method_expr', expr, dest, want)
      }

      ctx.freereg = free
      return dest
   }
   method bind_expr(ctx, node, dest) {
      var free = ctx.freereg

      var left_list = node[1]
      var expr_list = node[2]

      var want = left_list.len
      for i=1, expr_list.len {
         want -= (i - 1)
         expr_list[i] = ctx.emit(expr_list[i], ctx.nextreg, want)
      }

      want = left_list.len
      for i=1, left_list.len {
         want -= (i - 1)
         ctx.emit(left_list[i], expr_list[i], want)
      }

      ctx.freereg = free
   }
   method bind_term(ctx, node, dest, want) {
      if node[1]::tag == 'name' {
         var name = ctx.call('name', node[1])
         var info = ctx.lookup(name)
         if info {
            if info::type {
               var free = ctx.freereg
               var type = info::type
               var base = ctx.getvar(type::name, ctx.nextreg)
               ctx.invoke(base, 'coerce', 1, dest)
               dest = base
               ctx.freereg = free
            }
            if info::proto != ctx.proto {
               ctx.op_uset(name, dest)
            }
            else {
               ctx.update(name, ctx.offs, dest)
               if dest && dest != info::idx {
                  ctx.op_move(info::idx, dest)
               }
            }
            return info::idx
         }
         else {
            return ctx.op_gset(dest, name)
         }
      }
      else if node[2]::tag == 'bind_member' {
         var base = ctx.emit(node[1], nil, 1)
         var bind = node[2][1]
         var tkey = ctx.emit(bind[1], nil, 1)
         if bind::oper == '::' {
            ctx.op_tset(base, tkey, dest)
            return dest
         }
         else if bind::oper == '.' {
            var free = ctx.freereg
            var recv = ctx.nextreg
            var varg = ctx.nextreg
            ctx.op_move(recv, base)
            ctx.op_tget(base, base, tkey~'=')
            ctx.op_move(varg, dest)
            ctx.op_call(base, 0, 2)
            ctx.freereg = free
            return dest
         }
      }
      return ctx.emit(node[1], dest)
   }
   method return_stmt(ctx, node) {
      var list = node[1]
      var vars = [ ]
      for i=1, list.len {
         vars[vars.len + 1] = ctx.emit(list[i], ctx.nextreg)
      }
      ctx.op_ret(vars[1], vars.len)
   }

   method member_expr(ctx, node, base) {
      var free = ctx.freereg
      base ||= ctx.nextreg
      var base = ctx.emit(node[1], base)
      var expr = ctx.emit(node[2])
      ctx.op_tget(base, base, expr)
      ctx.freereg = free
      return base
   }
   method method_expr(ctx, node, base, want) {
      want ||= 0
      var args = [ ]
      var free = ctx.freereg
      base = ctx.emit(node[1], base, 1)
      var recv = ctx.nextreg
      ctx.op_move(recv, base)
      args.push(recv)

      var mres = false
      var narg = 0
      if node[3] && node[3][1] {
         var list = node[3][1]
         narg = list.len
         ctx.nextreg(narg)
         for i=1, narg {
            if i == narg {
               args.push(ctx.emit(list[i], recv + i, MULTIRES))
            }
            else {
               args.push(ctx.emit(list[i], recv + i, 1))
            }
         }
      }
      for i=1, args.len {
         var arg = args[i]
         if arg == MULTIRES {
            mres = true
            break
         }
      }
      narg = args.len
      var name = ctx.emit(node[2])
      ctx.op_tget(base, base, name)

      ctx.freereg = free
      if want == MULTIRES {
         ctx.op_call(base, want, narg)
         return MULTIRES
      }
      else if mres {
         ctx.op_callm(base, 0, narg - 1)
      }
      else {
         ctx.op_call(base, want, narg)
      }
      return base
   }

   our MULTIRES = -1

   method paren_expr(ctx, node, base, want) {
      want ||= 0
      var args = [ ]
      var free = ctx.freereg

      base ||= ctx.nextreg
      base = ctx.emit(node[1], base)

      var narg = node[2].len

      ctx.nextreg(narg)
      var mres = false
      var last = node[2].len
      for i=1, last {
         if i == last {
            args.push(ctx.emit(node[2][i], base + i, MULTIRES))
         }
         else {
            args.push(ctx.emit(node[2][i], base + i, 1))
         }
      }
      for i=1, args.len {
         var arg = args[i]
         if arg == MULTIRES {
            mres = true
            break
         }
      }

      ctx.freereg = free
      if want == MULTIRES {
         ctx.op_call(base, want, narg)
         return MULTIRES
      }
      else if mres {
         ctx.op_callm(base, 0, narg - 1)
      }
      else {
         ctx.op_call(base, want, narg)
      }
      return base
   }
   method array(ctx, node, dest) {
      var free = ctx.freereg
      dest ||= ctx.nextreg

      var base = ctx.nextreg
      var recv = ctx.nextreg
      ctx.op_gget(base, 'Array')
      ctx.op_move(recv, base)
      ctx.op_tget(base, base, 'new')

      ctx.nextreg(node.len)
      for i=1, node.len {
         ctx.emit(node[i], recv + i)
      }
      ctx.op_call(base, 1, 1 + node.len)
      ctx.op_move(dest, base)
      ctx.freereg = free

      return dest
   }
   method table(ctx, node, dest) {
      var free = ctx.freereg
      dest ||= ctx.nextreg
      var base = dest

      var iarry, ihash = [ ], [ ]
      for i=1, node.len {
         var n = node[i]
         if n::tag == 'table_item' {
            iarry.push(n)
         }
         else {
            ihash.push(n)
         }
      }
      ctx.op_tnew(base, iarry.len, ihash.len)

      var tkey = ctx.nextreg
      var tval = ctx.nextreg
      for i=1, iarry.len {
         ctx.op_load(tkey, i)
         ctx.emit(iarry[i][1], tval)
         ctx.op_tset(base, tkey, tval)
      }
      for i=1, ihash.len {
         var temp = ctx.emit(ihash[i][1], tkey)
         ctx.emit(ihash[i][2], tval)
         ctx.op_tset(base, temp, tval)
      }
      ctx.freereg = base
      var ctor = ctx.nextreg
      var recv = ctx.nextreg
      var this = ctx.nextreg
      ctx.op_move(this, base)
      ctx.op_gget(ctor, 'Table')
      ctx.op_move(recv, ctor)
      ctx.op_tget(ctor, ctor, 'new')
      ctx.op_call(ctor, 1, 2)
      ctx.freereg = free

      return dest
   }
   method string(ctx, node, dest) {
      var free = ctx.freereg
      dest ||= ctx.nextreg
      ctx.nextreg(node.len)
      for i=1, node.len {
         var frag = node[i]
         if type(frag) == 'string' {
            ctx.op_load(dest + i - 1, node[i])
         }
         else {
            ctx.emit(node[i], dest + i - 1)
         }
      }
      if node.len > 1 {
         ctx.op_cat(dest, dest, dest + node.len - 1)
      }
      ctx.freereg = free
      return dest
   }
   method number(ctx, node, dest) {
      dest ||= ctx.nextreg
      ctx.op_load(dest, tonumber(node[1]))
      return dest
   }
   method vtrue(ctx, node, dest) {
      dest ||= ctx.nextreg
      ctx.op_load(dest, true)
      return dest
   }
   method vfalse(ctx, node, dest) {
      dest ||= ctx.nextreg
      ctx.op_load(dest, false)
      return dest
   }
   method vnil(ctx, node, dest) {
      dest ||= ctx.nextreg
      ctx.op_load(dest, nil)
      return dest
   }
   method ident(ctx, node, dest) {
      var name = ctx.call('name', node[1])
      var info = ctx.lookup(name)
      if info && info::base != '(environ)' {
         if info::proto != ctx.proto {
            var idx = ctx.upval(name)
            dest ||= ctx.nextreg
            ctx.op_uget(dest, name)
            return dest
         }
         if dest && dest != info::idx {
            ctx.op_move(dest, info::idx)
            return dest
         }
         else {
            return info::idx
         }
      }
      else {
         dest ||= ctx.nextreg
         ctx.op_gget(dest, name)
         return dest
      }
   }
   method decl_stmt(ctx, node, _1, _2, _3) {
      return ctx.emit(node[1], _1, _2, _3)
   }
   method var_decl(ctx, node) {
      var kind = node['kind']
      var name_list = node[1]
      var expr_list = node[2]
      var info_list = [ ]
      for i=1, name_list.len {
         var name = ctx.call('name', name_list[i])
         var type = name_list[i]::type
         var info = ctx.newvar(name, ctx.nextreg)
         ctx.define(name, info)
         if type {
            info::type = type
            type::name = '(type'~Code::genid()~')'
            type::base = ctx.emit(type, ctx.nextreg, 1)
            type::info = ctx.newvar(type::name, type::base)
            ctx.define(type::name, type::info)
         }
         info_list.push(info)
      }
      var free = ctx.freereg
      var want = name_list.len
      for i=1, expr_list.len {
         want -= (i - 1)
         var expr = expr_list[i]
         var info = info_list[i]
         var dest = info::idx
         ctx.emit(expr, dest, want)
         if info::type {
            var type = info::type
            var free = ctx.freereg
            var cast = ctx.nextreg
            ctx.op_move(cast, type::base)
            ctx.invoke(cast, 'coerce', 1, dest)
            ctx.op_move(dest, cast)
            ctx.freereg = free
         }
      }
      ctx.freereg = free
   }
   method func_decl(ctx, node, dest) {
      var proto = ctx.child(Code::Proto::VARARG)
      var outer = ctx.proto
      ctx.proto = proto
      ctx.enter('lexical')
      var name = ctx.call('name', node[1])
      var args = node[2]
      var body = node[3]
      for i=1, args.len {
         var pname = ctx.call('name', args[1][i])
         var pidx = ctx.param(pname)
         ctx.define(pname, { idx = pidx })
      }
      for i=1, body.len - 1 {
         ctx.emit(body[i])
      }

      // last expr implies return
      if body.len > 0 {
         var last = body[body.len]
         if last[1]::tag == 'expr' {
            ctx.call('return_stmt', { [ last ] })
         }
         else {
            ctx.emit(last)
         }
      }

      ctx.proto = outer
      ctx.leave()

      if ctx.scope.kind == 'lexical' {
         dest ||= ctx.nextreg
         var info = ctx.newvar(name, dest)
         ctx.define(name, info)
         ctx.op_fnew(dest, proto::idx)
      }
      else {
         var dest = ctx.nextreg
         ctx.op_fnew(dest, proto::idx)
         ctx.op_gset(dest, name)
         ctx.freereg = dest
      }
      return proto::idx
   }
   method term(ctx, node, _1, _2, _3) {
      return ctx.emit(node[1], _1, _2, _3)
   }
   method name(ctx, node) {
      return node[1]
   }
   method stmt(ctx, node, _1, _2, _3) {
      return ctx.emit(node[1], _1, _2, _3)
   }
   method if_stmt(ctx, node) {
      var free = ctx.freereg
      var last = Code::genid()
      for i=1, node.len {
         var cond, body = node[i][1], node[i][2]
         if body == nil {
            body = cond
            ctx.emit(body)
         }
         else {
            var expr = ctx.emit(cond, nil, 1)
            var exit = Code::genid()
            ctx.op_test(false, expr, exit)
            ctx.emit(body)
            ctx.jump(last)
            ctx.here(exit)
         }
      }
      ctx.here(last)
      ctx.freereg = free
   }
   method for_stmt(ctx, node) {
      var free = ctx.freereg
      ctx.enter("loop")
      ctx.proto.enter()
      var base = ctx.nextreg(3)
      var name = ctx.emit(node[1][1])
      var info = ctx.newvar(name, base)
      ctx.define(name, info)
      ctx.emit(node[2], base, 1)
      var stop = ctx.emit(node[3], base + 1, 1)
      var step = base + 2
      var body
      if node[5] {
         ctx.emit(node[4], step, 1)
         body = node[5]
      }
      else {
         ctx.op_load(step, 1)
         body = node[4]
      }
      var loop = ctx.op_fori(base)
      ctx.emit(body)
      ctx.op_forl(base, loop)
      ctx.proto.leave()
      ctx.leave()
      ctx.freereg = free
   }
   method for_in_stmt(ctx, node) {
      var free = ctx.freereg
      ctx.enter("loop")
      ctx.proto.enter()
      var vars = node[1]
      var expr = node[2]
      var body = node[3]
      var loop = Code::genid()

      var base = ctx.nextreg(vars.len + 1)
      var iter = base + vars.len + 1

      ctx.emit(expr, base, vars.len + 1)
      ctx.jump(loop)

      for i=1, vars.len {
         var name = ctx.call('name', vars[i][1])
         var info = ctx.newvar(name, ctx.nextreg)
         ctx.define(name, info)
      }

      var ltop = Code::genid()
      ctx.here(ltop)
      ctx.emit(body)
      ctx.here(loop)
      ctx.op_iterc(iter, vars.len)
      ctx.op_iterl(iter, ltop)
      ctx.proto.leave()
      ctx.leave()
      ctx.freereg = free
   }
   method block(ctx, node) {
      for i=1, node.len {
         ctx.emit(node[i])
      }
   }
   method unit(ctx, node) {
      ctx.enter('main')
      for k,v in pairs(global) {
         ctx.define(k, { base = '(environ)' })
      }

      /*
      var info = ctx.newvar('(environ)')
      ctx.nextreg(2)

      ctx.op_tnew(1)
      ctx.op_tnew(2, 1)
      ctx.op_gget(3, "_G")
      ctx.op_tset(2, "__index", 3)
      ctx.op_gget(0, "setmetatable")
      ctx.op_call(0, 1, 2)

      ctx.freereg = 1
      */

      for i, stmt in ipairs(node) {
         ctx.emit(stmt)
      }
      ctx.leave()
   }
}


package::loaded::['lupa.lang'] = {
   Compiler = Compiler,
   Parser   = Parser,
   Context  = Context,
}

var tests = [ ]

function runtest(tnum, dump) {
   var test = tests[tnum]
   print('-'.rep(30)+'TEST:'+tnum+'-'.rep(30))
   print(test)
   var src = test
   var ast = Parser.script(src)
   if dump {
      print(ASTUtil.dump(ast))
   }
   var ctx = Context.new("test", src)
   var out = ctx.transform(ast)
   var fun = assert(loadstring(out))
   var bc  = require('jit.bc')
   bc::dump(fun, nil, true)
   var glo = setmetatable({ }, { __index = _G })
   glo::_G = glo
   var env = {
      print = print,
      Array = Array,
      Table = Table,
      ipairs = ipairs,
      pairs  = pairs,
      _G    = glo,
      obj   = {
         ['foo='] = function(self, val) {
            self::_foo = val
         },
         ['foo'] = function(self) {
            return self::_foo
         },
         ['greet'] = function(self, mesg) {
            print(mesg)
         },
      },
      Number = Number,
   }
   setfenv(fun, env)
   fun()
} 

tests push '''
var mesg = "Hello"
function greet(whom) {
   print(mesg, whom, "!")
}
greet("World")
var a, b = 1, 40 + 2
print(a, b)
'''

tests push '''
function a() {
   function c() {
      return 'Hi'
   }
   return c()
}
function b() {
   return 'Hello', 'World!'
}
print(a(), b())
'''

tests push '''
_G::print("Hello World!")
'''

tests push '''
var a = [ 1, 2 ]
print(a)
var b = 'bee'
var s = "a${b}c"
print(s)
'''

tests push '''
var l = "Hello".len::toString("foo","bar")
print(l)
'''

tests push '''
var h = { 1, 2, foo = "bar", 3}
print(h)
'''

tests push '''
a = 42
a = 12
print(a)
'''

tests push '''
var h = { }
h::foo = 42
print(h::foo)
'''

tests push '''
obj.foo = 42
print(obj.foo)
'''

tests push '''
obj greet "Hello World!"
'''

tests push '''
var a = 69
function answer() {
   a = 42
}
answer()
print("answer:", a)
'''

tests push '''
var a = true
if a {
   print("OK")
}
else if !a {
   print("NOT OK")
}
else {
   print("WTF?!")
}
'''

tests push '''
var a : Number = 42
function f() {
   a = "69"
}
f()
print(a)
'''

tests push '''
var a = 1
for i=a, 10 {
   print("tick:", i)
}
var b = 2
'''

tests push '''
var a = { foo = 'bar', baz = 42 }
for k, v in pairs(a) {
   print(k, v)
}
var b = 2
'''

for i=1, tests.len {
   runtest(i, i == tests.len)
}


