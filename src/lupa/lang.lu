export Compiler, Parser, Context

object ASTUtil {

   function _dump(node, buf, level) {
      var pad  = '  '.rep(level)
      var pad1 = '  '.rep(level - 1)
      if node is Table {
         var pos = node['pos'] && "@${node['pos']}" || ''
         buf.push("<${node['tag']}>${pos} {\n")
         var seen = { }
         var abuf = [ ]
         for i=1, rawlen(node) {
            seen[i] = true
            abuf.push("${pad}[${i}] = ")
            _dump(node::[i], abuf, level + 1)
            abuf.push(",\n")
         }
         for k,v in node {
            if !seen[k] && k != 'tag' && k != 'pos' {
               buf.push("${pad}${k} = ")
               _dump(v, buf, level + 1)
               buf.push(",\n")
            }
         }
         buf.push(abuf.concat())
         buf.push("${pad1}}")
      }
      else if node is Array {
         buf.push("[\n")
         for i=1, rawlen(node) {
            buf.push("${pad}[${i}] = ")
            _dump(node::[i], buf, level + 1)
            buf.push(",\n")
         }
         buf.push("${pad1}]")
      }
      else if type(node) == 'string' {
         buf.push("%q".format(node))
      }
      else {
         buf.push(tostring(node))
      }
   }

   method dump(node) {
      var buf = [ ]
      _dump(node, buf, 1)
      return buf.concat()
   }
}



object Parser {

   function error_line(src, pos) {
      var line = 1
      var index, limit = 1, pos
      while index <= limit {
         var s, e = src.find("\n", index, true)
         if s == nil || e > limit { break }
         index = e + 1
         line  = line + 1
      }
      return line
   }
   function error_near(src, pos) {
      if (src.len < pos + 20) {
         return src.sub(pos)
      }
      else {
         return src.sub(pos, pos + 20)+"..."
      }
   }
   function syntax_error(m) {
      return function(src, pos) {
         var line, near = error_line(src, pos), error_near(src, pos)
         error("SyntaxError: ${m||''} on line ${line} near '${near}'")
      }
   }
   function expect(p,m) {
      if !m { m = p }
      return / p | <{ syntax_error("expected '"+m+"'") }> /
   }

   function quote(c) { return "%q".format(c) }

   var nl      = / "\n" /
   var line_comment = /
      ((!nl %s)* "//" (!nl .)* nl)
   /
   var long_comment = /
      "/*" | (!"*/" .)* "*/"
   /
   var comment = / line_comment | long_comment /
   var idsafe  = / !(%alnum | "_") /
   var s       = / (comment | %s)* /
   var S       = / (comment | %s)+ /
   var hs      = / !nl %s /
   var udigit  = / %digit {~ "_" -> "" ~}? /
   var digits  = / %digit udigit* /
   var word    = / ((%alpha | "_") (%alnum | "_")*) /

   var keyword = / (
      | "var" | "function" | "class" | "with" | "in" | "our"
      | "nil" | "true" | "false" | "return" | "static"
      | "for" | "throw" | "method" | "has" | "from" | "break" | "guard"
      | "switch" | "case" | "default" | "do" | "while" | "needs"
      | "continue" | "import" | "export" | "try" | "catch" | "super"
      | "default" | "finally" | "if" | "else" | "rule" | "enum"
   ) idsafe /

   var infix_punct = /
      |'||'|'|'|'&&'|'&'|'~~'|'~'|'**'|'*'|'/'|'%'
      |'+'|'-'|'>>>'|'>>'|'>='|'>'|'<<'|'<='|'<'|'^'
   /

   function make_infix_expr(oper, term) {
      / (term {: hs* {oper} s term :}*) ~> function(a, o, b) {
         return { tag = 'infix_expr', oper = o, a, b }
      } /
   }

   rule script {
      <unit> (!. | <{syntax_error("invalid syntax")}>)
   }
   rule unit {
      { %s* '#!' (!nl .)* %s* }?
      s <main_stmt_list>? s
      -> { tag = 'unit' }
   }

   rule sep {
      long_comment? ("\n" | ";" | &"}" | line_comment) | [\t ] <sep>
   }

   rule decl_stmt {
      | <var_decl>
      | <enum_decl>
      | <func_decl>
      | <class_decl>
      | <trait_decl>
      | <guard_decl>
      | <object_decl>
   }
   rule main_decl_stmt {
      {:pos: %pos :} (
         | <import_decl>
         | <export_decl>
      ) -> { tag = 'stmt' }
   }
   rule body_decl_stmt {
      {:pos: %pos :} (
         | <import_decl>
      ) -> {tag = 'stmt' }
   }
   rule stmt {
      {:pos: %pos :} (
         | <if_stmt>
         | <switch_stmt>
         | <throw_stmt>
         | <break_stmt>
         | <continue_stmt>
         | <for_stmt>
         | <for_in_stmt>
         | <do_while_stmt>
         | <while_stmt>
         | <try_stmt>
         | <decl_stmt>
         | <bind_stmt>
         | <expr_stmt>
         | <block_stmt>
         | <return_stmt>
      ) -> { tag = 'stmt' }
   }
   rule main_stmt {
      | <main_decl_stmt>
      | <stmt>
   }
   rule body_stmt {
      | <body_decl_stmt>
      | &<export_decl> <{ syntax_error("export in nested scope") }>
      | <stmt>
   }
   rule stmt_list {
      <stmt> (<sep> s <stmt>)* <sep>?
   }
   rule main_stmt_list {
      <main_stmt> (<sep> s <main_stmt>)* <sep>?
   }
   rule body_stmt_list {
      <body_stmt> (<sep> s <body_stmt>)* <sep>?
   }
   rule return_stmt {
      "return" idsafe s
      ((<expr> (s "," s <expr>)*)? -> [ ])
      -> { tag = 'return_stmt' }
   }
   rule block_stmt {
      <block> -> { tag = 'block_stmt' }
   }
   rule block_expr {
      <func_body> -> { tag = 'block_expr' }
   }
   rule block {
      '{' s <stmt_list> s <{ expect("}") }> -> { tag = 'block' }
   }
   rule import_decl {
      (
         "import" idsafe s
         ((<name> (s "," s <name>)*)? -> [ ]) s
         "from" idsafe s <name> ("." <name>)*
         (s "in" idsafe s <name>)?
      ) -> { tag = 'import_decl' }
   }
   rule export_decl {
      "export" idsafe s <name> (s "," s <name>)* -> { tag = 'export_decl' }
   }
   rule for_name {
      <name> (s <type_expr>)? -> { tag = 'for_name' }
   }
   rule for_in_stmt {
      "for" idsafe s
      (<for_name> (s "," s <for_name>)* -> [ ]) s
      "in" idsafe s <expr> s
      <block> -> { tag = 'for_in_stmt' }
   }
   rule for_stmt {
      "for" idsafe s <for_name> s "=" s <expr> s "," s <expr>
      (s "," s <expr> | {`1`}) s <block> -> { tag = 'for_stmt' }
   }
   rule while_stmt {
      "while" idsafe s <expr> s <block>
      -> { tag = 'while_stmt' }
   }
   rule do_while_stmt {
      "do" idsafe s <block> s
      "while" idsafe s <expr> -> { tag = 'do_while_stmt' }
   }
   rule if_stmt {
      "if" idsafe s (<expr> s <block> -> [ ])
      (s "else" idsafe s "if" idsafe s <expr> s <block> -> [ ])*
      (s "else" idsafe s <block> -> [ ])?
      -> { tag = 'if_stmt' }
   }
   rule switch_stmt {
      "switch" idsafe s <expr> s
      <{ expect("{") }> {:loopy: {`true`} :}
      (s <case_stmt>)* (s <default_stmt>)? s
      <{ expect("}") }> -> { tag = 'switch_stmt' }
   }
   rule case_stmt {
      "case" idsafe hs* <expr> s <{ expect(":") }>
      s <case_body>?
      -> { tag = 'case_stmt' }
   }
   rule case_body {
      <case_body_stmt> (<sep> s <case_body_stmt>)* <sep>?
      -> { tag = 'case_body' }
   }
   rule case_body_stmt {
      !(("case" | "default") idsafe) <stmt>
   }
   rule default_stmt {
      "default" idsafe hs* ":" s <stmt_list>? -> { tag = 'default_stmt' }
   }
   rule throw_stmt {
      "throw" idsafe s <expr> -> { tag = 'throw_stmt' }
   }
   rule break_stmt {
      "break" idsafe -> { tag = 'break_stmt' }
   }
   rule continue_stmt {
      "continue" idsafe -> { tag = 'continue_stmt' }
   }
   rule try_stmt {
      "try" idsafe s
      "{" s <stmt_list> s <{ expect("}") }>
      ((s <catch_stmt>)* -> [ ])
      -> { tag = 'try_stmt' }
   }
   rule catch_stmt {
      "catch" idsafe s
      "(" s <name> (hs* <type_expr> | {`'Any'`})
      ")" s "{" s <stmt_list> s "}"
      -> { tag = 'catch_stmt' }
   }

   rule name_list {
      <name> (hs* "," s <name>)* -> { tag = 'name_list' }
   }
   rule type_term {
      <expr>
   }
   rule type_term_list {
      <type_term> (hs* "," s <type_term>)* -> { tag = 'type_term_list' }
   }
   rule type_expr {
      ":" hs* <type_term> -> { tag = 'type_expr' }
   }
   rule type_list {
      ":" hs* <type_term> (s "," s <type_term>)* -> { tag = 'type_list' }
   }

   rule var_decl {
      {:kind: {"var" | "our"} idsafe :} hs* (
         (<var_list> -> [ ])
         (hs* "=" (s <expr> (s "," s <expr>)* -> [ ]))?
      ) -> { tag = 'var_decl' }
   }
   rule var_list {
      <name> (s <type_expr>)? (hs* "," s (<name> (s <type_expr>)?))*
   }

   rule attr {
      {:attr: { "static" } idsafe hs* | {`nil`} :}
   }
   rule has_decl {
      (<attr> "has" idsafe s <name>
         {:type: s <type_expr>  :}?
         {:expr: s "=" s <expr> :}?
      ) -> { tag = 'has_decl' }
   }

   rule needs_decl {
      <attr> "needs" idsafe hs* <meth_name> -> { tag = 'needs_decl' }
   }

   rule meth_name {
      | {: {"_[]=" | "_[]"} -> { tag = 'name' } :}
      | {: <name> "="? :}
   }

   rule meth_decl {
      (<attr> "method" idsafe hs* <meth_name> s
      ("(" s <param_list> s <{ expect(")") }> | {`[]`})
      (s <type_list>)? s
      "{" s <func_body> s <{ expect("}") }>
      ) -> { tag = 'meth_decl' }
   }
   rule func_decl {
      ("function" idsafe hs+ <name> s
      ("(" s <param_list> s <{ expect(")") }> s | {`[]`})
      <type_list>? s "{" s <func_body> s <{ expect("}") }>
      ) -> { tag = 'func_decl' }
   }
   rule func_body {
      <stmt_list>? -> { tag = 'func_body' }
   }
   rule func {
      ("function" idsafe s
      "(" s <param_list> s <{ expect(")") }> (s <type_list>)? s "{"
      s <func_body> s
      <{ expect("}") }>
      ) -> { tag = 'func' }
   }
   rule short_func {
      (
         ("(" s <param_list> s ")" (s <type_list>)? s
         | (({`'_'`}) -> [ ]))
         '=>' s (
            | "{" s <func_body> s <{ expect("}") }>
            | <expr_stmt> (s <sep>)?
         )
      ) -> { tag = 'short_func' }
   }

   rule guard_decl {
      (
         "guard" idsafe hs+ <name> s
         ("(" s <param_list> s <{ expect(")") }> s | {`[]`})
         <type_list>? s "{"
         s <func_body> s
         <{ expect("}") }>
      ) -> { tag = 'guard_decl' }
   }

   rule enum_decl {
      "enum" idsafe hs* <name> hs* "{"
      s <enum_members>* s <{ expect("}") }>
      -> { tag = 'enum_decl' }
   }
   rule enum_members {
      <enum_member> (hs* "," s <enum_member>)* (hs* ",")?
   }
   rule enum_member {
      <name> (hs* "=" hs* <number>)? -> { tag = 'enum_member' }
   }

   rule class_decl {
      "class" idsafe hs* <name> s
      (<class_from> | {`false`}) s
      (<class_with> | {`false`}) s
      "{" s <class_body> s <{ expect("}") }>
      -> { tag = 'class_decl' }
   }
   rule trait_decl {
      "trait" idsafe hs* <name> hs*
      ("[" hs* ((<name_list> -> [ ])) hs* "]" | {`[]`}) s
      (<class_with> | {`false`}) hs*
      "{" s <trait_body> s <{ expect("}") }>
      -> { tag = 'trait_decl' }
   }
   rule object_decl {
      "object" idsafe hs* <name> hs*
      (<class_from> | {`false`}) hs*
      (<class_with> | {`false`}) hs*
      "{" s <class_body> s <{ expect("}") }>
      -> { tag = 'object_decl' }
   }
   rule object_expr {
      "object" idsafe hs*
      (<class_from> | {`false`}) hs*
      (<class_with> | {`false`}) hs*
      "{" s <class_body> s <{ expect("}") }>
      -> { tag = 'object_expr' }
   }
   rule class_body {
      (<class_body_stmt> (<sep> s <class_body_stmt>)* <sep>?)?
      -> { tag = 'class_body' }
   }
   rule trait_body {
      (<trait_body_stmt> (<sep> s <trait_body_stmt>)* <sep>?)?
      -> { tag = 'trait_body' }
   }
   rule class_from {
      "from" idsafe hs* <type_term>
      -> { tag = 'class_from' }
   }
   rule class_with {
      "with" idsafe hs* <type_term> (hs* "," s <type_term>)*
      -> { tag = 'class_with' }
   }
   rule with_decl {
      <class_with> -> { tag = 'with_decl' }
   }
   rule class_body_stmt {
      | <has_decl>
      | <meth_decl>
      | <rule_decl>
      | <with_decl>
      | <body_stmt>
   }
   rule trait_body_stmt {
      <class_body_stmt> | <needs_decl>
   }
   rule rest {
      {'...'} (<name> (hs* <type_expr>)? &(s ")"))
      -> { tag = 'rest' }
   }
   rule param_list {
      (
      | <params>
      | {`nil`}
      ) -> [ ]
   }
   rule params {
      | <rest>
      | <param> s "," s <params>
      | <param>
   }
   rule ident {
      {:pos: %pos :} <name> -> { tag = 'ident' }
   }
   rule param {
      <name> s <type_expr>? (s "=" s <expr>)?
      -> { tag = 'param' }
   }
   rule name {
      !keyword (
         { (%alpha | "_" | "$") (%alnum | "_" | "$")* }
      ) -> { tag = 'name' }
   }
   rule hexadec {
      "-"? "0x" %xdigit+ ([Uu][Ll] -> 'ULL' | [Ll] -> 'LL')?
   }
   rule decimal {
      "-"? digits "." digits (("e"|"E") "-"? digits)?
   }
   rule integer {
      "-"? digits ([Uu][Ll] -> 'ULL' | [Ll] -> 'LL')?
   }
   rule octal {
      {~ { "-"? "0" [0-7]+ } -> function(s) { tostring(tonumber(s, 8)) } ~}
   }
   rule number {
      {~ <hexadec>
      |  <octal>
      |  <decimal>
      |  <integer>
      ~} -> tonumber -> { tag = 'number' }
   }
   rule string {
      (<qstring> | <astring>) -> { tag = 'string' }
   }
   rule special {
      {~
      | "\n"  -> "\\\n"
      | "\\$" -> "$"
      | "\\\\"
      | "\\" .
      ~}
   }
   rule qstring {
      | '"""' (
         | <string_expr>
         | {~ (<special> | !'"""'('"'->'\"') | !(<string_expr> | "\"\"\"") .)+ ~}
      )* ('"""' | <{ syntax_error("expected '\"\"\"'") }>)
      | '"' (
         | <string_expr>
         | {~ (<special> | !(<string_expr> | "\"") .)+ ~}
      )* ('"' | <{ syntax_error("expected '\"'") }>)
   }
   rule astring {
      {~
         | ("'''" -> "") ('\\' | '\'' | (!"'''" .))* ("'''" -> "")
         | ("'"   -> "") ('\\' | '\'' | (!"'"   .))* ("'"   -> "")
      ~}
   }
   rule string_expr {
      '${' s <expr> s "}"
   }
   rule vnil {
      "nil" idsafe -> { tag = 'vnil' }
   }
   rule vtrue {
      "true" idsafe -> { tag = 'vtrue' }
   }
   rule vfalse {
      "false" idsafe -> { tag = 'vfalse' }
   }
   rule range {
      (
         "[" s <expr> s ";" s <expr> ( s ";" s <expr> | {`"1"`} ) s "]"
      ) -> { tag = 'range' }
   }
   rule array {
      "[" s (<array_elements> | {`""`}) s <{expect("]")}>
      -> { tag = 'array' }
   }
   rule array_elements {
      <expr> ( s "," s <expr> )* (s ("," -> ''))?
   }

   rule table {
      "{" s (<table_elems> | {`""`}) s <{expect('}')}>
      -> { tag = 'table' }
   }
   rule table_elems {
      <table_elem> ( s "," s <table_elem> )* (s ",")?
   }
   rule table_elem {
      | <table_pair>
      | <table_item>
   }
   rule table_item {
      <expr> -> { tag = 'table_item' }
   }
   rule table_pair {
      (
      | <name>
      | "[" s <expr> s <{ expect("]") }>
      ) s "=" s <expr>
      -> { tag = 'table_pair' }
   }
   rule primary {
      | <range>
      | <array>
      | <func>
      | <short_func>
      | <object_expr>
      | <pattern>
      | <ident>
      | &"." -> { tag = 'ident', { tag = 'name', 'self' } }
      | <number>
      | <string>
      | <vnil>
      | <vtrue>
      | <vfalse>
      | <table>
      | "(" s <expr> s <{ expect(")") }>
   }

   rule paren_expr {
      "(" s (<expr_list> | {`nil`}) s <{ expect(")") }> -> { tag = 'paren_expr' }
   }

   rule member_expr {
      (
      | {:oper: "." :} s <name> (hs* <paren_expr>)?
      | {:oper: "[" :} s <expr> s "]"
      | {:oper: "::":} hs* "[" s <expr> s "]"
      | {:oper: "::":} hs* <name>
      ) -> { tag = 'member_expr' }
   }

   rule suffix_expr {
      | <member_expr>
      | <paren_expr>
   }

   function fold_term(a, b) {
      table::insert(b, 1, a)
      return b
   }
   rule term {
      | <super_expr> (hs* <suffix_expr>)*
      | (<primary> {: hs* <suffix_expr> :}+) ~> fold_term
      | <primary>
   }
   rule super_expr {
      "super" idsafe hs* "." s <name> hs* (
         | "(" s <expr_list>? s ")"
         | {`[]`}
      ) -> { tag = 'super_expr' }
   }
   rule expr_stmt {
      | <super_expr> (hs* <suffix_expr>)* -> { tag = 'expr' }
      | <expr>
   }
   rule expr_list {
      <expr> (s "," s <expr>)* -> { tag = 'expr_list' }
   }
   rule expr {
      {:pos: %pos :} (
         | !<bind_binop_expr> <infix_expr>
         | <prefix_expr>
      ) -> { tag = 'expr' }
   }

   rule infix_expr {
      <{ make_infix_expr(/ !keyword word idsafe /, /<expr_1>/) }>
   }
   rule expr_1 {
      <{ make_infix_expr(/"||"/, /<expr_2>/) }>
   }
   rule expr_2 {
      <{ make_infix_expr(/"&&"/, /<expr_3>/) }>
   }
   rule expr_3 {
      <{ make_infix_expr(/"^"|"|"|"&"/,  /<expr_4>/) }>
   }
   rule expr_4 {
      <{ make_infix_expr(/"<<"|"<"|">>>"|">>"|">"/, /<expr_5>/) }>
   }
   rule expr_5 {
      <{ make_infix_expr(/"=="|"!="|'<='|'>='/, /<expr_6>/) }>
   }
   rule expr_6 {
      <{ make_infix_expr(/"+"|"-"|"~"/, /<expr_7>/) }>
   }
   rule expr_7 {
      <{ make_infix_expr(/"*"|"/"|"%"/, /<expr_8>/) }>
   }
   rule expr_8 {
      <{ make_infix_expr(/"**"/, /<prefix_expr>/) }>
   }

   var prefix_punct = / "..."|"!"|"#"|"-"|"~"|"?" /
   rule prefix_expr {
      | {: { prefix_punct } hs* <term> :} -> { tag = 'prefix_expr' }
      | <term> -> { tag = 'term' }
   }

   // binding expression rules
   rule bind_stmt {
      (<bind_expr> | <bind_binop_expr>) -> { tag = 'bind_stmt' }
   }
   rule bind_expr {
      ((<bind_list> -> [ ]) hs* "=" s (<expr_list> -> [ ]))
      -> { tag = 'bind_expr' }
   }
   rule bind_binop {
      !('>=' | '<=' | '!=' | '==') {
         '+'|'-'|'**'|'*'|'/'|'%'|'^'|'~'|'||'|'|'|'&&'|'&'|'<<'|'>>'|'>>>'
      }'='
   }
   rule bind_binop_expr {
      <bind_term> hs* { <bind_binop> } s <expr> -> { tag = 'binop_bind_expr' }
   }
   rule bind_list {
      <bind_term> (hs* "," s <bind_term>)* -> { tag = 'bind_list' }
   }

   rule bind_term {
      ( <primary> (hs* <bind_member>)+
      | <name>
      ) -> { tag = 'bind_term' }
   }
   rule bind_member {
      ( <suffix_expr> <bind_member>
      | <bind_suffix>
      ) -> { tag = 'bind_member' }
   }
   rule bind_suffix {
      ( {:oper: "." :} hs* <name>
      | {:oper: "[" :} s <expr> s "]"
      | {:oper: "::" :} hs* <name>
      | {:oper: "::" :} hs* "[" s <expr> "]"
      ) -> { tag = 'bind_suffix' }
   }

   // PEG grammar and pattern rules
   rule pattern {
      "/" {~ s <rule_body> s ~} <{ expect("/") }> -> '__env.Pattern.P(%1)'
   }
   rule rule_decl {
      "rule" idsafe s <name> s "{" {~ s <rule_body> s ~} "}"
      -> '__env.rule(self,"%1",%2);'
   }
   rule rule_body {
      <rule_alt> | {`'__env.Pattern.P(nil)'`}
   }

   rule rule_alt {
      {~ ("|" -> '' s)? <rule_seq> (s ("|" -> "+") s <rule_seq>)* ~}
   }

   rule rule_seq {
      ({~ s <rule_suffix> ~}+ -> [ ]) -> function(a) { a.concat('*') }
   }
   rule rule_patt {
      ({~ s <rule_prefix> ~}+ -> [ ]) -> function(a) { a.concat('*') }
   }

   var prod_oper = / "->" | "~>" | "=>" /

   rule rule_suffix {
      ({~ <rule_patt> ~} {: {s} {prod_oper} {s} <rule_prod> :}*) ~> function(a,s1,o,s2,b,t) {
         if o == "=>" {
            return '__env.Pattern.Cmt(%s%s,%s%s)'.format(a,s1,s2,b)
         }
         else if o == "~>" {
            return '__env.Pattern.Cf(%s%s,%s%s)'.format(a,s1,s2,b)
         }
         else {
            if t == 'table' {
               return '__env.Pattern.Ch(%s%s,%s%s)'.format(a,s1,s2,b)
            }
            else if t == 'array' {
               return '__env.Pattern.Ca(%s%s,%s%s)'.format(a,s1,s2,b)
            }
            else {
               return '(%s)%s/%s(%s)'.format(a,s1,s2,b)
            }
         }
      }
   }

   rule rule_rep {
      {~ "+" -> "^1" | "*" -> "^0" | "?" -> "^-1" | "^"s("+"|"-")?s[0-9]+ ~}
   }
   rule rule_prefix {
      {~ (("&" -> "#") | ("!" -> "-")) {~ s <rule_prefix> ~} -> '%1%2'
      | <rule_primary>
      ~}
   }

   rule rule_prod {
      | <table> {`'table'`}
      | <array> {`'array'`}
      | <term>  {`'term'`}
   }
   rule rule_primary {
      ( <rule_group>
      | <rule_term>
      | <rule_class>
      | <rule_predef>
      | <rule_capt>
      | <rule_any>
      | <rule_ref>
      ) (s <rule_rep>)*
   }
   rule rule_group {
      {~ "(" s (<rule_alt> | <{ syntax_error("expected <rule_alt>") }>) s
         <{ expect(")") }>
      ~}
   }
   rule rule_term {
      {~ <string> -> '__env.Pattern.P(%1)' ~}
   }
   rule rule_class {
      {~
         ("[" -> '(') ("^" -> '__env.Pattern.P(1)-')?
         (((!"]" <rule_item>)+ -> [ ]) -> function(a) { "("+a.concat("+")+")" })
         ("]" -> ')')
      ~}
   }
   rule rule_item {
      {~ <rule_predef> | <rule_range>
      | {.} -> function(c) { '__env.Pattern.P(%q)'.format(c) }
      ~}
   }
   rule rule_predef {
      {~ ('%' -> '') (
         | { [0-9]+ } -> '__env.Pattern.Carg(%1)'
         | <name> -> '__env.Pattern.Def("%1")'
      ) ~}
   }
   rule rule_range {
      {~ . ("-"->'') !"]" . ~} -> function(r) { '__env.Pattern.R(%q)'.format(r) }
   }
   rule rule_any {
      {~ "." -> '__env.Pattern.P(1)' ~}
   }
   rule rule_ref {
      {~
      ("<" -> '') s
         ( <name> -> '__env.Pattern.V("%1")'
         | {~ ("{" -> '__env.Pattern.P(') s <expr> s ("}" -> ")") ~}
         ) s
      (">" -> '')
      | <ident> -> '__env.Pattern.P(%1)'
      ~}
   }
   rule rule_capt {
      | <rule_sub_capt>
      | <rule_const_capt>
      | <rule_simple_capt>
      | <rule_back_capt>
      | <rule_group_capt>
   }
   rule rule_group_capt {
      {~ "{:" ((<name> -> quote ":") | {`'nil'`}) {~ s <rule_alt> s ~} <{ expect(":}") }>
      -> '__env.Pattern.Cg(%2,%1)'
      ~}
   }
   rule rule_back_capt {
      "=" (<name> -> quote) -> '__env.Pattern.Cb(%1)'
   }
   rule rule_sub_capt {
      "{~" {~ s <rule_alt> s ~} <{ expect("~}") }> -> '__env.Pattern.Cs(%1)'
   }
   rule rule_const_capt {
      "{:" {~ s <rule_alt> s ~} <{ expect(":}") }> -> '__env.Pattern.Cg(%1)'
   }
   rule rule_const_capt {
      "{`" {~ s <expr_list> s ~} <{ expect("`}") }> -> '__env.Pattern.Cc(%1)'
   }
   rule rule_simple_capt {
      "{" {~ s <rule_alt> s ~} <{ expect("}") }> -> '__env.Pattern.C(%1)'
   }
}

object Compiler {

   method predef(ctx, env) {
      for k,v in (env || global)  {
         ctx.define(k, { base = '(environ)' })
      }
   }

   method compile(lupa, name, env) {
      var ctx = Context.new(lupa)
      ctx.enter('(environ)')
      self.predef(ctx, env || global)
      var lua = Parser.match(lupa, 1, ctx)
      ctx.leave()
      assert(ctx.scope.outer == nil, "scope is unbalanced")
      return lua
   }
}

class Scope {
   has entries = { }
   has resolve = { }
   has exports = [ ]
   has hoists  = [ ]
   has inner   = [ ]
   has outer
   has kind

   method init(outer) {
      .outer = outer
      if outer {
         outer.inner.push(self)
      }
   }
   method lookup(name, pos, orig) {
      orig ||= self
      if .entries[name] {
         return .entries[name]
      }
      else if .outer {
         return .outer.lookup(name, pos, orig)
      }
      orig.resolve[name] = pos
   }
   method define(name, info) {
      .entries[name] = info || { }
   }
   method unhoist(sep) {
      var code = .hoists.concat(sep)
      if .hoists.len > 0 {
         .hoists = [ ]
      }
      return code
   }
}

import Proto, Dump from code

class Context {

   has scope  = Scope.new
   has source = ''

   has name
   has dump
   has main
   has proto
   has offs = 0
   has sync_line = 0
   has sync_seen = { }

   method init(name, source) {
      self.name = name
      self.main = Proto.new(Proto::VARARG)
      self.dump = Dump.new(self.main, '='+self.name)
      self.proto = self.main
      self.source = source
   }

   method enter(kind) {
      kind ||= .scope.kind
      .scope = Scope.new(.scope)
      .scope.kind = kind
   }
   method leave() {
      if .scope.hoists.len > 0 {
         error("unhoisted code: ${.scope.hoists}", 2)
      }
      var outer = .scope.outer
      var inner = .scope
      if outer != nil {
         .scope = outer
         return inner
      }
      Error raise "no outer scope"
   }
   method define(name, info) {
      info ||= { }
      if info['base'] != '(environ)' {
         info['proto'] = self.proto
      }
      .scope.define(name, info)
   }
   method lookup(name, pos) {
      var info = .scope.lookup(name, pos || .offs)
      if info && info::base != '(environ)' && info::proto == self.proto {
         self.proto.getvar(name)
      }
      return info
   }
   method update(name, pos) {
      var info = self.lookup(name, pos)
      if info && info::base != '(environ)' && info::proto == self.proto {
         self.proto.getvar(name)
      }
   }

   function count_lines(src, pos, idx) {
      var line = 0
      var index, limit = idx || 1, pos
      while index <= limit {
         var s, e = src.find("\n", index, true)
         if s == nil || e > limit { break }
         index = e + 1
         line  = line + 1
      }
      return line
   }

   for name, meth in Proto::__index {
      if self::__slots::[name] == nil {
         self::__slots::[name] = function(self, _1, _2, _3) {
            var proto = self.proto
            proto::[name](proto, _1, _2, _3)
         }
      }
   }

   method freereg { self.proto::freereg }
   method freereg=(free) { self.proto::freereg = free }

   method newvar(name, dest) {
      var info = self.proto.newvar(name, dest)
      return setmetatable(info, Table)
   }
   method nextreg(num) {
      var next = .proto.nextreg()
      if num && num > 1 {
         for i=1, num {
            .proto.nextreg()
         }
      }
      return next
   }
   method sync(node) {
      var offs = node['pos']
      if offs != nil && offs > self.offs {
         var prev = self.offs
         var line = count_lines(self.source, offs, prev + 1) + self.sync_line
         self.sync_line = line
         self.offs = offs
         self.proto.line(line)
      }
   }
   method emit(node, _1, _2, _3, _4) {
      var emit = Handler::[node['tag']]
      self.sync(node)
      return emit(Handler, self, node, _1, _2, _3, _4)
   }
   method call(name, node, _1, _2, _3, _4) {
      var call = Handler::[name]
      self.sync(node)
      return call(Handler, self, node, _1, _2, _3, _4)
   }
   method transform(ast) {
      self.emit(ast)
      return self.dump.pack()
   }
}

object Handler {
   method expr(ctx, node, _1, _2, _3) {
      ctx.emit(node[1], _1, _2, _3)
   }
   method infix_expr(ctx, node, d, a, b) {
      var free = ctx.freereg
      a ||= ctx.nextreg
      b ||= ctx.nextreg
      d ||= ctx.nextreg
      a = ctx.emit(node[1], a)
      b = ctx.emit(node[2], b)
      var o = node['oper']

      if      o == '+'  { ctx.op_add(d, a, b) }
      else if o == '-'  { ctx.op_sub(d, a, b) }
      else if o == '*'  { ctx.op_mul(d, a, b) }
      else if o == '/'  { ctx.op_div(d, a, b) }
      else if o == '%'  { ctx.op_mod(d, a, b) }
      else if o == '**' { ctx.op_pow(d, a, b) }
      else if o == '~'  { ctx.op_cat(d, a, b) }
      else {
         ctx.call('paren_expr', { a, { tag = 'name', { o } }, [ b ] })
      }

      ctx.freereg = free
      return d, a, b
   }
   method number(ctx, node, dest) {
      dest ||= ctx.nextreg
      ctx.op_load(dest, tonumber(node[1]))
      return dest
   }
   method bind_stmt(ctx, node, dest) {
   }
   method bind_expr(ctx, node, dest) {
   }
   method bind_list(ctx, node, dest) {
   }
   method bind_term(ctx, node, dest) {
   }
   method return_stmt(ctx, node) {
      var list = node[1]
      var vars = [ ]
      for i=1, list.len {
         vars[vars.len + 1] = ctx.emit(list[i], ctx.nextreg)
      }
      ctx.op_ret(vars[1], vars.len)
   }

   method member_expr(ctx, node, base, want) {
      var free = ctx.freereg
      var oper = node::oper
      var base = ctx.emit(node[1], base || ctx.nextreg)
      var name = ctx.emit(node[2])
      if oper == '::' {
         ctx.op_tget(base, base, name)
      }
      else {
         want ||= 0
         var recv = ctx.nextreg
         ctx.op_move(recv, base)
         ctx.op_tget(base, base, name)
         var args = [ recv ]
         var mres = false
         var narg = 1
         if node[3] {
            narg = node[3].len + 1
            ctx.nextreg(narg)
            for i=1, node[3].len {
               if i == node[3].len {
                  args[i + 1] = ctx.emit(node[3][i], base + i + 1, MULTIRES)
               }
               else {
                  args[i + 1] = ctx.emit(node[3][i], base + i + 1, 1)
               }
            }
         }
         for i=1, args.len {
            var arg = args[i]
            if arg == MULTIRES {
               mres = true
               break
            }
            if arg != nil && arg < base {
               ctx.op_move(ctx.nextreg, args[i])
            }
         }
         ctx.freereg = free
         if want == MULTIRES {
            ctx.op_call(base, want, narg)
            return MULTIRES
         }
         else if mres {
            ctx.op_callm(base, 0, narg - 1)
         }
         else {
            ctx.op_call(base, want, narg)
         }
         return base
      }
      ctx.freereg = free
      return base
   }

   our MULTIRES = -1

   method paren_expr(ctx, node, base, want) {
      want ||= 0
      var args = [ ]
      var free = ctx.freereg
      base ||= ctx.nextreg
      base = ctx.emit(node[1], base)
      var narg = node[2].len
      ctx.nextreg(narg)
      var mres = false
      for i=1, narg {
         if i == narg {
            args[i] = ctx.emit(node[2][i], base + i, MULTIRES)
         }
         else {
            args[i] = ctx.emit(node[2][i], base + i, 1)
         }
      }
      for i=1, args.len {
         var arg = args[i]
         if arg == MULTIRES {
            mres = true
            break
         }
         if arg != nil && arg < base {
            ctx.op_move(ctx.nextreg, args[i])
         }
      }
      ctx.freereg = free
      if want == MULTIRES {
         ctx.op_call(base, want, narg)
         return MULTIRES
      }
      else if mres {
         ctx.op_callm(base, 0, narg - 1)
      }
      else {
         ctx.op_call(base, want, narg)
      }
      return base
   }
   method string(ctx, node, dest) {
      dest ||= ctx.nextreg
      ctx.op_load(dest, node[1])
      return dest
   }
   method ident(ctx, node, dest) {
      var name = ctx.call('name', node[1])
      var info = ctx.lookup(name)
      if info && info::base != '(environ)' {
         if info::proto != ctx.proto {
            var idx = ctx.upval(name)
            dest ||= ctx.nextreg
            ctx.op_uget(dest, name)
            return dest
         }
         if dest && dest != info::idx {
            ctx.op_move(dest, info::idx)
            return dest
         }
         else {
            return info::idx
         }
      }
      else {
         dest ||= ctx.nextreg
         ctx.op_gget(dest, name)
         return dest
      }
   }
   method decl_stmt(ctx, node, _1, _2, _3) {
      return ctx.emit(node[1], _1, _2, _3)
   }
   method var_decl(ctx, node) {
      var kind = node['kind']
      var name_list = node[1]
      var expr_list = node[2]
      var info_list = [ ]
      for i=1, name_list.len {
         var name = ctx.call('name', name_list[i])
         var info = ctx.newvar(name)
         ctx.define(name, info)
         info_list.push(info)
      }
      var free = ctx.freereg
      var want = name_list.len
      for i=1, expr_list.len {
         want -= (i - 1)
         var expr = expr_list[i]
         var dest = info_list[i]::idx
         ctx.emit(expr, dest, want)
      }
      ctx.freereg = free
   }
   method func_decl(ctx, node, dest) {
      var proto = ctx.child(Proto::VARARG)
      var outer = ctx.proto
      ctx.proto = proto
      ctx.enter('lexical')
      var name = ctx.call('name', node[1])
      var args = node[2]
      var body = node[3]
      for i=1, args.len {
         var pname = ctx.call('name', args[1][i])
         var pidx = ctx.param(pname)
         ctx.define(pname, { idx = pidx })
      }
      for i=1, body.len - 1 {
         ctx.emit(body[i])
      }

      // last expr implies return
      if body.len > 0 {
         var last = body[body.len]
         if last[1]::tag == 'expr' {
            ctx.call('return_stmt', { [ last ] })
         }
         else {
            ctx.emit(last)
         }
      }

      ctx.proto = outer
      ctx.leave()

      if ctx.scope.kind == 'lexical' {
         dest ||= ctx.nextreg
         var info = ctx.newvar(name, dest)
         ctx.define(name, info)
         ctx.op_fnew(dest, proto::idx)
      }
      else {
         var dest = ctx.nextreg
         ctx.op_fnew(dest, proto::idx)
         ctx.op_gset(dest, name)
         ctx.freereg = dest
      }
      return proto::idx
   }
   method term(ctx, node, _1, _2) {
      return ctx.emit(node[1], _1, _2)
   }
   method name(ctx, node) {
      return node[1]
   }
   method stmt(ctx, node, _1, _2) {
      return ctx.emit(node[1], _1, _2)
   }
   method unit(ctx, node) {
      ctx.enter('main')
      for k,v in pairs(global) {
         ctx.define(k, { base = '(environ)' })
      }

      /*
      var info = ctx.newvar('(environ)')
      ctx.nextreg(2)

      ctx.op_tnew(1)
      ctx.op_tnew(2, 1)
      ctx.op_gget(3, "_G")
      ctx.op_tset(2, "__index", 3)
      ctx.op_gget(0, "setmetatable")
      ctx.op_call(0, 1, 2)

      ctx.freereg = 1
      */

      for i, stmt in ipairs(node) {
         ctx.emit(stmt)
      }
      ctx.leave()
   }
}


package::loaded::['lupa.lang'] = {
   Compiler = Compiler,
   Parser   = Parser,
   Context  = Context,
}

var src = '''
var mesg = "Hello"
function greet(whom) {
   print(mesg, whom, "!")
}
greet("World")
var a, b = 1, 40 + 2
'''

var src = '''
function a() {
   function c() {
      return 'Hi'
   }
   return c()
}
function b() {
   return 'Hello', 'World!'
}
print(a(), b())
'''
var src = '''
_G::print(_G::table::foreach)
_G.print()
'''
/*
for i=1, 1000 {
   var ast = Parser.script(src)
   var ctx = Context.new("test", src)
   var out = ctx.transform(ast)
   var fun = assert(loadstring(out))
}
*/
//Dump::DEBUG = true
var ast = Parser.script(src)
print(ASTUtil.dump(ast))
var ctx = Context.new("test", src)
var out = ctx.transform(ast)
var fun = assert(loadstring(out))
var bc  = require('jit.bc')
bc::dump(fun, nil, true)
setfenv(fun, setmetatable({ }, { __index = _G }))
fun()
//Compiler.compile(ast)

