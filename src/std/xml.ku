package XML {

    class Node {
        has data
        has type
        has parent

        method __tostring() {
            return self.as_string()
        }
        method as_string() {
            var type = self.type
            if type == 'COMMENT_NODE' {
                return "<!--%{self.data}-->"
            }
            else if type == 'DOCTYPE_DECLARATION' {
                return "<!DOCTYPE%{self.data}>"
            }
            else if type == 'PROCESSING_INSTRUCTION_NODE' {
                return "<?%{self.data}>"
            }
            else if type == 'CDATA_SECTION_NODE' {
                return "<![CDATA[%{self.data}]]>"
            }
            else {
                return self.data
            }
        }
    }

    class Element extends Node {
        has name
        has attributes = { }

        method __get_first_child() {
            return #self > 0 ? self::[1] : nil
        }
        method __get_last_child() {
            return self::[#self]
        }
        method __get_prev_sibling() {
            for i, node in self.parent {
                if node == self {
                    return i > 1 ? self.parent::[i - 1] : nil
                }
            }
        }
        method __get_next_sibling() {
            for i, node in self.parent {
                if node == self {
                    return i < #self.parent ? self.parent::[i + 1] : nil
                }
            }
        }
        method append(node) {
            Array::push(self, node)
        }
        method insert(new_child, ref_child) {
            for i, node in self {
                if node == ref_child {
                    return Array::insert(self, i, new_child)
                }
            }
        }
        method remove(ref_child) {
            for i, node in self {
                if node == ref_child {
                    return Array::remove(self, i)
                }
            }
        }
        method as_string() {
            var name = self.name
            var atts = self.attributes_as_string()

            if #atts > 0 {
                atts = " %{atts}"
            }

            if #self == 0 {
                return "<%{name}%{atts} />"
            }
            var kids = self.children_as_string()
            return "<%{name}%{atts}>%{kids}</%{name}>"
        }

        method __each() {
            return ipairs(self)
        }
        method __getitem(key) {
            return self.attributes[key]
        }
        method __setitem(key, val) {
            self.attributes[key] = val
        }

        method attributes_as_string() {
            var buff = [ ]
            for name, data in self.attributes {
                buff.push("%s=%q".format(name, data))
            }
            return buff.concat(" ")
        }

        method children_as_string() {
            var buff = [ ]
            for i, node in self {
                buff.push(node.as_string())
            }
            return buff.concat()
        }
    }
    
    class Document extends Element {
        has elements = { }

        method init() {
            var stack = [ self ]
            while #stack > 0 {
                var node = stack.pop()
                if node.type == "ELEMENT_NODE" {
                    if node.attributes['id'] {
                        self.elements[node.attributes['id']] = node
                    }
                }
                for i=#node, 1, -1 {
                    node::[i].parent = node
                    stack.push(node::[i])
                }
            }
            return self
        }

        method as_string() {
            return self.children_as_string()
        }
    }

    class Parser {

        method parse(xmlstr) {
            var xmldoc = self.xml.match(xmlstr)
            xmldoc.init()
            return xmldoc
        }

        function parse_error(s, i) {
            var msg = (#s < i + 20) ? s.sub(i) : s.sub(i, i+20)~"..."
            throw "parse error near '%s'".format(msg)
        }

        function backref(s, i, c) {
            if !c.isa(String) { return nil }
            var e = #c + i
            if s.sub(i, e - 1) == c {
                return e
            }
        }

        function Cbr(name) {
            return LPeg::Cmt(LPeg::Cb(name), backref)
        }

        function fold_attributes(list) {
            var atts = { }
            for i=1, #list, 2 {
                atts[list[i]] = list[i+1]
            }
            return atts
        }

        function create_document(xdoc) {
            return Document.bless(xdoc)
        }
        function create_doctype_node(node) {
            return Node.bless(node)
        }
        function create_element_node(node) {
            return Element.bless(node)
        }
        function create_cdata_node(node) {
            return Node.bless(node)
        }
        function create_text_node(node) {
            return Node.bless(node)
        }
        function create_comment_node(node) {
            return Node.bless(node)
        }
        function create_procins_node(node) {
            return Node.bless(node)
        }

        rule xml {
            <ws>* {% <document> %} -> create_document | <eos>
        }
        rule document {
            <doctype>? <markup> (<eos> | <{parse_error}>)
        }
        rule doctype {
            {% "<!DOCTYPE" {:data: [^>]+ :} {:type: {`"DOCTYPE_DECLARATION"`} :} ">" %}
            -> create_doctype_node
        }
        rule markup {
            ( {% <element> %} -> create_element_node
            | {% <cdata>   %} -> create_cdata_node
            | {% <text>    %} -> create_text_node
            | {% <comment> %} -> create_comment_node
            | {% <procins> %} -> create_procins_node
            )*
        }
        rule element {
            <tagOpen> <markup> (&<tagClose> | <{parse_error}>)
            <tagClose> | <tagOpenEmpty>
        }

        rule tagOpen {
            "<" (<tagName> <attrs> <ws>* ">" | <ws>* ">")
        }
        
        rule tagOpenEmpty {
            "<" (<tagName> <attrs> <ws>* "/>" | <ws>* "/>")
        }
        rule tagClose {
            "</" <{Cbr("name")}> <ws>* ">"
        }
        rule tagName {
            {:name: <ident> :} {:type: {`"ELEMENT_NODE"`} :}
        }
        rule text {
            {:data: [^><]+ :} {:type: {`"TEXT_NODE"`} :}
        }
        rule cdata {
            "<![CDATA[" {:data: (!"]]>" .)* :} "]]>" {:type: {`"CDATA_SECTION_NODE"`} :}
        }
        rule comment {
            "<!--" {:data: (!"-->" .)* :} "-->" {:type: {`"COMMENT_NODE"`} :}
        }
        rule procins {
            "<?" {:data: (!"?>" .)* :} "?>" {:type: {`"PROCESSING_INSTRUCTION_NODE"`} :}
        }
        rule attrs {
            {:attributes: {% <attr>* %} -> fold_attributes :}
        }
        rule attr {
            <ws>+ { <ident> } "=" <str>
        }
        rule str {
            '"' { (!'"' .)* } '"' | "'" { (!"'" .)* } "'"
        }
        rule ident {
            [a-zA-Z0-9_.:-]+
        }
        rule ws {
            %space
        }
        rule eos { !. }
    }
}

/*
var xmlstr = """
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta content="895" name="ku-session-keeper" id="ku-session-keeper" />
    <script src="/kudu/jslib/ku/core.js" type="text/javascript" />
    <link rel="stylesheet" href="/kudu/css/default.css" />
</head>
<body>
    <!-- this is a comment baby -->
    <div ku:replace="header" />
    <div ku:include="content" />
    <form ku:action="doit">...</form>
    <script type="text/javascript" id="my-script"><![CDATA[
    if ( foo > 42 ) {
        alert("cheese");
    }
    ]]>
    </script>
    <div foo="bar" baz="quux">This is My Div</div>
</body>
</html>
"""
var p = XML::Parser.new()
var d = p.parse(xmlstr)
print(d)
*/
